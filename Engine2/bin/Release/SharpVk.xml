<?xml version="1.0"?>
<doc>
    <assembly>
        <name>SharpVk</name>
    </assembly>
    <members>
        <member name="T:SharpVk.AccessFlags">
            <summary>
            <para>
            Bitmask specifying memory access types that will participate in a
            memory dependency.
            </para>
            <para>
            Certain access types are only performed by a subset of pipeline stages.
            Any synchronization command that takes both stage masks and access
            masks uses both to define the
            &lt;&lt;synchronization-dependencies-access-scopes, access
            scopes&gt;&gt; - only the specified access types performed by the
            specified stages are included in the access scope. An application must:
            not specify an access flag in a synchronization command if it does not
            include a pipeline stage in the corresponding stage mask that is able
            to perform accesses of that type. The following table lists, for each
            access flag, which pipeline stages can: perform that type of access.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.AccessFlags.None">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.AccessFlags.IndirectCommandRead">
            <summary>
            ename:VK_ACCESS_INDIRECT_COMMAND_READ_BIT: Read access to an
            indirect command structure read as part of an indirect drawing or
            dispatch command.
            </summary>
        </member>
        <member name="F:SharpVk.AccessFlags.IndexRead">
            <summary>
            ename:VK_ACCESS_INDEX_READ_BIT: Read access to an index buffer as
            part of an indexed drawing command, bound by
            flink:vkCmdBindIndexBuffer.
            </summary>
        </member>
        <member name="F:SharpVk.AccessFlags.VertexAttributeRead">
            <summary>
            ename:VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT: Read access to a vertex
            buffer as part of a drawing command, bound by
            flink:vkCmdBindVertexBuffers.
            </summary>
        </member>
        <member name="F:SharpVk.AccessFlags.UniformRead">
            <summary>
            ename:VK_ACCESS_UNIFORM_READ_BIT: Read access to a
            &lt;&lt;descriptorsets-uniformbuffer, uniform buffer&gt;&gt;.
            </summary>
        </member>
        <member name="F:SharpVk.AccessFlags.InputAttachmentRead">
            <summary>
            ename:VK_ACCESS_INPUT_ATTACHMENT_READ_BIT: Read access to an
            &lt;&lt;renderpass, input attachment&gt;&gt; within a renderpass
            during fragment shading.
            </summary>
        </member>
        <member name="F:SharpVk.AccessFlags.ShaderRead">
            <summary>
            ename:VK_ACCESS_SHADER_READ_BIT: Read access to a
            &lt;&lt;descriptorsets-storagebuffer, storage buffer&gt;&gt;,
            &lt;&lt;descriptorsets-uniformtexelbuffer, uniform texel
            buffer&gt;&gt;, &lt;&lt;descriptorsets-storagetexelbuffer, storage
            texel buffer&gt;&gt;, &lt;&lt;descriptorsets-sampledimage, sampled
            image&gt;&gt;, or &lt;&lt;descriptorsets-storageimage, storage
            image&gt;&gt;.
            </summary>
        </member>
        <member name="F:SharpVk.AccessFlags.ShaderWrite">
            <summary>
            ename:VK_ACCESS_SHADER_WRITE_BIT: Write access to a
            &lt;&lt;descriptorsets-storagebuffer, storage buffer&gt;&gt;,
            &lt;&lt;descriptorsets-storagetexelbuffer, storage texel
            buffer&gt;&gt;, or &lt;&lt;descriptorsets-storageimage, storage
            image&gt;&gt;.
            </summary>
        </member>
        <member name="F:SharpVk.AccessFlags.ColorAttachmentRead">
            <summary>
            ename:VK_ACCESS_COLOR_ATTACHMENT_READ_BIT: Read access to a
            &lt;&lt;renderpass, color attachment&gt;&gt;, such as via
            &lt;&lt;framebuffer-blending, blending&gt;&gt;,
            &lt;&lt;framebuffer-logicop, logic operations&gt;&gt;, or via
            certain &lt;&lt;renderpass-load-store-ops, subpass load
            operations&gt;&gt;.
            </summary>
        </member>
        <member name="F:SharpVk.AccessFlags.ColorAttachmentWrite">
            <summary>
            ename:VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT: Write access to a
            &lt;&lt;renderpass, color or resolve attachment&gt;&gt; during a
            &lt;&lt;renderpass, render pass&gt;&gt; or via certain
            &lt;&lt;renderpass-load-store-ops, subpass load and store
            operations&gt;&gt;.
            </summary>
        </member>
        <member name="F:SharpVk.AccessFlags.DepthStencilAttachmentRead">
            <summary>
            ename:VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT: Read access to a
            &lt;&lt;renderpass, depth/stencil attachment&gt;&gt;, via
            &lt;&lt;fragops-ds-state, depth or stencil operations&gt;&gt; or
            via certain &lt;&lt;renderpass-load-store-ops, subpass load
            operations&gt;&gt;.
            </summary>
        </member>
        <member name="F:SharpVk.AccessFlags.DepthStencilAttachmentWrite">
            <summary>
            ename:VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT: Write access to
            a &lt;&lt;renderpass, depth/stencil attachment&gt;&gt;, via
            &lt;&lt;fragops-ds-state, depth or stencil operations&gt;&gt; or
            via certain &lt;&lt;renderpass-load-store-ops, subpass load and
            store operations&gt;&gt;.
            </summary>
        </member>
        <member name="F:SharpVk.AccessFlags.TransferRead">
            <summary>
            ename:VK_ACCESS_TRANSFER_READ_BIT: Read access to an image or
            buffer in a &lt;&lt;copies, copy&gt;&gt; operation.
            </summary>
        </member>
        <member name="F:SharpVk.AccessFlags.TransferWrite">
            <summary>
            ename:VK_ACCESS_TRANSFER_WRITE_BIT: Write access to an image or
            buffer in a &lt;&lt;clears, clear&gt;&gt; or &lt;&lt;copies,
            copy&gt;&gt; operation.
            </summary>
        </member>
        <member name="F:SharpVk.AccessFlags.HostRead">
            <summary>
            ename:VK_ACCESS_HOST_READ_BIT: Read access by a host operation.
            Accesses of this type are not performed through a resource, but
            directly on memory.
            </summary>
        </member>
        <member name="F:SharpVk.AccessFlags.HostWrite">
            <summary>
            ename:VK_ACCESS_HOST_WRITE_BIT: Write access by a host operation.
            Accesses of this type are not performed through a resource, but
            directly on memory.
            </summary>
        </member>
        <member name="F:SharpVk.AccessFlags.MemoryRead">
            <summary>
            ename:VK_ACCESS_MEMORY_READ_BIT: Read access via non-specific
            entities. These entities include the Vulkan device and host, but
            may: also include entities external to the Vulkan device or
            otherwise not part of the core Vulkan pipeline. When included in a
            destination access mask, makes all available writes visible to all
            future read accesses on entities known to the Vulkan device.
            </summary>
        </member>
        <member name="F:SharpVk.AccessFlags.MemoryWrite">
            <summary>
            ename:VK_ACCESS_MEMORY_WRITE_BIT: Write access via non-specific
            entities. These entities include the Vulkan device and host, but
            may: also include entities external to the Vulkan device or
            otherwise not part of the core Vulkan pipeline. When included in a
            source access mask, all writes that are performed by entities known
            to the Vulkan device are made available. When included in a
            destination access mask, makes all available writes visible to all
            future write accesses on entities known to the Vulkan device.
            ifdef::VK_NVX_device_generated_commands[]
            </summary>
        </member>
        <member name="F:SharpVk.AccessFlags.CommandProcessRead">
            <summary>
            ename:VK_ACCESS_COMMAND_PROCESS_READ_BIT_NVX: Reads from
            sname:VkBuffer inputs to flink:vkCmdProcessCommandsNVX.
            </summary>
        </member>
        <member name="F:SharpVk.AccessFlags.CommandProcessWrite">
            <summary>
            ename:VK_ACCESS_COMMAND_PROCESS_WRITE_BIT_NVX: Writes to the target
            command buffer in flink:vkCmdProcessCommandsNVX.
            endif::VK_NVX_device_generated_commands[]
            </summary>
        </member>
        <member name="T:SharpVk.AllocationCallbacks">
            <summary>
            Structure containing callback function pointers for memory allocation.
            </summary>
        </member>
        <member name="P:SharpVk.AllocationCallbacks.UserData">
            <summary>
            pname:pUserData is a value to be interpreted by the implementation
            of the callbacks. When any of the callbacks in
            sname:VkAllocationCallbacks are called, the Vulkan implementation
            will pass this value as the first parameter to the callback. This
            value can: vary each time an allocator is passed into a command,
            even when the same object takes an allocator in multiple commands.
            </summary>
        </member>
        <member name="P:SharpVk.AllocationCallbacks.PfnAllocation">
            <summary>
            pname:pfnAllocation is a pointer to an application-defined memory
            allocation function of type tlink:PFN_vkAllocationFunction.
            </summary>
        </member>
        <member name="P:SharpVk.AllocationCallbacks.PfnReallocation">
            <summary>
            pname:pfnReallocation is a pointer to an application-defined memory
            reallocation function of type tlink:PFN_vkReallocationFunction.
            </summary>
        </member>
        <member name="P:SharpVk.AllocationCallbacks.PfnFree">
            <summary>
            pname:pfnFree is a pointer to an application-defined memory free
            function of type tlink:PFN_vkFreeFunction.
            </summary>
        </member>
        <member name="P:SharpVk.AllocationCallbacks.PfnInternalAllocation">
            <summary>
            pname:pfnInternalAllocation is a pointer to an application-defined
            function that is called by the implementation when the
            implementation makes internal allocations, and it is of type
            tlink:PFN_vkInternalAllocationNotification.
            </summary>
        </member>
        <member name="P:SharpVk.AllocationCallbacks.PfnInternalFree">
            <summary>
            pname:pfnInternalFree is a pointer to an application-defined
            function that is called by the implementation when the
            implementation frees internal allocations, and it is of type
            tlink:PFN_vkInternalFreeNotification.
            </summary>
        </member>
        <member name="T:SharpVk.AndroidSurfaceCreateFlags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.AndroidSurfaceCreateFlags.None">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.AndroidSurfaceCreateInfo">
            <summary>
            Structure specifying parameters of a newly created Android surface
            object.
            </summary>
        </member>
        <member name="P:SharpVk.AndroidSurfaceCreateInfo.Flags">
            <summary>
            pname:flags is reserved for future use.
            </summary>
        </member>
        <member name="P:SharpVk.AndroidSurfaceCreateInfo.Window">
            <summary>
            pname:window is a pointer to the code:ANativeWindow to associate
            the surface with.
            </summary>
        </member>
        <member name="T:SharpVk.ApplicationInfo">
            <summary>
            Structure specifying application info.
            </summary>
        </member>
        <member name="P:SharpVk.ApplicationInfo.ApplicationName">
            <summary>
            pname:pApplicationName is a pointer to a null-terminated UTF-8
            string containing the name of the application.
            </summary>
        </member>
        <member name="P:SharpVk.ApplicationInfo.ApplicationVersion">
            <summary>
            pname:applicationVersion is an unsigned integer variable containing
            the developer-supplied version number of the application.
            </summary>
        </member>
        <member name="P:SharpVk.ApplicationInfo.EngineName">
            <summary>
            pname:pEngineName is a pointer to a null-terminated UTF-8 string
            containing the name of the engine (if any) used to create the
            application.
            </summary>
        </member>
        <member name="P:SharpVk.ApplicationInfo.EngineVersion">
            <summary>
            pname:engineVersion is an unsigned integer variable containing the
            developer-supplied version number of the engine used to create the
            application.
            </summary>
        </member>
        <member name="P:SharpVk.ApplicationInfo.ApiVersion">
            <summary>
            pname:apiVersion is the version of the Vulkan API against which the
            application expects to run, encoded as described in the
            &lt;&lt;fundamentals-versionnum,API Version Numbers and
            Semantics&gt;&gt; section. If pname:apiVersion is 0 the
            implementation must: ignore it, otherwise if the implementation
            does not support the requested pname:apiVersion it must: return
            ename:VK_ERROR_INCOMPATIBLE_DRIVER. The patch version number
            specified in pname:apiVersion is ignored when creating an instance
            object. Only the major and minor versions of the instance must:
            match those requested in pname:apiVersion.
            </summary>
        </member>
        <member name="T:SharpVk.ArrayProxy`1">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:SharpVk.ArrayProxy`1.Contents">
            <summary>
            
            </summary>
        </member>
        <member name="P:SharpVk.ArrayProxy`1.Item(System.Int32)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:SharpVk.ArrayProxy`1.Length">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:SharpVk.ArrayProxy`1.GetSingleValue">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:SharpVk.ArrayProxy`1.GetArrayValue">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:SharpVk.ArrayProxy`1.Null">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.ArrayProxy`1.op_Implicit(`0[])~SharpVk.ArrayProxy{`0}">
            <summary>
            
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:SharpVk.ArrayProxy`1.op_Implicit(System.ArraySegment{`0})~SharpVk.ArrayProxy{`0}">
            <summary>
            
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:SharpVk.ArrayProxy`1.op_Implicit(`0)~SharpVk.ArrayProxy{`0}">
            <summary>
            
            </summary>
            <param name="value"></param>
        </member>
        <member name="T:SharpVk.ProxyContents">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.ProxyContents.Null">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.ProxyContents.Single">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.ProxyContents.Array">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.AttachmentDescription">
            <summary>
            Structure specifying an attachment description.
            </summary>
        </member>
        <member name="M:SharpVk.AttachmentDescription.#ctor(SharpVk.AttachmentDescriptionFlags,SharpVk.Format,SharpVk.SampleCountFlags,SharpVk.AttachmentLoadOp,SharpVk.AttachmentStoreOp,SharpVk.AttachmentLoadOp,SharpVk.AttachmentStoreOp,SharpVk.ImageLayout,SharpVk.ImageLayout)">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.AttachmentDescription.Flags">
            <summary>
            pname:flags is a bitmask describing additional properties of the
            attachment. Bits which can: be set include: + --
            </summary>
        </member>
        <member name="F:SharpVk.AttachmentDescription.Format">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.AttachmentDescription.Samples">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.AttachmentDescription.LoadOp">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.AttachmentDescription.StoreOp">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.AttachmentDescription.StencilLoadOp">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.AttachmentDescription.StencilStoreOp">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.AttachmentDescription.InitialLayout">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.AttachmentDescription.FinalLayout">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.AttachmentDescription.ToString">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.AttachmentDescriptionFlags">
            <summary>
            Bitmask specifying additional properties of an attachment.
            </summary>
        </member>
        <member name="F:SharpVk.AttachmentDescriptionFlags.None">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.AttachmentDescriptionFlags.MayAlias">
            <summary>
            The attachment may alias physical memory of another attachment in
            the same render pass
            </summary>
        </member>
        <member name="T:SharpVk.AttachmentLoadOp">
            <summary>
            Specify how contents of an attachment are treated at the beginning of a
            subpass.
            </summary>
        </member>
        <member name="F:SharpVk.AttachmentLoadOp.Load">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.AttachmentLoadOp.Clear">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.AttachmentLoadOp.DontCare">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.AttachmentReference">
            <summary>
            Structure specifying an attachment reference.
            </summary>
        </member>
        <member name="M:SharpVk.AttachmentReference.#ctor(System.UInt32,SharpVk.ImageLayout)">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.AttachmentReference.Attachment">
            <summary>
            pname:attachment is the index of the attachment of the render pass,
            and corresponds to the index of the corresponding element in the
            pname:pAttachments array of the sname:VkRenderPassCreateInfo
            structure. If any color or depth/stencil attachments are
            ename:VK_ATTACHMENT_UNUSED, then no writes occur for those
            attachments.
            </summary>
        </member>
        <member name="F:SharpVk.AttachmentReference.Layout">
            <summary>
            pname:layout is a elink:VkImageLayout value specifying the layout
            the attachment uses during the subpass.
            </summary>
        </member>
        <member name="M:SharpVk.AttachmentReference.ToString">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.AttachmentStoreOp">
            <summary>
            <para>
            Specify how contents of an attachment are treated at the end of a
            subpass.
            </para>
            <para>
            If the attachment uses a color format, then pname:loadOp and
            pname:storeOp are used, and pname:stencilLoadOp and
            pname:stencilStoreOp are ignored. If the format has depth and/or
            stencil components, pname:loadOp and pname:storeOp apply only to the
            depth data, while pname:stencilLoadOp and pname:stencilStoreOp define
            how the stencil data is handled. pname:loadOp and pname:stencilLoadOp
            define the _load operations_ that execute as part of the first subpass
            that uses the attachment. pname:storeOp and pname:stencilStoreOp define
            the _store operations_ that execute as part of the last subpass that
            uses the attachment.
            </para>
            <para>
            The load operation for each value in an attachment used by a subpass
            happens-before any command recorded into that subpass reads from that
            value. Load operations for attachments with a depth/stencil format
            execute in the ename:VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT
            pipeline stage. Load operations for attachments with a color format
            execute in the ename:VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT
            pipeline stage.
            </para>
            <para>
            Store operations for each value in an attachment used by a subpass
            happen-after any command recorded into that subpass writes to that
            value. Store operations for attachments with a depth/stencil format
            execute in the ename:VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT pipeline
            stage. Store operations for attachments with a color format execute in
            the ename:VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT pipeline stage.
            </para>
            <para>
            If an attachment is not used by any subpass, then pname:loadOp,
            pname:storeOp, pname:stencilStoreOp, and pname:stencilLoadOp are
            ignored, and the attachment's memory contents will not be modified by
            execution of a render pass instance.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.AttachmentStoreOp.Store">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.AttachmentStoreOp.DontCare">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.BindSparseInfo">
            <summary>
            Structure specifying a sparse binding operation.
            </summary>
        </member>
        <member name="P:SharpVk.BindSparseInfo.WaitSemaphores">
            <summary>
            pname:pWaitSemaphores is a pointer to an array of semaphores upon
            which to wait on before the sparse binding operations for this
            batch begin execution. If semaphores to wait on are provided, they
            define a &lt;&lt;synchronization-semaphores-waiting, semaphore wait
            operation&gt;&gt;.
            </summary>
        </member>
        <member name="P:SharpVk.BindSparseInfo.BufferBinds">
            <summary>
            pname:pBufferBinds is a pointer to an array of
            slink:VkSparseBufferMemoryBindInfo structures.
            </summary>
        </member>
        <member name="P:SharpVk.BindSparseInfo.ImageOpaqueBinds">
            <summary>
            pname:pImageOpaqueBinds is a pointer to an array of
            slink:VkSparseImageOpaqueMemoryBindInfo structures, indicating
            opaque sparse image bindings to perform.
            </summary>
        </member>
        <member name="P:SharpVk.BindSparseInfo.ImageBinds">
            <summary>
            pname:pImageBinds is a pointer to an array of
            slink:VkSparseImageMemoryBindInfo structures, indicating sparse
            image bindings to perform.
            </summary>
        </member>
        <member name="P:SharpVk.BindSparseInfo.SignalSemaphores">
            <summary>
            pname:pSignalSemaphores is a pointer to an array of semaphores
            which will be signaled when the sparse binding operations for this
            batch have completed execution. If semaphores to be signaled are
            provided, they define a
            &lt;&lt;synchronization-semaphores-signaling, semaphore signal
            operation&gt;&gt;.
            </summary>
        </member>
        <member name="T:SharpVk.BlendFactor">
            <summary>
            <para>
            Framebuffer blending factors.
            </para>
            <para>
            The semantics of each enum value is described in the table below:
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.BlendFactor.Zero">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.BlendFactor.One">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.BlendFactor.SourceColor">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.BlendFactor.OneMinusSourceColor">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.BlendFactor.DestinationColor">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.BlendFactor.OneMinusDestinationColor">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.BlendFactor.SourceAlpha">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.BlendFactor.OneMinusSourceAlpha">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.BlendFactor.DestinationAlpha">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.BlendFactor.OneMinusDestinationAlpha">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.BlendFactor.ConstantColor">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.BlendFactor.OneMinusConstantColor">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.BlendFactor.ConstantAlpha">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.BlendFactor.OneMinusConstantAlpha">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.BlendFactor.SourceAlphaSaturate">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.BlendFactor.Src1Color">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.BlendFactor.OneMinusSrc1Color">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.BlendFactor.Src1Alpha">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.BlendFactor.OneMinusSrc1Alpha">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.BlendOp">
            <summary>
            <para>
            Framebuffer blending operations.
            </para>
            <para>
            &lt;&lt;&lt;
            </para>
            <para>
            The semantics of each enum value is described in the table below:
            </para>
            <para>
            .Blend Operations
            [width="100%",cols="45%,30%,25%",options="header",align="center"] |====
            |VkBlendOp | RGB Components | Alpha Component
            </para>
            <para>
            |ename:VK_BLEND_OP_ADD | [eq]#R = R~s0~ {times} S~r~ + R~d~ {times}
            D~r~# + [eq]#G = G~s0~ {times} S~g~ + G~d~ {times} D~g~# + [eq]#B =
            B~s0~ {times} S~b~ + B~d~ {times} D~b~# | [eq]#A = A~s0~ {times} S~a~ +
            A~d~ {times} D~a~#
            </para>
            <para>
            |ename:VK_BLEND_OP_SUBTRACT | [eq]#R = R~s0~ {times} S~r~ - R~d~
            {times} D~r~# + [eq]#G = G~s0~ {times} S~g~ - G~d~ {times} D~g~# +
            [eq]#B = B~s0~ {times} S~b~ - B~d~ {times} D~b~# | [eq]#A = A~s0~
            {times} S~a~ - A~d~ {times} D~a~#
            </para>
            <para>
            |ename:VK_BLEND_OP_REVERSE_SUBTRACT | [eq]#R = R~d~ {times} D~r~ -
            R~s0~ {times} S~r~# + [eq]#G = G~d~ {times} D~g~ - G~s0~ {times} S~g~#
            + [eq]#B = B~d~ {times} D~b~ - B~s0~ {times} S~b~# | [eq]#A = A~d~
            {times} D~a~ - A~s0~ {times} S~a~#
            </para>
            <para>
            |ename:VK_BLEND_OP_MIN | [eq]#R = min(R~s0~,R~d~)# + [eq]#G =
            min(G~s0~,G~d~)# + [eq]#B = min(B~s0~,B~d~)# | [eq]#A =
            min(A~s0~,A~d~)#
            </para>
            <para>
            |ename:VK_BLEND_OP_MAX | [eq]#R = max(R~s0~,R~d~)# + [eq]#G =
            max(G~s0~,G~d~)# + [eq]#B = max(B~s0~,B~d~)# | [eq]#A =
            max(A~s0~,A~d~)# |====
            </para>
            <para>
            In this table, the following conventions are used:
            </para>
            <para>
            * [eq]#R~s0~, G~s0~, B~s0~# and [eq]#A~s0~# represent the first source
            color R, G, B, and A components, respectively. * [eq]#R~d~, G~d~, B~d~#
            and [eq]#A~d~# represent the R, G, B, and A components of the
            destination color. That is, the color currently in the corresponding
            color attachment for this fragment/sample. * [eq]#S~r~, S~g~, S~b~# and
            [eq]#S~a~# represent the source blend factor R, G, B, and A components,
            respectively. * [eq]#D~r~, D~g~, D~b~# and [eq]#D~a~# represent the
            destination blend factor R, G, B, and A components, respectively.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.BlendOp.Add">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.BlendOp.Subtract">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.BlendOp.ReverseSubtract">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.BlendOp.Min">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.BlendOp.Max">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.BorderColor">
            <summary>
            <para>
            Specify border color used for texture lookups.
            </para>
            <para>
            [NOTE] .Mapping of OpenGL to Vulkan filter modes ==================
            pname:magFilter values of ename:VK_FILTER_NEAREST and
            ename:VK_FILTER_LINEAR directly correspond to code:GL_NEAREST and
            code:GL_LINEAR magnification filters. pname:minFilter and
            pname:mipmapMode combine to correspond to the similarly named OpenGL
            minification filter of code:GL_minFilter_MIPMAP_mipmapMode (e.g.
            pname:minFilter of ename:VK_FILTER_LINEAR and pname:mipmapMode of
            ename:VK_SAMPLER_MIPMAP_MODE_NEAREST correspond to
            code:GL_LINEAR_MIPMAP_NEAREST).
            </para>
            <para>
            There are no Vulkan filter modes that directly correspond to OpenGL
            minification filters of code:GL_LINEAR or code:GL_NEAREST, but they
            can: be emulated using ename:VK_SAMPLER_MIPMAP_MODE_NEAREST,
            pname:minLod = 0, and pname:maxLod = 0.25, and using pname:minFilter =
            ename:VK_FILTER_LINEAR or pname:minFilter = ename:VK_FILTER_NEAREST,
            respectively.
            </para>
            <para>
            Note that using a pname:maxLod of zero would cause
            &lt;&lt;textures-texel-filtering,magnification&gt;&gt; to always be
            performed, and the pname:magFilter to always be used. This is valid,
            just not an exact match for OpenGL behavior. Clamping the maximum LOD
            to 0.25 allows the [eq]#{lambda}# value to be non-zero and minification
            to be performed, while still always rounding down to the base level. If
            the pname:minFilter and pname:magFilter are equal, then using a
            pname:maxLod of zero also works. ==================
            </para>
            <para>
            pname:addressModeU, pname:addressModeV, and pname:addressModeW must:
            each have one of the following values:
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.BorderColor.FloatTransparentBlack">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.BorderColor.IntTransparentBlack">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.BorderColor.FloatOpaqueBlack">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.BorderColor.IntOpaqueBlack">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.BorderColor.FloatOpaqueWhite">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.BorderColor.IntOpaqueWhite">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Buffer">
            <summary>
            <para>
            Opaque handle to a buffer object.
            </para>
            <para>
            Buffers represent linear arrays of data which are used for various
            purposes by binding them to a graphics or compute pipeline via
            descriptor sets or via certain commands, or by directly specifying them
            as parameters to certain commands.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Buffer.BindMemory(SharpVk.DeviceMemory,SharpVk.DeviceSize)">
            <summary>
            Bind device memory to a buffer object.
            </summary>
        </member>
        <member name="M:SharpVk.Buffer.GetMemoryRequirements">
            <summary>
            Returns the memory requirements for specified Vulkan object.
            </summary>
        </member>
        <member name="M:SharpVk.Buffer.Destroy">
            <summary>
            Destroy a buffer object.
            </summary>
        </member>
        <member name="P:SharpVk.Buffer.RawHandle">
            <summary>
            The interop handle for this Buffer.
            </summary>
        </member>
        <member name="M:SharpVk.Buffer.Dispose">
            <summary>
            Releases the unmanaged resources associated with this instance and
            destroys the underlying Vulkan handle.
            </summary>
        </member>
        <member name="T:SharpVk.BufferCopy">
            <summary>
            Structure specifying a buffer copy operation.
            </summary>
        </member>
        <member name="M:SharpVk.BufferCopy.#ctor(SharpVk.DeviceSize,SharpVk.DeviceSize,SharpVk.DeviceSize)">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.BufferCopy.SourceOffset">
            <summary>
            pname:srcOffset is the starting offset in bytes from the start of
            pname:srcBuffer.
            </summary>
        </member>
        <member name="F:SharpVk.BufferCopy.DestinationOffset">
            <summary>
            pname:dstOffset is the starting offset in bytes from the start of
            pname:dstBuffer.
            </summary>
        </member>
        <member name="F:SharpVk.BufferCopy.Size">
            <summary>
            pname:size is the number of bytes to copy.
            </summary>
        </member>
        <member name="M:SharpVk.BufferCopy.ToString">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.BufferCreateFlags">
            <summary>
            <para>
            Bitmask specifying additional parameters of a buffer.
            </para>
            <para>
            See &lt;&lt;sparsememory-sparseresourcefeatures,Sparse Resource
            Features&gt;&gt; and &lt;&lt;features-features,Physical Device
            Features&gt;&gt; for details of the sparse memory features supported on
            a device.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.BufferCreateFlags.None">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.BufferCreateFlags.SparseBinding">
            <summary>
            ename:VK_BUFFER_CREATE_SPARSE_BINDING_BIT indicates that the buffer
            will be backed using sparse memory binding.
            </summary>
        </member>
        <member name="F:SharpVk.BufferCreateFlags.SparseResidency">
            <summary>
            ename:VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT indicates that the
            buffer can: be partially backed using sparse memory binding.
            Buffers created with this flag must: also be created with the
            ename:VK_BUFFER_CREATE_SPARSE_BINDING_BIT flag.
            </summary>
        </member>
        <member name="F:SharpVk.BufferCreateFlags.SparseAliased">
            <summary>
            ename:VK_BUFFER_CREATE_SPARSE_ALIASED_BIT indicates that the buffer
            will be backed using sparse memory binding with memory ranges that
            might also simultaneously be backing another buffer (or another
            portion of the same buffer). Buffers created with this flag must:
            also be created with the ename:VK_BUFFER_CREATE_SPARSE_BINDING_BIT
            flag.
            </summary>
        </member>
        <member name="T:SharpVk.BufferCreateInfo">
            <summary>
            <para>
            Structure specifying the parameters of a newly created buffer object.
            </para>
            <para>
            Bits which can: be set in pname:usage are:
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.BufferCreateInfo.Flags">
            <summary>
            pname:flags is a bitmask describing additional parameters of the
            buffer. See elink:VkBufferCreateFlagBits below for a description of
            the supported bits.
            </summary>
        </member>
        <member name="P:SharpVk.BufferCreateInfo.Size">
            <summary>
            pname:size is the size in bytes of the buffer to be created.
            </summary>
        </member>
        <member name="P:SharpVk.BufferCreateInfo.Usage">
            <summary>
            pname:usage is a bitmask describing the allowed usages of the
            buffer. See elink:VkBufferUsageFlagBits below for a description of
            the supported bits.
            </summary>
        </member>
        <member name="P:SharpVk.BufferCreateInfo.SharingMode">
            <summary>
            pname:sharingMode is the sharing mode of the buffer when it will be
            accessed by multiple queue families, see elink:VkSharingMode in the
            &lt;&lt;resources-sharing,Resource Sharing&gt;&gt; section below
            for supported values.
            </summary>
        </member>
        <member name="P:SharpVk.BufferCreateInfo.QueueFamilyIndices">
            <summary>
            pname:pQueueFamilyIndices is a list of queue families that will
            access this buffer (ignored if pname:sharingMode is not
            ename:VK_SHARING_MODE_CONCURRENT).
            </summary>
        </member>
        <member name="T:SharpVk.BufferImageCopy">
            <summary>
            <para>
            Structure specifying a buffer image copy operation.
            </para>
            <para>
            When copying to or from a depth or stencil aspect, the data in buffer
            memory uses a layout that is a (mostly) tightly packed representation
            of the depth or stencil data. Specifically:
            </para>
            <para>
            * data copied to or from the stencil aspect of any depth/stencil format
            is tightly packed with one ename:VK_FORMAT_S8_UINT value per texel. *
            data copied to or from the depth aspect of a ename:VK_FORMAT_D16_UNORM
            or ename:VK_FORMAT_D16_UNORM_S8_UINT format is tightly packed with one
            ename:VK_FORMAT_D16_UNORM value per texel. * data copied to or from the
            depth aspect of a ename:VK_FORMAT_D32_SFLOAT or
            ename:VK_FORMAT_D32_SFLOAT_S8_UINT format is tightly packed with one
            ename:VK_FORMAT_D32_SFLOAT value per texel. * data copied to or from
            the depth aspect of a ename:VK_FORMAT_X8_D24_UNORM_PACK32 or
            ename:VK_FORMAT_D24_UNORM_S8_UINT format is packed with one 32-bit word
            per texel with the D24 value in the LSBs of the word, and undefined
            values in the eight MSBs.
            </para>
            <para>
            [NOTE] .Note ==== To copy both the depth and stencil aspects of a
            depth/stencil format, two entries in pname:pRegions can: be used, where
            one specifies the depth aspect in pname:imageSubresource, and the other
            specifies the stencil aspect. ====
            </para>
            <para>
            Because depth or stencil aspect buffer to image copies may: require
            format conversions on some implementations, they are not supported on
            queues that do not support graphics. When copying to a depth aspect,
            the data in buffer memory must: be in the the range [eq]#[0,1]# or
            undefined results occur.
            </para>
            <para>
            Copies are done layer by layer starting with image layer
            pname:baseArrayLayer member of pname:imageSubresource. pname:layerCount
            layers are copied from the source image or to the destination image.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.BufferImageCopy.#ctor(SharpVk.DeviceSize,System.UInt32,System.UInt32,SharpVk.ImageSubresourceLayers,SharpVk.Offset3D,SharpVk.Extent3D)">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.BufferImageCopy.BufferOffset">
            <summary>
            pname:bufferOffset is the offset in bytes from the start of the
            buffer object where the image data is copied from or to.
            </summary>
        </member>
        <member name="F:SharpVk.BufferImageCopy.BufferRowLength">
            <summary>
            pname:bufferRowLength and pname:bufferImageHeight specify the data
            in buffer memory as a subregion of a larger two- or
            three-dimensional image, and control the addressing calculations of
            data in buffer memory. If either of these values is zero, that
            aspect of the buffer memory is considered to be tightly packed
            according to the pname:imageExtent.
            </summary>
        </member>
        <member name="F:SharpVk.BufferImageCopy.BufferImageHeight">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.BufferImageCopy.ImageSubresource">
            <summary>
            pname:imageSubresource is a slink:VkImageSubresourceLayers used to
            specify the specific image subresources of the image used for the
            source or destination image data.
            </summary>
        </member>
        <member name="F:SharpVk.BufferImageCopy.ImageOffset">
            <summary>
            pname:imageOffset selects the initial x, y, z offsets in texels of
            the sub-region of the source or destination image data.
            </summary>
        </member>
        <member name="F:SharpVk.BufferImageCopy.ImageExtent">
            <summary>
            pname:imageExtent is the size in texels of the image to copy in
            pname:width, pname:height and pname:depth.
            </summary>
        </member>
        <member name="M:SharpVk.BufferImageCopy.ToString">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.BufferMemoryBarrier">
            <summary>
            <para>
            Structure specifying a buffer memory barrier.
            </para>
            <para>
            The first &lt;&lt;synchronization-dependencies-access-scopes, access
            scope&gt;&gt; is limited to access to memory through the specified
            buffer range, via access types in the
            &lt;&lt;synchronization-access-masks, source access mask&gt;&gt;
            specified by pname:srcAccessMask. If pname:srcAccessMask includes
            ename:VK_ACCESS_HOST_WRITE_BIT, memory writes performed by that access
            type are also made visible, as that access type is not performed
            through a resource.
            </para>
            <para>
            The second &lt;&lt;synchronization-dependencies-access-scopes, access
            scope&gt;&gt; is limited to access to memory through the specified
            buffer range, via access types in the
            &lt;&lt;synchronization-access-masks, destination access mask&gt;&gt;
            specified by pname:dstAccessMask. If pname:dstAccessMask includes
            ename:VK_ACCESS_HOST_WRITE_BIT or ename:VK_ACCESS_HOST_READ_BIT,
            available memory writes are also made visible to accesses of those
            types, as those access types are not performed through a resource.
            </para>
            <para>
            If pname:srcQueueFamilyIndex is not equal to pname:dstQueueFamilyIndex,
            and pname:srcQueueFamilyIndex is equal to the current queue family,
            then the memory barrier defines a
            &lt;&lt;synchronization-queue-transfers-release, queue family release
            operation&gt;&gt; for the specified buffer range, and the second access
            scope includes no access, as if pname:dstAccessMask was `0`.
            </para>
            <para>
            If pname:dstQueueFamilyIndex is not equal to pname:srcQueueFamilyIndex,
            and pname:dstQueueFamilyIndex is equal to the current queue family,
            then the memory barrier defines a
            &lt;&lt;synchronization-queue-transfers-acquire, queue family acquire
            operation&gt;&gt; for the specified buffer range, and the first access
            scope includes no access, as if pname:srcAccessMask was `0`.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.BufferMemoryBarrier.SourceAccessMask">
            <summary>
            pname:srcAccessMask defines a &lt;&lt;synchronization-access-masks,
            source access mask&gt;&gt;.
            </summary>
        </member>
        <member name="P:SharpVk.BufferMemoryBarrier.DestinationAccessMask">
            <summary>
            pname:dstAccessMask defines a &lt;&lt;synchronization-access-masks,
            destination access mask&gt;&gt;.
            </summary>
        </member>
        <member name="P:SharpVk.BufferMemoryBarrier.SourceQueueFamilyIndex">
            <summary>
            pname:srcQueueFamilyIndex is the source queue family for a
            &lt;&lt;synchronization-queue-transfers, queue family ownership
            transfer&gt;&gt;.
            </summary>
        </member>
        <member name="P:SharpVk.BufferMemoryBarrier.DestinationQueueFamilyIndex">
            <summary>
            pname:dstQueueFamilyIndex is the destination queue family for a
            &lt;&lt;synchronization-queue-transfers, queue family ownership
            transfer&gt;&gt;.
            </summary>
        </member>
        <member name="P:SharpVk.BufferMemoryBarrier.Buffer">
            <summary>
            pname:buffer is a handle to the buffer whose backing memory is
            affected by the barrier.
            </summary>
        </member>
        <member name="P:SharpVk.BufferMemoryBarrier.Offset">
            <summary>
            pname:offset is an offset in bytes into the backing memory for
            pname:buffer; this is relative to the base offset as bound to the
            buffer (see flink:vkBindBufferMemory).
            </summary>
        </member>
        <member name="P:SharpVk.BufferMemoryBarrier.Size">
            <summary>
            pname:size is a size in bytes of the affected area of backing
            memory for pname:buffer, or ename:VK_WHOLE_SIZE to use the range
            from pname:offset to the end of the buffer.
            </summary>
        </member>
        <member name="T:SharpVk.BufferUsageFlags">
            <summary>
            <para>
            Bitmask specifying allowed usage of a buffer.
            </para>
            <para>
            Any combination of bits can: be specified for pname:usage, but at least
            one of the bits must: be set in order to create a valid buffer.
            </para>
            <para>
            Bits which can: be set in pname:flags are:
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.BufferUsageFlags.None">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.BufferUsageFlags.TransferSource">
            <summary>
            ename:VK_BUFFER_USAGE_TRANSFER_SRC_BIT indicates that the buffer
            can: be used as the source of a _transfer command_ (see the
            definition of &lt;&lt;synchronization-pipeline-stages-transfer,
            ename:VK_PIPELINE_STAGE_TRANSFER_BIT&gt;&gt;).
            </summary>
        </member>
        <member name="F:SharpVk.BufferUsageFlags.TransferDestination">
            <summary>
            ename:VK_BUFFER_USAGE_TRANSFER_DST_BIT indicates that the buffer
            can: be used as the destination of a transfer command.
            </summary>
        </member>
        <member name="F:SharpVk.BufferUsageFlags.UniformTexelBuffer">
            <summary>
            ename:VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT indicates that the
            buffer can: be used to create a sname:VkBufferView suitable for
            occupying a sname:VkDescriptorSet slot of type
            ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER.
            </summary>
        </member>
        <member name="F:SharpVk.BufferUsageFlags.StorageTexelBuffer">
            <summary>
            ename:VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT indicates that the
            buffer can: be used to create a sname:VkBufferView suitable for
            occupying a sname:VkDescriptorSet slot of type
            ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER.
            </summary>
        </member>
        <member name="F:SharpVk.BufferUsageFlags.UniformBuffer">
            <summary>
            ename:VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT indicates that the buffer
            can: be used in a sname:VkDescriptorBufferInfo suitable for
            occupying a sname:VkDescriptorSet slot either of type
            ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or
            ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC.
            </summary>
        </member>
        <member name="F:SharpVk.BufferUsageFlags.StorageBuffer">
            <summary>
            ename:VK_BUFFER_USAGE_STORAGE_BUFFER_BIT indicates that the buffer
            can: be used in a sname:VkDescriptorBufferInfo suitable for
            occupying a sname:VkDescriptorSet slot either of type
            ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or
            ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC.
            </summary>
        </member>
        <member name="F:SharpVk.BufferUsageFlags.IndexBuffer">
            <summary>
            ename:VK_BUFFER_USAGE_INDEX_BUFFER_BIT indicates that the buffer is
            suitable for passing as the pname:buffer parameter to
            fname:vkCmdBindIndexBuffer.
            </summary>
        </member>
        <member name="F:SharpVk.BufferUsageFlags.VertexBuffer">
            <summary>
            ename:VK_BUFFER_USAGE_VERTEX_BUFFER_BIT indicates that the buffer
            is suitable for passing as an element of the pname:pBuffers array
            to fname:vkCmdBindVertexBuffers.
            </summary>
        </member>
        <member name="F:SharpVk.BufferUsageFlags.IndirectBuffer">
            <summary>
            ename:VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT indicates that the buffer
            is suitable for passing as the pname:buffer parameter to
            fname:vkCmdDrawIndirect, fname:vkCmdDrawIndexedIndirect, or
            fname:vkCmdDispatchIndirect. ifdef::VK_NVX_device_generated_commands[]
            It is also suitable for passing as the pname:buffer member of
            sname:VkIndirectCommandsTokenNVX, or pname:sequencesCountBuffer or
            pname:sequencesIndexBuffer member of
            sname:VkCmdProcessCommandsInfoNVX endif::VK_NVX_device_generated_commands[]
            </summary>
        </member>
        <member name="T:SharpVk.BufferView">
            <summary>
            <para>
            Opaque handle to a buffer view object.
            </para>
            <para>
            A _buffer view_ represents a contiguous range of a buffer and a
            specific format to be used to interpret the data. Buffer views are used
            to enable shaders to access buffer contents interpreted as formatted
            data. In order to create a valid buffer view, the buffer must: have
            been created with at least one of the following usage flags:
            </para>
            <para>
            * ename:VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT *
            ename:VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.BufferView.Destroy">
            <summary>
            Destroy a buffer view object.
            </summary>
        </member>
        <member name="P:SharpVk.BufferView.RawHandle">
            <summary>
            The interop handle for this BufferView.
            </summary>
        </member>
        <member name="M:SharpVk.BufferView.Dispose">
            <summary>
            Releases the unmanaged resources associated with this instance and
            destroys the underlying Vulkan handle.
            </summary>
        </member>
        <member name="T:SharpVk.BufferViewCreateFlags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.BufferViewCreateFlags.None">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.BufferViewCreateInfo">
            <summary>
            Structure specifying parameters of a newly created buffer view.
            </summary>
        </member>
        <member name="P:SharpVk.BufferViewCreateInfo.Flags">
            <summary>
            pname:flags is reserved for future use.
            </summary>
        </member>
        <member name="P:SharpVk.BufferViewCreateInfo.Buffer">
            <summary>
            pname:buffer is a sname:VkBuffer on which the view will be created.
            </summary>
        </member>
        <member name="P:SharpVk.BufferViewCreateInfo.Format">
            <summary>
            pname:format is a elink:VkFormat describing the format of the data
            elements in the buffer.
            </summary>
        </member>
        <member name="P:SharpVk.BufferViewCreateInfo.Offset">
            <summary>
            pname:offset is an offset in bytes from the base address of the
            buffer. Accesses to the buffer view from shaders use addressing
            that is relative to this starting offset.
            </summary>
        </member>
        <member name="P:SharpVk.BufferViewCreateInfo.Range">
            <summary>
            pname:range is a size in bytes of the buffer view. If pname:range
            is equal to ename:VK_WHOLE_SIZE, the range from pname:offset to the
            end of the buffer is used. If ename:VK_WHOLE_SIZE is used and the
            remaining size of the buffer is not a multiple of the element size
            of pname:format, then the nearest smaller multiple is used.
            </summary>
        </member>
        <member name="T:SharpVk.ClearAttachment">
            <summary>
            <para>
            Structure specifying a clear attachment.
            </para>
            <para>
            No memory barriers are needed between fname:vkCmdClearAttachments and
            preceding or subsequent draw or attachment clear commands in the same
            subpass.
            </para>
            <para>
            The fname:vkCmdClearAttachments command is not affected by the bound
            pipeline state.
            </para>
            <para>
            Attachments can: also be cleared at the beginning of a render pass
            instance by setting pname:loadOp (or pname:stencilLoadOp) of
            slink:VkAttachmentDescription to ename:VK_ATTACHMENT_LOAD_OP_CLEAR, as
            described for flink:vkCreateRenderPass.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.ClearAttachment.#ctor(SharpVk.ImageAspectFlags,System.UInt32,SharpVk.ClearValue)">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.ClearAttachment.AspectMask">
            <summary>
            pname:aspectMask is a mask selecting the color, depth and/or
            stencil aspects of the attachment to be cleared. pname:aspectMask
            can: include ename:VK_IMAGE_ASPECT_COLOR_BIT for color attachments,
            ename:VK_IMAGE_ASPECT_DEPTH_BIT for depth/stencil attachments with
            a depth component, and ename:VK_IMAGE_ASPECT_STENCIL_BIT for
            depth/stencil attachments with a stencil component. If the
            subpass's depth/stencil attachment is ename:VK_ATTACHMENT_UNUSED,
            then the clear has no effect.
            </summary>
        </member>
        <member name="F:SharpVk.ClearAttachment.ColorAttachment">
            <summary>
            pname:colorAttachment is only meaningful if
            ename:VK_IMAGE_ASPECT_COLOR_BIT is set in pname:aspectMask, in
            which case it is an index to the pname:pColorAttachments array in
            the slink:VkSubpassDescription structure of the current subpass
            which selects the color attachment to clear. If
            pname:colorAttachment is ename:VK_ATTACHMENT_UNUSED then the clear
            has no effect.
            </summary>
        </member>
        <member name="F:SharpVk.ClearAttachment.ClearValue">
            <summary>
            pname:clearValue is the color or depth/stencil value to clear the
            attachment to, as described in &lt;&lt;clears-values,Clear
            Values&gt;&gt; below.
            </summary>
        </member>
        <member name="M:SharpVk.ClearAttachment.ToString">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.ClearColorValue">
            <summary>
            <para>
            Structure specifying a clear color value.
            </para>
            <para>
            The four array elements of the clear color map to R, G, B, and A
            components of image formats, in order.
            </para>
            <para>
            If the image has more than one sample, the same value is written to all
            samples for any pixels being cleared.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.ClearColorValue.op_Implicit(System.Single[])~SharpVk.ClearColorValue">
            <summary>
            Implicit conversion of float[] to ClearColorValue.
            </summary>
            <param name="float32">
            pname:float32 are the color clear values when the format of the
            image or attachment is one of the formats in the
            &lt;&lt;features-formats-numericformat, Interpretation of Numeric
            Format&gt;&gt; table other than signed integer (etext:SINT) or
            unsigned integer (etext:UINT). Floating point values are
            automatically converted to the format of the image, with the clear
            value being treated as linear if the image is sRGB.
            </param>
        </member>
        <member name="M:SharpVk.ClearColorValue.op_Implicit(System.Int32[])~SharpVk.ClearColorValue">
            <summary>
            Implicit conversion of int[] to ClearColorValue.
            </summary>
            <param name="int32">
            pname:int32 are the color clear values when the format of the image
            or attachment is signed integer (etext:SINT). Signed integer values
            are converted to the format of the image by casting to the smaller
            type (with negative 32-bit values mapping to negative values in the
            smaller type). If the integer clear value is not representable in
            the target type (e.g. would overflow in conversion to that type),
            the clear value is undefined.
            </param>
        </member>
        <member name="M:SharpVk.ClearColorValue.op_Implicit(System.UInt32[])~SharpVk.ClearColorValue">
            <summary>
            Implicit conversion of uint[] to ClearColorValue.
            </summary>
            <param name="uInt32">
            pname:uint32 are the color clear values when the format of the
            image or attachment is unsigned integer (etext:UINT). Unsigned
            integer values are converted to the format of the image by casting
            to the integer type with fewer bits.
            </param>
        </member>
        <member name="M:SharpVk.ClearColorValue.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.ClearColorValue.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.ClearColorValue.#ctor(System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.ClearDepthStencilValue">
            <summary>
            Structure specifying a clear depth stencil value.
            </summary>
        </member>
        <member name="M:SharpVk.ClearDepthStencilValue.#ctor(System.Single,System.UInt32)">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.ClearDepthStencilValue.Depth">
            <summary>
            pname:depth is the clear value for the depth aspect of the
            depth/stencil attachment. It is a floating-point value which is
            automatically converted to the attachment's format.
            </summary>
        </member>
        <member name="F:SharpVk.ClearDepthStencilValue.Stencil">
            <summary>
            pname:stencil is the clear value for the stencil aspect of the
            depth/stencil attachment. It is a 32-bit integer value which is
            converted to the attachment's format by taking the appropriate
            number of LSBs.
            </summary>
        </member>
        <member name="M:SharpVk.ClearDepthStencilValue.ToString">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.ClearRect">
            <summary>
            <para>
            Structure specifying a clear rectangle.
            </para>
            <para>
            The layers [eq]#[pname:baseArrayLayer, pname:baseArrayLayer {plus}
            pname:layerCount)# counting from the base layer of the attachment image
            view are cleared.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.ClearRect.#ctor(SharpVk.Rect2D,System.UInt32,System.UInt32)">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.ClearRect.Rect">
            <summary>
            pname:rect is the two-dimensional region to be cleared.
            </summary>
        </member>
        <member name="F:SharpVk.ClearRect.BaseArrayLayer">
            <summary>
            pname:baseArrayLayer is the first layer to be cleared.
            </summary>
        </member>
        <member name="F:SharpVk.ClearRect.LayerCount">
            <summary>
            pname:layerCount is the number of layers to clear.
            </summary>
        </member>
        <member name="M:SharpVk.ClearRect.ToString">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.ClearValue">
            <summary>
            <para>
            Structure specifying a clear value.
            </para>
            <para>
            This union is used where part of the API requires either color or
            depth/stencil clear values, depending on the attachment, and defines
            the initial clear values in the slink:VkRenderPassBeginInfo structure.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.ClearValue.op_Implicit(SharpVk.ClearColorValue)~SharpVk.ClearValue">
            <summary>
            Implicit conversion of ClearColorValue to ClearValue.
            </summary>
            <param name="color">
            pname:color specifies the color image clear values to use when
            clearing a color image or attachment.
            </param>
        </member>
        <member name="M:SharpVk.ClearValue.op_Implicit(SharpVk.ClearDepthStencilValue)~SharpVk.ClearValue">
            <summary>
            Implicit conversion of ClearDepthStencilValue to ClearValue.
            </summary>
            <param name="depthStencil">
            pname:depthStencil specifies the depth and stencil clear values to
            use when clearing a depth/stencil image or attachment.
            </param>
        </member>
        <member name="T:SharpVk.ColorComponentFlags">
            <summary>
            <para>
            Bitmask controlling which components are written to the framebuffer.
            </para>
            <para>
            If ename:VK_COLOR_COMPONENT_R_BIT is set, then the [eq]#R# value is
            written to color attachment for the appropriate sample, otherwise the
            value in memory is unmodified. The ename:VK_COLOR_COMPONENT_G_BIT,
            ename:VK_COLOR_COMPONENT_B_BIT, and ename:VK_COLOR_COMPONENT_A_BIT bits
            similarly control writing of the [eq]#G, B,# and [eq]#A# values. The
            pname:colorWriteMask is applied regardless of whether blending is
            enabled.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ColorComponentFlags.None">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.ColorComponentFlags.R">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.ColorComponentFlags.G">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.ColorComponentFlags.B">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.ColorComponentFlags.A">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.ColorSpace">
            <summary>
            <para>
            Supported color space of the presentation engine.
            </para>
            <para>
            The color components of Non-linear color space swap chain images have
            had the appropriate transfer function applied. Vulkan requires that all
            implementations support the sRGB OETF and EOTF transfer functions when
            using an SRGB pixel format. Other transfer functions, such as SMPTE
            170M, must not: be performed by the implementation, but can: be
            performed by the application shader.
            endif::VK_EXT_swapchain_colorspace[]
            </para>
            <para>
            If pname:pSurfaceFormats includes an entry whose value for
            pname:colorSpace is ename:VK_COLOR_SPACE_SRGB_NONLINEAR_KHR and whose
            value for pname:format is a UNORM (or SRGB) format and the
            corresponding SRGB (or UNORM) format is a color renderable format for
            ename:VK_IMAGE_TILING_OPTIMAL, then pname:pSurfaceFormats must: also
            contain an entry with the same value for pname:colorSpace and
            pname:format equal to the corresponding SRGB (or UNORM) format.
            </para>
            <para>
            [NOTE] .Note ==== If pname:pSurfaceFormats includes just one entry,
            whose value for pname:format is ename:VK_FORMAT_UNDEFINED,
            pname:surface has no preferred format. In this case, the application
            can: use any valid ename:VkFormat value. ====
            </para>
            <para>
            [NOTE] .Note ==== In the initial release of the +VK_KHR_surface+ and
            +VK_KHR_swapchain+ extensions, the token
            ename:VK_COLORSPACE_SRGB_NONLINEAR_KHR was used. Starting in the May
            13, 2016 updates to the extension branches, matching release 1.0.13 of
            the core API specification, ename:VK_COLOR_SPACE_SRGB_NONLINEAR_KHR is
            used instead for consistency with Vulkan naming rules. The older enum
            is still available for backwards compatibility. ====
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ColorSpace.SrgbNonlinear">
            <summary>
            ename:VK_COLOR_SPACE_SRGB_NONLINEAR_KHR: The presentation engine
            supports the sRGB color space. ifdef::VK_EXT_swapchain_colorspace[]
            </summary>
        </member>
        <member name="F:SharpVk.ColorSpace.DisplayP3Linear">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.ColorSpace.DisplayP3Nonlinear">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.ColorSpace.ScrgbLinear">
            <summary>
            * ename:VK_COLOR_SPACE_SCRGB_LINEAR_EXT - supports the scRGB color
            space and applies a linear OETF.
            </summary>
        </member>
        <member name="F:SharpVk.ColorSpace.ScrgbNonlinear">
            <summary>
            * ename:VK_COLOR_SPACE_SCRGB_NONLINEAR_EXT - supports the scRGB
            color space and applies the scRGB OETF.
            </summary>
        </member>
        <member name="F:SharpVk.ColorSpace.DciP3Linear">
            <summary>
            * ename:VK_COLOR_SPACE_DCI_P3_LINEAR_EXT - supports the DCI-P3
            color space and applies a linear OETF.
            </summary>
        </member>
        <member name="F:SharpVk.ColorSpace.DciP3Nonlinear">
            <summary>
            * ename:VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT - supports the DCI-P3
            color space and applies the Gamma 2.6 OETF.
            </summary>
        </member>
        <member name="F:SharpVk.ColorSpace.Bt709Linear">
            <summary>
            * ename:VK_COLOR_SPACE_BT709_LINEAR_EXT - supports the BT709 color
            space and applies a linear OETF.
            </summary>
        </member>
        <member name="F:SharpVk.ColorSpace.Bt709Nonlinear">
            <summary>
            * ename:VK_COLOR_SPACE_BT709_NONLINEAR_EXT - supports the BT709
            color space and applies the SMPTE 170M OETF.
            </summary>
        </member>
        <member name="F:SharpVk.ColorSpace.Bt2020Linear">
            <summary>
            * ename:VK_COLOR_SPACE_BT2020_LINEAR_EXT - supports the BT2020
            color space and applies a linear OETF.
            </summary>
        </member>
        <member name="F:SharpVk.ColorSpace.Bt2020Nonlinear">
            <summary>
            * ename:VK_COLOR_SPACE_BT2020_NONLINEAR_EXT - supports the BT2020
            color space and applies the SMPTE 170M OETF.
            </summary>
        </member>
        <member name="F:SharpVk.ColorSpace.AdobergbLinear">
            <summary>
            * ename:VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT - supports the AdobeRGB
            color space and applies a linear OETF.
            </summary>
        </member>
        <member name="F:SharpVk.ColorSpace.AdobergbNonlinear">
            <summary>
            * ename:VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT - supports the
            AdobeRGB color space and applies the Gamma 2.2 OETF.
            </summary>
        </member>
        <member name="T:SharpVk.CommandBuffer">
            <summary>
            <para>
            Opaque handle to a command buffer object.
            </para>
            <para>
            Command buffers are objects used to record commands which can: be
            subsequently submitted to a device queue for execution. There are two
            levels of command buffers - _primary command buffers_, which can:
            execute secondary command buffers, and which are submitted to queues,
            and _secondary command buffers_, which can: be executed by primary
            command buffers, and which are not directly submitted to queues.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.Begin(SharpVk.CommandBufferBeginInfo)">
            <summary>
            Start recording a command buffer.
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.End">
            <summary>
            Finish recording a command buffer.
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.Reset(SharpVk.CommandBufferResetFlags)">
            <summary>
            Reset a command buffer.
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.BindPipeline(SharpVk.PipelineBindPoint,SharpVk.Pipeline)">
            <summary>
            Bind a pipeline object to a command buffer.
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.SetViewport(System.UInt32,SharpVk.ArrayProxy{SharpVk.Viewport})">
            <summary>
            Set the viewport on a command buffer.
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.SetScissor(System.UInt32,SharpVk.ArrayProxy{SharpVk.Rect2D})">
            <summary>
            Set the dynamic scissor rectangles on a command buffer.
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.SetLineWidth(System.Single)">
            <summary>
            Set the dynamic line width state.
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.SetDepthBias(System.Single,System.Single,System.Single)">
            <summary>
            Set the depth bias dynamic state.
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.SetBlendConstants(System.Single)">
            <summary>
            Set the values of blend constants.
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.SetDepthBounds(System.Single,System.Single)">
            <summary>
            Set the depth bounds test values for a command buffer.
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.SetStencilCompareMask(SharpVk.StencilFaceFlags,System.UInt32)">
            <summary>
            Set the stencil compare mask dynamic state.
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.SetStencilWriteMask(SharpVk.StencilFaceFlags,System.UInt32)">
            <summary>
            Set the stencil write mask dynamic state.
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.SetStencilReference(SharpVk.StencilFaceFlags,System.UInt32)">
            <summary>
            Set the stencil reference dynamic state.
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.BindDescriptorSets(SharpVk.PipelineBindPoint,SharpVk.PipelineLayout,System.UInt32,SharpVk.ArrayProxy{SharpVk.DescriptorSet},SharpVk.ArrayProxy{System.UInt32})">
            <summary>
            Binds descriptor sets to a command buffer.
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.BindIndexBuffer(SharpVk.Buffer,SharpVk.DeviceSize,SharpVk.IndexType)">
            <summary>
            Bind an index buffer to a command buffer.
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.BindVertexBuffers(System.UInt32,SharpVk.ArrayProxy{SharpVk.Buffer},SharpVk.ArrayProxy{SharpVk.DeviceSize})">
            <summary>
            Bind vertex buffers to a command buffer.
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.Draw(System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Draw primitives.
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.DrawIndexed(System.UInt32,System.UInt32,System.UInt32,System.Int32,System.UInt32)">
            <summary>
            Issue an indexed draw into a command buffer.
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.DrawIndirect(SharpVk.Buffer,SharpVk.DeviceSize,System.UInt32,System.UInt32)">
            <summary>
            Issue an indirect draw into a command buffer.
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.DrawIndexedIndirect(SharpVk.Buffer,SharpVk.DeviceSize,System.UInt32,System.UInt32)">
            <summary>
            Perform an indexed indirect draw.
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.Dispatch(System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Dispatch compute work items.
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.DispatchIndirect(SharpVk.Buffer,SharpVk.DeviceSize)">
            <summary>
            Dispatch compute work items using indirect parameters.
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.CopyBuffer(SharpVk.Buffer,SharpVk.Buffer,SharpVk.ArrayProxy{SharpVk.BufferCopy})">
            <summary>
            Copy data between buffer regions.
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.CopyImage(SharpVk.Image,SharpVk.ImageLayout,SharpVk.Image,SharpVk.ImageLayout,SharpVk.ArrayProxy{SharpVk.ImageCopy})">
            <summary>
            Copy data between images.
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.BlitImage(SharpVk.Image,SharpVk.ImageLayout,SharpVk.Image,SharpVk.ImageLayout,SharpVk.ArrayProxy{SharpVk.ImageBlit},SharpVk.Filter)">
            <summary>
            Copy regions of an image, potentially performing format
            conversion,.
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.CopyBufferToImage(SharpVk.Buffer,SharpVk.Image,SharpVk.ImageLayout,SharpVk.ArrayProxy{SharpVk.BufferImageCopy})">
            <summary>
            Copy data from a buffer into an image.
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.CopyImageToBuffer(SharpVk.Image,SharpVk.ImageLayout,SharpVk.Buffer,SharpVk.ArrayProxy{SharpVk.BufferImageCopy})">
            <summary>
            Copy image data into a buffer.
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.UpdateBuffer(SharpVk.Buffer,SharpVk.DeviceSize,SharpVk.ArrayProxy{System.Byte})">
            <summary>
            Update a buffer's contents from host memory.
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.FillBuffer(SharpVk.Buffer,SharpVk.DeviceSize,SharpVk.DeviceSize,System.UInt32)">
            <summary>
            Fill a region of a buffer with a fixed value.
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.ClearColorImage(SharpVk.Image,SharpVk.ImageLayout,SharpVk.ClearColorValue,SharpVk.ArrayProxy{SharpVk.ImageSubresourceRange})">
            <summary>
            Clear regions of a color image.
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.ClearDepthStencilImage(SharpVk.Image,SharpVk.ImageLayout,SharpVk.ClearDepthStencilValue,SharpVk.ArrayProxy{SharpVk.ImageSubresourceRange})">
            <summary>
            Fill regions of a combined depth-stencil image.
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.ClearAttachments(SharpVk.ArrayProxy{SharpVk.ClearAttachment},SharpVk.ArrayProxy{SharpVk.ClearRect})">
            <summary>
            Clear regions within currently bound framebuffer attachments.
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.ResolveImage(SharpVk.Image,SharpVk.ImageLayout,SharpVk.Image,SharpVk.ImageLayout,SharpVk.ArrayProxy{SharpVk.ImageResolve})">
            <summary>
            Resolve regions of an image.
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.SetEvent(SharpVk.Event,SharpVk.PipelineStageFlags)">
            <summary>
            Set an event object to signaled state.
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.ResetEvent(SharpVk.Event,SharpVk.PipelineStageFlags)">
            <summary>
            Reset an event object to non-signaled state.
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.WaitEvents(SharpVk.ArrayProxy{SharpVk.Event},SharpVk.PipelineStageFlags,SharpVk.PipelineStageFlags,SharpVk.ArrayProxy{SharpVk.MemoryBarrier},SharpVk.ArrayProxy{SharpVk.BufferMemoryBarrier},SharpVk.ArrayProxy{SharpVk.ImageMemoryBarrier})">
            <summary>
            Wait for one or more events and insert a set of memory.
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.PipelineBarrier(SharpVk.PipelineStageFlags,SharpVk.PipelineStageFlags,SharpVk.DependencyFlags,SharpVk.ArrayProxy{SharpVk.MemoryBarrier},SharpVk.ArrayProxy{SharpVk.BufferMemoryBarrier},SharpVk.ArrayProxy{SharpVk.ImageMemoryBarrier})">
            <summary>
            Insert a memory dependency.
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.BeginQuery(SharpVk.QueryPool,System.UInt32,SharpVk.QueryControlFlags)">
            <summary>
            Begin a query.
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.EndQuery(SharpVk.QueryPool,System.UInt32)">
            <summary>
            Ends a query.
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.ResetQueryPool(SharpVk.QueryPool,System.UInt32,System.UInt32)">
            <summary>
            Reset queries in a query pool.
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.WriteTimestamp(SharpVk.PipelineStageFlags,SharpVk.QueryPool,System.UInt32)">
            <summary>
            Write a device timestamp into a query object.
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.CopyQueryPoolResults(SharpVk.QueryPool,System.UInt32,System.UInt32,SharpVk.Buffer,SharpVk.DeviceSize,SharpVk.DeviceSize,SharpVk.QueryResultFlags)">
            <summary>
            Copy the results of queries in a query pool to a buffer object.
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.PushConstants(SharpVk.PipelineLayout,SharpVk.ShaderStageFlags,System.UInt32,SharpVk.ArrayProxy{System.Byte})">
            <summary>
            Update the values of push constants.
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.BeginRenderPass(SharpVk.RenderPassBeginInfo,SharpVk.SubpassContents)">
            <summary>
            Begin a new render pass.
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.NextSubpass(SharpVk.SubpassContents)">
            <summary>
            Transition to the next subpass of a render pass.
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.EndRenderPass">
            <summary>
            End the current render pass.
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.ExecuteCommands(SharpVk.ArrayProxy{SharpVk.CommandBuffer})">
            <summary>
            Execute a secondary command buffer from a primary command buffer.
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.DebugMarkerBegin(SharpVk.DebugMarkerMarkerInfo)">
            <summary>
            Open a command buffer marker region.
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.DebugMarkerEnd">
            <summary>
            Close a command buffer marker region.
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.DebugMarkerInsert(SharpVk.DebugMarkerMarkerInfo)">
            <summary>
            Insert a marker label into a command buffer.
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.DrawIndirectCount(SharpVk.Buffer,SharpVk.DeviceSize,SharpVk.Buffer,SharpVk.DeviceSize,System.UInt32,System.UInt32)">
            <summary>
            Perform an indirect draw with the draw count sourced from a buffer.
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.DrawIndexedIndirectCount(SharpVk.Buffer,SharpVk.DeviceSize,SharpVk.Buffer,SharpVk.DeviceSize,System.UInt32,System.UInt32)">
            <summary>
            Perform an indexed indirect draw with the draw count sourced from a
            buffer.
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.ProcessCommands(SharpVk.CommandProcessCommandsInfo)">
            <summary>
            Performs the generation of commands on the device.
            </summary>
        </member>
        <member name="M:SharpVk.CommandBuffer.ReserveSpaceForCommands(SharpVk.CommandReserveSpaceForCommandsInfo)">
            <summary>
            Perform a reservation of command buffer space.
            </summary>
        </member>
        <member name="P:SharpVk.CommandBuffer.RawHandle">
            <summary>
            The interop handle for this CommandBuffer.
            </summary>
        </member>
        <member name="T:SharpVk.CommandBufferAllocateInfo">
            <summary>
            Structure specifying the allocation parameters for command buffer
            object.
            </summary>
        </member>
        <member name="P:SharpVk.CommandBufferAllocateInfo.CommandPool">
            <summary>
            pname:commandPool is the command pool from which the command
            buffers are allocated.
            </summary>
        </member>
        <member name="P:SharpVk.CommandBufferAllocateInfo.Level">
            <summary>
            pname:level determines whether the command buffers are primary or
            secondary command buffers. Possible values include: + --
            </summary>
        </member>
        <member name="P:SharpVk.CommandBufferAllocateInfo.CommandBufferCount">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.CommandBufferBeginInfo">
            <summary>
            Structure specifying a command buffer begin operation.
            </summary>
        </member>
        <member name="P:SharpVk.CommandBufferBeginInfo.Flags">
            <summary>
            pname:flags is a bitmask indicating usage behavior for the command
            buffer. Bits which can: be set include: + --
            </summary>
        </member>
        <member name="P:SharpVk.CommandBufferBeginInfo.InheritanceInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.CommandBufferInheritanceInfo">
            <summary>
            Structure specifying command buffer inheritance info.
            </summary>
        </member>
        <member name="P:SharpVk.CommandBufferInheritanceInfo.RenderPass">
            <summary>
            pname:renderPass is a sname:VkRenderPass object defining which
            render passes the sname:VkCommandBuffer will be
            &lt;&lt;renderpass-compatibility, compatible&gt;&gt; with and can:
            be executed within. If the sname:VkCommandBuffer will not be
            executed within a render pass instance, pname:renderPass is
            ignored.
            </summary>
        </member>
        <member name="P:SharpVk.CommandBufferInheritanceInfo.Subpass">
            <summary>
            pname:subpass is the index of the subpass within the render pass
            instance that the sname:VkCommandBuffer will be executed within. If
            the sname:VkCommandBuffer will not be executed within a render pass
            instance, pname:subpass is ignored.
            </summary>
        </member>
        <member name="P:SharpVk.CommandBufferInheritanceInfo.Framebuffer">
            <summary>
            pname:framebuffer optionally refers to the sname:VkFramebuffer
            object that the sname:VkCommandBuffer will be rendering to if it is
            executed within a render pass instance. It can: be
            dlink:VK_NULL_HANDLE if the framebuffer is not known, or if the
            sname:VkCommandBuffer will not be executed within a render pass
            instance. + [NOTE] .Note ==== Specifying the exact framebuffer that
            the secondary command buffer will be executed with may: result in
            better performance at command buffer execution time. ====
            </summary>
        </member>
        <member name="P:SharpVk.CommandBufferInheritanceInfo.OcclusionQueryEnable">
            <summary>
            pname:occlusionQueryEnable indicates whether the command buffer
            can: be executed while an occlusion query is active in the primary
            command buffer. If this is ename:VK_TRUE, then this command buffer
            can: be executed whether the primary command buffer has an
            occlusion query active or not. If this is ename:VK_FALSE, then the
            primary command buffer must: not have an occlusion query active.
            </summary>
        </member>
        <member name="P:SharpVk.CommandBufferInheritanceInfo.QueryFlags">
            <summary>
            pname:queryFlags indicates the query flags that can: be used by an
            active occlusion query in the primary command buffer when this
            secondary command buffer is executed. If this value includes the
            ename:VK_QUERY_CONTROL_PRECISE_BIT bit, then the active query can:
            return boolean results or actual sample counts. If this bit is not
            set, then the active query must: not use the
            ename:VK_QUERY_CONTROL_PRECISE_BIT bit.
            </summary>
        </member>
        <member name="P:SharpVk.CommandBufferInheritanceInfo.PipelineStatistics">
            <summary>
            pname:pipelineStatistics indicates the set of pipeline statistics
            that can: be counted by an active query in the primary command
            buffer when this secondary command buffer is executed. If this
            value includes a given bit, then this command buffer can: be
            executed whether the primary command buffer has a pipeline
            statistics query active that includes this bit or not. If this
            value excludes a given bit, then the active pipeline statistics
            query must: not be from a query pool that counts that statistic.
            </summary>
        </member>
        <member name="T:SharpVk.CommandBufferLevel">
            <summary>
            Structure specifying a command buffer level.
            </summary>
        </member>
        <member name="F:SharpVk.CommandBufferLevel.Primary">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.CommandBufferLevel.Secondary">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.CommandBufferResetFlags">
            <summary>
            Bitmask controlling behavior of a command buffer reset.
            </summary>
        </member>
        <member name="F:SharpVk.CommandBufferResetFlags.None">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.CommandBufferResetFlags.ReleaseResources">
            <summary>
            Release resources owned by the buffer
            </summary>
        </member>
        <member name="T:SharpVk.CommandBufferUsageFlags">
            <summary>
            Bitmask specifying usage behavior for command buffer.
            </summary>
        </member>
        <member name="F:SharpVk.CommandBufferUsageFlags.None">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.CommandBufferUsageFlags.OneTimeSubmit">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.CommandBufferUsageFlags.RenderPassContinue">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.CommandBufferUsageFlags.SimultaneousUse">
            <summary>
            Command buffer may be submitted/executed more than once
            simultaneously
            </summary>
        </member>
        <member name="T:SharpVk.CommandCache">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.CommandCache.GetCommandDelegate``1(System.String,System.String)">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <param name="name"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="T:SharpVk.IProcLookup">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.IProcLookup.GetProcedureAddress(System.String)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="T:SharpVk.CommandPool">
            <summary>
            <para>
            Opaque handle to a command pool object.
            </para>
            <para>
            Command pools are opaque objects that command buffer memory is
            allocated from, and which allow the implementation to amortize the cost
            of resource creation across multiple command buffers. Command pools are
            externally synchronized, meaning that a command pool must: not be used
            concurrently in multiple threads. That includes use via recording
            commands on any command buffers allocated from the pool, as well as
            operations that allocate, free, and reset command buffers or the pool
            itself.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.CommandPool.Destroy">
            <summary>
            Destroy a command pool object.
            </summary>
        </member>
        <member name="M:SharpVk.CommandPool.Reset(SharpVk.CommandPoolResetFlags)">
            <summary>
            Reset a command pool.
            </summary>
        </member>
        <member name="M:SharpVk.CommandPool.FreeCommandBuffers(SharpVk.ArrayProxy{SharpVk.CommandBuffer})">
            <summary>
            Free command buffers.
            </summary>
        </member>
        <member name="M:SharpVk.CommandPool.Trim(SharpVk.CommandPoolTrimFlags)">
            <summary>
            Trim a command pool.
            </summary>
        </member>
        <member name="P:SharpVk.CommandPool.RawHandle">
            <summary>
            The interop handle for this CommandPool.
            </summary>
        </member>
        <member name="M:SharpVk.CommandPool.Dispose">
            <summary>
            Releases the unmanaged resources associated with this instance and
            destroys the underlying Vulkan handle.
            </summary>
        </member>
        <member name="T:SharpVk.CommandPoolCreateFlags">
            <summary>
            Bitmask specifying usage behavior for a command pool.
            </summary>
        </member>
        <member name="F:SharpVk.CommandPoolCreateFlags.None">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.CommandPoolCreateFlags.Transient">
            <summary>
            Command buffers have a short lifetime
            </summary>
        </member>
        <member name="F:SharpVk.CommandPoolCreateFlags.ResetCommandBuffer">
            <summary>
            Command buffers may release their memory individually
            </summary>
        </member>
        <member name="T:SharpVk.CommandPoolCreateInfo">
            <summary>
            Structure specifying parameters of a newly created command pool.
            </summary>
        </member>
        <member name="P:SharpVk.CommandPoolCreateInfo.Flags">
            <summary>
            pname:flags is a bitmask indicating usage behavior for the pool and
            command buffers allocated from it. Bits which can: be set include:
            + --
            </summary>
        </member>
        <member name="P:SharpVk.CommandPoolCreateInfo.QueueFamilyIndex">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.CommandPoolResetFlags">
            <summary>
            <para>
            Bitmask controlling behavior of a command pool reset.
            </para>
            <para>
            Resetting a command pool recycles all of the resources from all of the
            command buffers allocated from the command pool back to the command
            pool. All command buffers that have been allocated from the command
            pool are put in the initial state.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.CommandPoolResetFlags.None">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.CommandPoolResetFlags.ReleaseResources">
            <summary>
            Release resources owned by the pool
            </summary>
        </member>
        <member name="T:SharpVk.CommandPoolTrimFlags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.CommandPoolTrimFlags.None">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.CommandProcessCommandsInfo">
            <summary>
            Structure specifying parameters for the generation of commands.
            </summary>
        </member>
        <member name="P:SharpVk.CommandProcessCommandsInfo.ObjectTable">
            <summary>
            pname:objectTable is the sname:VkObjectTableNVX to be used for the
            generation process. Only registered objects at the time
            flink:vkCmdReserveSpaceForCommandsNVX is called, will be taken into
            account for the reservation.
            </summary>
        </member>
        <member name="P:SharpVk.CommandProcessCommandsInfo.IndirectCommandsLayout">
            <summary>
            pname:indirectCommandsLayout is the
            sname:VkIndirectCommandsLayoutNVX that provides the command
            sequence to generate.
            </summary>
        </member>
        <member name="P:SharpVk.CommandProcessCommandsInfo.IndirectCommandsTokens">
            <summary>
            pname:pIndirectCommandsTokens provides an array of
            slink:VkIndirectCommandsTokenNVX that reference the input data for
            each token command.
            </summary>
        </member>
        <member name="P:SharpVk.CommandProcessCommandsInfo.MaxSequencesCount">
            <summary>
            pname:maxSequencesCount is the maximum number of sequences for
            which command buffer space will be reserved. If
            pname:sequencesCountBuffer is `NULL`, this is also the actual
            number of sequences generated.
            </summary>
        </member>
        <member name="P:SharpVk.CommandProcessCommandsInfo.TargetCommandBuffer">
            <summary>
            pname:targetCommandBuffer can: be the secondary
            sname:VkCommandBuffer in which the commands should be recorded. If
            `NULL` an implicit reservation as well as execution takes place on
            the processing sname:VkCommandBuffer.
            </summary>
        </member>
        <member name="P:SharpVk.CommandProcessCommandsInfo.SequencesCountBuffer">
            <summary>
            pname:sequencesCountBuffer can: be sname:VkBuffer from which the
            actual amount of sequences is sourced from as ftext:uint32_t value.
            </summary>
        </member>
        <member name="P:SharpVk.CommandProcessCommandsInfo.SequencesCountOffset">
            <summary>
            pname:sequencesCountOffset is the byte offset into
            pname:sequencesCountBuffer where the count value is stored.
            </summary>
        </member>
        <member name="P:SharpVk.CommandProcessCommandsInfo.SequencesIndexBuffer">
            <summary>
            pname:sequencesIndexBuffer must: be set if
            pname:indirectCommandsLayout's ename:VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT
            is set and provides the used sequence indices as ftext:uint32_t
            array. Otherwise it must: be `NULL`.
            </summary>
        </member>
        <member name="P:SharpVk.CommandProcessCommandsInfo.SequencesIndexOffset">
            <summary>
            pname:sequencesIndexOffset is the byte offset into
            pname:sequencesIndexBuffer where the index values start.
            </summary>
        </member>
        <member name="T:SharpVk.CommandReserveSpaceForCommandsInfo">
            <summary>
            Structure specifying parameters for the reservation of command buffer
            space.
            </summary>
        </member>
        <member name="P:SharpVk.CommandReserveSpaceForCommandsInfo.ObjectTable">
            <summary>
            pname:objectTable is the sname:VkObjectTableNVX to be used for the
            generation process. Only registered objects at the time
            flink:vkCmdReserveSpaceForCommandsNVX is called, will be taken into
            account for the reservation.
            </summary>
        </member>
        <member name="P:SharpVk.CommandReserveSpaceForCommandsInfo.IndirectCommandsLayout">
            <summary>
            pname:indirectCommandsLayout is the
            sname:VkIndirectCommandsLayoutNVX that must: also be used at
            generation time.
            </summary>
        </member>
        <member name="P:SharpVk.CommandReserveSpaceForCommandsInfo.MaxSequencesCount">
            <summary>
            pname:maxSequencesCount is the maximum number of sequences for
            which command buffer space will be reserved.
            </summary>
        </member>
        <member name="T:SharpVk.CompareOp">
            <summary>
            Stencil comparison function.
            </summary>
        </member>
        <member name="F:SharpVk.CompareOp.Never">
            <summary>
            ename:VK_COMPARE_OP_NEVER: the test never passes.
            </summary>
        </member>
        <member name="F:SharpVk.CompareOp.Less">
            <summary>
            ename:VK_COMPARE_OP_LESS: the test passes when [eq]#R &lt; S#.
            </summary>
        </member>
        <member name="F:SharpVk.CompareOp.Equal">
            <summary>
            ename:VK_COMPARE_OP_EQUAL: the test passes when [eq]#R = S#.
            </summary>
        </member>
        <member name="F:SharpVk.CompareOp.LessOrEqual">
            <summary>
            ename:VK_COMPARE_OP_LESS_OR_EQUAL: the test passes when [eq]#R
            {leq} S#.
            </summary>
        </member>
        <member name="F:SharpVk.CompareOp.Greater">
            <summary>
            ename:VK_COMPARE_OP_GREATER: the test passes when [eq]#R &gt; S#.
            </summary>
        </member>
        <member name="F:SharpVk.CompareOp.NotEqual">
            <summary>
            ename:VK_COMPARE_OP_NOT_EQUAL: the test passes when [eq]#R {neq}
            S#.
            </summary>
        </member>
        <member name="F:SharpVk.CompareOp.GreaterOrEqual">
            <summary>
            ename:VK_COMPARE_OP_GREATER_OR_EQUAL: the test passes when [eq]#R
            {geq} S#.
            </summary>
        </member>
        <member name="F:SharpVk.CompareOp.Always">
            <summary>
            ename:VK_COMPARE_OP_ALWAYS: the test always passes.
            </summary>
        </member>
        <member name="T:SharpVk.ComponentMapping">
            <summary>
            <para>
            Structure specifying a color component mapping.
            </para>
            <para>
            Each of pname:r, pname:g, pname:b, and pname:a is one of the values:
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.ComponentMapping.#ctor(SharpVk.ComponentSwizzle,SharpVk.ComponentSwizzle,SharpVk.ComponentSwizzle,SharpVk.ComponentSwizzle)">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.ComponentMapping.R">
            <summary>
            pname:r determines the component value placed in the R component of
            the output vector.
            </summary>
        </member>
        <member name="F:SharpVk.ComponentMapping.G">
            <summary>
            pname:g determines the component value placed in the G component of
            the output vector.
            </summary>
        </member>
        <member name="F:SharpVk.ComponentMapping.B">
            <summary>
            pname:b determines the component value placed in the B component of
            the output vector.
            </summary>
        </member>
        <member name="F:SharpVk.ComponentMapping.A">
            <summary>
            pname:a determines the component value placed in the A component of
            the output vector.
            </summary>
        </member>
        <member name="M:SharpVk.ComponentMapping.ToString">
            <summary>
            
            </summary>
        </member>
        <member name="P:SharpVk.ComponentMapping.Identity">
            <summary>
            Returns a default ComponentMapping of Identity for all components.
            </summary>
        </member>
        <member name="T:SharpVk.ComponentSwizzle">
            <summary>
            <para>
            Specify how a component is swizzled.
            </para>
            <para>
            Setting the identity swizzle on a component is equivalent to setting
            the identity mapping on that component. That is:
            </para>
            <para>
            .Component Mappings Equivalent To ename:VK_COMPONENT_SWIZZLE_IDENTITY
            [options="header"] |==== | Component | Identity Mapping |
            pname:components.r | ename:VK_COMPONENT_SWIZZLE_R | pname:components.g
            | ename:VK_COMPONENT_SWIZZLE_G | pname:components.b |
            ename:VK_COMPONENT_SWIZZLE_B | pname:components.a |
            ename:VK_COMPONENT_SWIZZLE_A |====
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ComponentSwizzle.Identity">
            <summary>
            ename:VK_COMPONENT_SWIZZLE_IDENTITY: the component is set to the
            identity swizzle.
            </summary>
        </member>
        <member name="F:SharpVk.ComponentSwizzle.Zero">
            <summary>
            ename:VK_COMPONENT_SWIZZLE_ZERO: the component is set to zero.
            </summary>
        </member>
        <member name="F:SharpVk.ComponentSwizzle.One">
            <summary>
            ename:VK_COMPONENT_SWIZZLE_ONE: the component is set to either 1 or
            1.0 depending on whether the type of the image view format is
            integer or floating-point respectively, as determined by the
            &lt;&lt;features-formats-definition,Format Definition&gt;&gt;
            section for each elink:VkFormat.
            </summary>
        </member>
        <member name="F:SharpVk.ComponentSwizzle.R">
            <summary>
            ename:VK_COMPONENT_SWIZZLE_R: the component is set to the value of
            the R component of the image.
            </summary>
        </member>
        <member name="F:SharpVk.ComponentSwizzle.G">
            <summary>
            ename:VK_COMPONENT_SWIZZLE_G: the component is set to the value of
            the G component of the image.
            </summary>
        </member>
        <member name="F:SharpVk.ComponentSwizzle.B">
            <summary>
            ename:VK_COMPONENT_SWIZZLE_B: the component is set to the value of
            the B component of the image.
            </summary>
        </member>
        <member name="F:SharpVk.ComponentSwizzle.A">
            <summary>
            ename:VK_COMPONENT_SWIZZLE_A: the component is set to the value of
            the A component of the image.
            </summary>
        </member>
        <member name="T:SharpVk.CompositeAlphaFlags">
            <summary>
            Alpha compositing modes supported on a device.
            </summary>
        </member>
        <member name="F:SharpVk.CompositeAlphaFlags.None">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.CompositeAlphaFlags.Opaque">
            <summary>
            ename:VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR: The alpha channel, if it
            exists, of the images is ignored in the compositing process.
            Instead, the image is treated as if it has a constant alpha of 1.0.
            </summary>
        </member>
        <member name="F:SharpVk.CompositeAlphaFlags.PreMultiplied">
            <summary>
            ename:VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR: The alpha channel,
            if it exists, of the images is respected in the compositing
            process. The non-alpha channels of the image are expected to
            already be multiplied by the alpha channel by the application.
            </summary>
        </member>
        <member name="F:SharpVk.CompositeAlphaFlags.PostMultiplied">
            <summary>
            ename:VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR: The alpha
            channel, if it exists, of the images is respected in the
            compositing process. The non-alpha channels of the image are not
            expected to already be multiplied by the alpha channel by the
            application; instead, the compositor will multiply the non-alpha
            channels of the image by the alpha channel during compositing.
            </summary>
        </member>
        <member name="F:SharpVk.CompositeAlphaFlags.Inherit">
            <summary>
            ename:VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR: The way in which the
            presentation engine treats the alpha channel in the images is
            unknown to the Vulkan API. Instead, the application is responsible
            for setting the composite alpha blending mode using native window
            system commands. If the application does not set the blending mode
            using native window system commands, then a platform-specific
            default will be used.
            </summary>
        </member>
        <member name="T:SharpVk.ComputePipelineCreateInfo">
            <summary>
            <para>
            Structure specifying parameters of a newly created compute pipeline.
            </para>
            <para>
            The parameters pname:basePipelineHandle and pname:basePipelineIndex are
            described in more detail in
            &lt;&lt;pipelines-pipeline-derivatives,Pipeline Derivatives&gt;&gt;.
            </para>
            <para>
            pname:stage points to a structure of type
            sname:VkPipelineShaderStageCreateInfo.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.ComputePipelineCreateInfo.Flags">
            <summary>
            pname:flags provides options for pipeline creation, and is of type
            elink:VkPipelineCreateFlagBits.
            </summary>
        </member>
        <member name="P:SharpVk.ComputePipelineCreateInfo.Stage">
            <summary>
            pname:stage is a slink:VkPipelineShaderStageCreateInfo describing
            the compute shader.
            </summary>
        </member>
        <member name="P:SharpVk.ComputePipelineCreateInfo.Layout">
            <summary>
            pname:layout is the description of binding locations used by both
            the pipeline and descriptor sets used with the pipeline.
            </summary>
        </member>
        <member name="P:SharpVk.ComputePipelineCreateInfo.BasePipelineHandle">
            <summary>
            pname:basePipelineHandle is a pipeline to derive from
            </summary>
        </member>
        <member name="P:SharpVk.ComputePipelineCreateInfo.BasePipelineIndex">
            <summary>
            pname:basePipelineIndex is an index into the pname:pCreateInfos
            parameter to use as a pipeline to derive from
            </summary>
        </member>
        <member name="T:SharpVk.KhrSurface">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.KhrSurface.SpecVersion">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.KhrSurface.ExtensionName">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.KhrSwapchain">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.KhrSwapchain.SpecVersion">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.KhrSwapchain.ExtensionName">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.KhrDisplay">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.KhrDisplay.SpecVersion">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.KhrDisplay.ExtensionName">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.KhrDisplaySwapchain">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.KhrDisplaySwapchain.SpecVersion">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.KhrDisplaySwapchain.ExtensionName">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.KhrXlibSurface">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.KhrXlibSurface.SpecVersion">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.KhrXlibSurface.ExtensionName">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.KhrXcbSurface">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.KhrXcbSurface.SpecVersion">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.KhrXcbSurface.ExtensionName">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.KhrWaylandSurface">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.KhrWaylandSurface.SpecVersion">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.KhrWaylandSurface.ExtensionName">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.KhrMirSurface">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.KhrMirSurface.SpecVersion">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.KhrMirSurface.ExtensionName">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.KhrAndroidSurface">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.KhrAndroidSurface.SpecVersion">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.KhrAndroidSurface.ExtensionName">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.KhrWin32Surface">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.KhrWin32Surface.SpecVersion">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.KhrWin32Surface.ExtensionName">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.ExtDebugReport">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.ExtDebugReport.SpecVersion">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.ExtDebugReport.ExtensionName">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.NvGlslShader">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.NvGlslShader.SpecVersion">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.NvGlslShader.ExtensionName">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.KhrSamplerMirrorClampToEdge">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.KhrSamplerMirrorClampToEdge.SpecVersion">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.KhrSamplerMirrorClampToEdge.ExtensionName">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.ImgFilterCubic">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.ImgFilterCubic.SpecVersion">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.ImgFilterCubic.ExtensionName">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.AmdRasterizationOrder">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.AmdRasterizationOrder.SpecVersion">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.AmdRasterizationOrder.ExtensionName">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.AmdShaderTrinaryMinmax">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.AmdShaderTrinaryMinmax.SpecVersion">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.AmdShaderTrinaryMinmax.ExtensionName">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.AmdShaderExplicitVertexParameter">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.AmdShaderExplicitVertexParameter.SpecVersion">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.AmdShaderExplicitVertexParameter.ExtensionName">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.ExtDebugMarker">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.ExtDebugMarker.SpecVersion">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.ExtDebugMarker.ExtensionName">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.AmdGcnShader">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.AmdGcnShader.SpecVersion">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.AmdGcnShader.ExtensionName">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.NvDedicatedAllocation">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.NvDedicatedAllocation.SpecVersion">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.NvDedicatedAllocation.ExtensionName">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.AmdDrawIndirectCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.AmdDrawIndirectCount.SpecVersion">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.AmdDrawIndirectCount.ExtensionName">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.AmdNegativeViewportHeight">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.AmdNegativeViewportHeight.SpecVersion">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.AmdNegativeViewportHeight.ExtensionName">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.AmdGpuShaderHalfFloat">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.AmdGpuShaderHalfFloat.SpecVersion">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.AmdGpuShaderHalfFloat.ExtensionName">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.AmdShaderBallot">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.AmdShaderBallot.SpecVersion">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.AmdShaderBallot.ExtensionName">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.ImgFormatPvrtc">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.ImgFormatPvrtc.SpecVersion">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.ImgFormatPvrtc.ExtensionName">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.NvExternalMemoryCapabilities">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.NvExternalMemoryCapabilities.SpecVersion">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.NvExternalMemoryCapabilities.ExtensionName">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.NvExternalMemory">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.NvExternalMemory.SpecVersion">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.NvExternalMemory.ExtensionName">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.NvExternalMemoryWin32">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.NvExternalMemoryWin32.SpecVersion">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.NvExternalMemoryWin32.ExtensionName">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.NvWin32KeyedMutex">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.NvWin32KeyedMutex.SpecVersion">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.NvWin32KeyedMutex.ExtensionName">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.KhrGetPhysicalDeviceProperties2">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.KhrGetPhysicalDeviceProperties2.Properties2SpecVersion">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.KhrGetPhysicalDeviceProperties2.Properties2ExtensionName">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.ExtValidationFlags">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.ExtValidationFlags.SpecVersion">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.ExtValidationFlags.ExtensionName">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.NnViSurface">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.NnViSurface.SpecVersion">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.NnViSurface.ExtensionName">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.KhrShaderDrawParameters">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.KhrShaderDrawParameters.SpecVersion">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.KhrShaderDrawParameters.ExtensionName">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.ExtShaderSubgroupBallot">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.ExtShaderSubgroupBallot.SpecVersion">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.ExtShaderSubgroupBallot.ExtensionName">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.ExtShaderSubgroupVote">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.ExtShaderSubgroupVote.SpecVersion">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.ExtShaderSubgroupVote.ExtensionName">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.KhrMaintenance1">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.KhrMaintenance1.SpecVersion">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.KhrMaintenance1.ExtensionName">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.NvxDeviceGeneratedCommands">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.NvxDeviceGeneratedCommands.SpecVersion">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.NvxDeviceGeneratedCommands.ExtensionName">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.ExtDirectModeDisplay">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.ExtDirectModeDisplay.SpecVersion">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.ExtDirectModeDisplay.ExtensionName">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.ExtAcquireXlibDisplay">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.ExtAcquireXlibDisplay.SpecVersion">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.ExtAcquireXlibDisplay.ExtensionName">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.ExtDisplaySurfaceCounter">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.ExtDisplaySurfaceCounter.SpecVersion">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.ExtDisplaySurfaceCounter.ExtensionName">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.ExtDisplayControl">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.ExtDisplayControl.SpecVersion">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.ExtDisplayControl.ExtensionName">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.ExtSwapchainColorspace">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.ExtSwapchainColorspace.ColorSpaceSpecVersion">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.ExtSwapchainColorspace.ColorSpaceExtensionName">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Constants">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Constants.LodClampNone">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Constants.RemainingMipLevels">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Constants.RemainingArrayLayers">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Constants.WholeSize">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Constants.AttachmentUnused">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Constants.True">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Constants.False">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Constants.QueueFamilyIgnored">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Constants.SubpassExternal">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Constants.MaxExtensionNameSize">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Constants.MaxDescriptionSize">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Constants.MaxMemoryTypes">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Constants.MaxMemoryHeaps">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Constants.MaxPhysicalDeviceNameSize">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Constants.UuidSize">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Constants.ApiVersion10">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Constants.SharpVkVersion">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.CopyDescriptorSet">
            <summary>
            Structure specifying a copy descriptor set operation.
            </summary>
        </member>
        <member name="P:SharpVk.CopyDescriptorSet.SourceSet">
            <summary>
            pname:srcSet, pname:srcBinding, and pname:srcArrayElement are the
            source set, binding, and array element, respectively.
            </summary>
        </member>
        <member name="P:SharpVk.CopyDescriptorSet.SourceBinding">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.CopyDescriptorSet.SourceArrayElement">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.CopyDescriptorSet.DestinationSet">
            <summary>
            pname:dstSet, pname:dstBinding, and pname:dstArrayElement are the
            destination set, binding, and array element, respectively.
            </summary>
        </member>
        <member name="P:SharpVk.CopyDescriptorSet.DestinationBinding">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.CopyDescriptorSet.DestinationArrayElement">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.CopyDescriptorSet.DescriptorCount">
            <summary>
            pname:descriptorCount is the number of descriptors to copy from the
            source to destination. If pname:descriptorCount is greater than the
            number of remaining array elements in the source or destination
            binding, those affect consecutive bindings in a manner similar to
            slink:VkWriteDescriptorSet above.
            </summary>
        </member>
        <member name="T:SharpVk.CullModeFlags">
            <summary>
            <para>
            Bitmask controlling triangle culling.
            </para>
            <para>
            If the pname:cullMode is set to ename:VK_CULL_MODE_NONE no triangles
            are discarded, if it is set to ename:VK_CULL_MODE_FRONT_BIT
            front-facing triangles are discarded, if it is set to
            ename:VK_CULL_MODE_BACK_BIT then back-facing triangles are discarded
            and if it is set to ename:VK_CULL_MODE_FRONT_AND_BACK then all
            triangles are discarded. Following culling, fragments are produced for
            any triangles which have not been discarded.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.CullModeFlags.None">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.CullModeFlags.Front">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.CullModeFlags.Back">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.CullModeFlags.FrontAndBack">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.DebugMarkerMarkerInfo">
            <summary>
            Specify parameters of a command buffer marker region.
            </summary>
        </member>
        <member name="P:SharpVk.DebugMarkerMarkerInfo.MarkerName">
            <summary>
            pname:pMarkerName is a pointer to a null-terminated UTF-8 string
            that contains the name of the marker.
            </summary>
        </member>
        <member name="P:SharpVk.DebugMarkerMarkerInfo.Color">
            <summary>
            pname:color is an optional RGBA color value that can be associated
            with the marker. A particular implementation may: choose to ignore
            this color value. The values contain RGBA values in order, in the
            range 0.0 to 1.0. If all elements in pname:color are set to 0.0
            then it is ignored.
            </summary>
        </member>
        <member name="T:SharpVk.DebugMarkerObjectNameInfo">
            <summary>
            <para>
            Specify parameters of a name to give to an object.
            </para>
            <para>
            Applications may: change the name associated with an object simply by
            calling fname:vkDebugMarkerSetObjectNameEXT again with a new string. To
            remove a previously set name, pname:pName should: be set to an empty
            string.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.DebugMarkerObjectNameInfo.ObjectType">
            <summary>
            pname:objectType is a elink:VkDebugReportObjectTypeEXT specifying
            the type of the object to be named.
            </summary>
        </member>
        <member name="P:SharpVk.DebugMarkerObjectNameInfo.Object">
            <summary>
            pname:object is the object to be named.
            </summary>
        </member>
        <member name="P:SharpVk.DebugMarkerObjectNameInfo.ObjectName">
            <summary>
            pname:pObjectName is a null-terminated UTF-8 string specifying the
            name to apply to pname:object.
            </summary>
        </member>
        <member name="T:SharpVk.DebugMarkerObjectTagInfo">
            <summary>
            <para>
            Specify parameters of a tag to attach to an object.
            </para>
            <para>
            The pname:tagName parameter gives a name or identifier to the type of
            data being tagged. This can be used by debugging layers to easily
            filter for only data that can be used by that implementation.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.DebugMarkerObjectTagInfo.ObjectType">
            <summary>
            pname:objectType is a elink:VkDebugReportObjectTypeEXT specifying
            the type of the object to be named.
            </summary>
        </member>
        <member name="P:SharpVk.DebugMarkerObjectTagInfo.Object">
            <summary>
            pname:object is the object to be tagged.
            </summary>
        </member>
        <member name="P:SharpVk.DebugMarkerObjectTagInfo.TagName">
            <summary>
            pname:tagName is a numerical identifier of the tag.
            </summary>
        </member>
        <member name="P:SharpVk.DebugMarkerObjectTagInfo.Tag">
            <summary>
            pname:pTag is an array of pname:tagSize bytes containing the data
            to be associated with the object.
            </summary>
        </member>
        <member name="T:SharpVk.DebugReportCallback">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.DebugReportCallback.Destroy">
            <summary>
            Destroy a debug report callback object.
            </summary>
        </member>
        <member name="P:SharpVk.DebugReportCallback.RawHandle">
            <summary>
            The interop handle for this DebugReportCallback.
            </summary>
        </member>
        <member name="M:SharpVk.DebugReportCallback.Dispose">
            <summary>
            Releases the unmanaged resources associated with this instance and
            destroys the underlying Vulkan handle.
            </summary>
        </member>
        <member name="T:SharpVk.DebugReportCallbackCreateInfo">
            <summary>
            Structure specifying parameters of a newly created debug report
            callback.
            </summary>
        </member>
        <member name="P:SharpVk.DebugReportCallbackCreateInfo.Flags">
            <summary>
            pname:flags indicate which event(s) will cause this callback to be
            called. Flags are interpreted as bitmasks and multiple may be set.
            Bits which can: be set include: + --
            </summary>
        </member>
        <member name="P:SharpVk.DebugReportCallbackCreateInfo.PfnCallback">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.DebugReportCallbackCreateInfo.UserData">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.DebugReportError">
            <summary>
            <para>
            Unknown VK_EXT_debug_report enumeration type.
            </para>
            <para>
            [NOTE] .Note ==== The +VK_EXT_debug_report+ extension defines the
            elink:VkDebugReportErrorEXT enumerant type, but does not currently
            explain what the enumeration is used for. It is included here for
            completeness. ====
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DebugReportError.None">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.DebugReportError.CallbackRef">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.DebugReportFlags">
            <summary>
            <para>
            Bitmask specifying events which cause a debug report callback.
            </para>
            <para>
            For each sname:VkDebugReportCallbackEXT that is created the flags
            determine when that function is called. A callback will be made for
            issues that match any bit set in its flags. The callback will come
            directly from the component that detected the event, unless some other
            layer intercepts the calls for its own purposes (filter them in
            different way, log to system error log, etc.) An application may
            receive multiple callbacks if multiple sname:VkDebugReportCallbackEXT
            objects were created. A callback will always be executed in the same
            thread as the originating Vulkan call. A callback may be called from
            multiple threads simultaneously (if the application is making Vulkan
            calls from multiple threads).
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DebugReportFlags.None">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.DebugReportFlags.Information">
            <summary>
            ename:VK_DEBUG_REPORT_INFORMATION_BIT_EXT indicates an
            informational message such as resource details that may be handy
            when debugging an application.
            </summary>
        </member>
        <member name="F:SharpVk.DebugReportFlags.Warning">
            <summary>
            ename:VK_DEBUG_REPORT_WARNING_BIT_EXT indicates use of Vulkan that
            may expose an app bug. Such cases may not be immediately harmful,
            such as a fragment shader outputting to a location with no
            attachment. Other cases may point to behavior that is almost
            certainly bad when unintended such as using an image whose memory
            hasn't been filled. In general if you see a warning but you know
            that the behavior is intended/desired, then simply ignore the
            warning.
            </summary>
        </member>
        <member name="F:SharpVk.DebugReportFlags.PerformanceWarning">
            <summary>
            ename:VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT indicates a
            potentially non-optimal use of Vulkan. E.g. using
            flink:vkCmdClearColorImage when a RenderPass load_op would have
            worked.
            </summary>
        </member>
        <member name="F:SharpVk.DebugReportFlags.Error">
            <summary>
            ename:VK_DEBUG_REPORT_ERROR_BIT_EXT indicates an error that may
            cause undefined results, including an application crash.
            </summary>
        </member>
        <member name="F:SharpVk.DebugReportFlags.Debug">
            <summary>
            ename:VK_DEBUG_REPORT_DEBUG_BIT_EXT indicates diagnostic
            information from the loader and layers. -- +
            </summary>
        </member>
        <member name="T:SharpVk.DebugReportObjectType">
            <summary>
            <para>
            Specify the type of an object handle.
            </para>
            <para>
            [NOTE] .Note ==== The primary expected use of
            ename:VK_ERROR_VALIDATION_FAILED_EXT is for validation layer testing.
            It is not expected that an application would see this error code during
            normal use of the validation layers. ====
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DebugReportObjectType.Unknown">
            <summary>
            ename:VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT is an unknown object.
            </summary>
        </member>
        <member name="F:SharpVk.DebugReportObjectType.Instance">
            <summary>
            ename:VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT is a
            sname:VkInstance.
            </summary>
        </member>
        <member name="F:SharpVk.DebugReportObjectType.PhysicalDevice">
            <summary>
            ename:VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT is a
            sname:VkPhysicalDevice.
            </summary>
        </member>
        <member name="F:SharpVk.DebugReportObjectType.Device">
            <summary>
            ename:VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT is a sname:VkDevice.
            </summary>
        </member>
        <member name="F:SharpVk.DebugReportObjectType.Queue">
            <summary>
            ename:VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT is a sname:VkQueue.
            </summary>
        </member>
        <member name="F:SharpVk.DebugReportObjectType.Semaphore">
            <summary>
            ename:VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT is a
            sname:VkSemaphore.
            </summary>
        </member>
        <member name="F:SharpVk.DebugReportObjectType.CommandBuffer">
            <summary>
            ename:VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT is a
            sname:VkCommandBuffer.
            </summary>
        </member>
        <member name="F:SharpVk.DebugReportObjectType.Fence">
            <summary>
            ename:VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT is a sname:VkFence.
            </summary>
        </member>
        <member name="F:SharpVk.DebugReportObjectType.DeviceMemory">
            <summary>
            ename:VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT is a
            sname:VkDeviceMemory.
            </summary>
        </member>
        <member name="F:SharpVk.DebugReportObjectType.Buffer">
            <summary>
            ename:VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT is a sname:VkBuffer.
            </summary>
        </member>
        <member name="F:SharpVk.DebugReportObjectType.Image">
            <summary>
            ename:VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT is a sname:VkImage.
            </summary>
        </member>
        <member name="F:SharpVk.DebugReportObjectType.Event">
            <summary>
            ename:VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT is a sname:VkEvent.
            </summary>
        </member>
        <member name="F:SharpVk.DebugReportObjectType.QueryPool">
            <summary>
            ename:VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT is a
            sname:VkQueryPool.
            </summary>
        </member>
        <member name="F:SharpVk.DebugReportObjectType.BufferView">
            <summary>
            ename:VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT is a
            sname:VkBufferView.
            </summary>
        </member>
        <member name="F:SharpVk.DebugReportObjectType.ImageView">
            <summary>
            ename:VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT is a
            sname:VkImageView.
            </summary>
        </member>
        <member name="F:SharpVk.DebugReportObjectType.ShaderModule">
            <summary>
            ename:VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT is a
            sname:VkShaderModule.
            </summary>
        </member>
        <member name="F:SharpVk.DebugReportObjectType.PipelineCache">
            <summary>
            ename:VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT is a
            sname:VkPipelineCache.
            </summary>
        </member>
        <member name="F:SharpVk.DebugReportObjectType.PipelineLayout">
            <summary>
            ename:VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT is a
            sname:VkPipelineLayout.
            </summary>
        </member>
        <member name="F:SharpVk.DebugReportObjectType.RenderPass">
            <summary>
            ename:VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT is a
            sname:VkRenderPass.
            </summary>
        </member>
        <member name="F:SharpVk.DebugReportObjectType.Pipeline">
            <summary>
            ename:VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT is a
            sname:VkPipeline.
            </summary>
        </member>
        <member name="F:SharpVk.DebugReportObjectType.DescriptorSetLayout">
            <summary>
            ename:VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT is a
            sname:VkDescriptorSetLayout.
            </summary>
        </member>
        <member name="F:SharpVk.DebugReportObjectType.Sampler">
            <summary>
            ename:VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT is a sname:VkSampler.
            </summary>
        </member>
        <member name="F:SharpVk.DebugReportObjectType.DescriptorPool">
            <summary>
            ename:VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT is a
            sname:VkDescriptorPool.
            </summary>
        </member>
        <member name="F:SharpVk.DebugReportObjectType.DescriptorSet">
            <summary>
            ename:VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT is a
            sname:VkDescriptorSet.
            </summary>
        </member>
        <member name="F:SharpVk.DebugReportObjectType.Framebuffer">
            <summary>
            ename:VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT is a
            sname:VkFramebuffer.
            </summary>
        </member>
        <member name="F:SharpVk.DebugReportObjectType.CommandPool">
            <summary>
            ename:VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT is a
            sname:VkCommandPool.
            </summary>
        </member>
        <member name="F:SharpVk.DebugReportObjectType.SurfaceKhr">
            <summary>
            ename:VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT is a
            sname:VkSurfaceKHR.
            </summary>
        </member>
        <member name="F:SharpVk.DebugReportObjectType.SwapchainKhr">
            <summary>
            ename:VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT is a
            sname:VkSwapchainKHR.
            </summary>
        </member>
        <member name="F:SharpVk.DebugReportObjectType.DebugReport">
            <summary>
            ename:VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT is a
            sname:VkDebugReportCallbackEXT.
            </summary>
        </member>
        <member name="F:SharpVk.DebugReportObjectType.DisplayKhr">
            <summary>
            ename:VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT is a
            sname:VkDisplayKHR.
            </summary>
        </member>
        <member name="F:SharpVk.DebugReportObjectType.DisplayModeKhr">
            <summary>
            ename:VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT is a
            sname:VkDisplayModeKHR.
            </summary>
        </member>
        <member name="F:SharpVk.DebugReportObjectType.ObjectTableNvx">
            <summary>
            ename:VK_DEBUG_REPORT_OBJECT_TYPE_OBJECT_TABLE_NVX_EXT is a
            sname:VkObjectTableNVX.
            </summary>
        </member>
        <member name="F:SharpVk.DebugReportObjectType.IndirectCommandsLayoutNvx">
            <summary>
            ename:VK_DEBUG_REPORT_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX_EXT
            is a sname:VkIndirectCommandsLayoutNVX.
            </summary>
        </member>
        <member name="T:SharpVk.DedicatedAllocationBufferCreateInfo">
            <summary>
            <para>
            Specify that a buffer is bound to a dedicated memory resource.
            </para>
            <para>
            If the pname:pNext list includes a
            sname:VkDedicatedAllocationBufferCreateInfoNV structure, then that
            structure includes an enable controlling whether the buffer will have a
            dedicated memory allocation bound to it.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.DedicatedAllocationBufferCreateInfo.DedicatedAllocation">
            <summary>
            pname:dedicatedAllocation indicates whether the buffer will have a
            dedicated allocation bound to it.
            </summary>
        </member>
        <member name="T:SharpVk.DedicatedAllocationImageCreateInfo">
            <summary>
            <para>
            Specify that an image is bound to a dedicated memory resource.
            </para>
            <para>
            If the pname:pNext list includes a
            sname:VkDedicatedAllocationImageCreateInfoNV structure, then that
            structure includes an enable controlling whether the image will have a
            dedicated memory allocation bound to it.
            </para>
            <para>
            [NOTE] .Note ==== Using a dedicated allocation for color and
            depth/stencil attachments or other large images may: improve
            performance on some devices. ====
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.DedicatedAllocationImageCreateInfo.DedicatedAllocation">
            <summary>
            pname:dedicatedAllocation indicates whether the image will have a
            dedicated allocation bound to it.
            </summary>
        </member>
        <member name="T:SharpVk.DedicatedAllocationMemoryAllocateInfo">
            <summary>
            <para>
            Specify a dedicated memory allocation resource.
            </para>
            <para>
            If the pname:pNext list includes a
            sname:VkDedicatedAllocationMemoryAllocateInfoNV structure, then that
            structure includes a handle of the sole buffer or image resource that
            the memory can: be bound to.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.DedicatedAllocationMemoryAllocateInfo.Image">
            <summary>
            pname:image is sname:VK_NULL_HANDLE or a handle of an image which
            this memory will be bound to.
            </summary>
        </member>
        <member name="P:SharpVk.DedicatedAllocationMemoryAllocateInfo.Buffer">
            <summary>
            pname:buffer is sname:VK_NULL_HANDLE or a handle of a buffer which
            this memory will be bound to.
            </summary>
        </member>
        <member name="T:SharpVk.DependencyFlags">
            <summary>
            <para>
            Bitmask specifying how execution and memory dependencies are formed.
            </para>
            <para>
            When flink:vkCmdPipelineBarrier is submitted to a queue, it defines a
            memory dependency between commands that were submitted before it, and
            those submitted after it.
            </para>
            <para>
            If flink:vkCmdPipelineBarrier was recorded outside a render pass
            instance, the first &lt;&lt;synchronization-dependencies-scopes,
            synchronization scope&gt;&gt; includes every command submitted to the
            same queue before it, including those in the same command buffer and
            batch. If flink:vkCmdPipelineBarrier was recorded inside a render pass
            instance, the first synchronization scope includes only commands
            submitted before it within the same subpass. In either case, the first
            synchronization scope is limited to operations on the pipeline stages
            determined by the &lt;&lt;synchronization-pipeline-stages-masks, source
            stage mask&gt;&gt; specified by pname:srcStageMask.
            </para>
            <para>
            If flink:vkCmdPipelineBarrier was recorded outside a render pass
            instance, the second &lt;&lt;synchronization-dependencies-scopes,
            synchronization scope&gt;&gt; includes every command submitted to the
            same queue after it, including those in the same command buffer and
            batch. If flink:vkCmdPipelineBarrier was recorded inside a render pass
            instance, the second synchronization scope includes only commands
            submitted after it within the same subpass. In either case, the second
            synchronization scope is limited to operations on the pipeline stages
            determined by the &lt;&lt;synchronization-pipeline-stages-masks,
            destination stage mask&gt;&gt; specified by pname:dstStageMask.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DependencyFlags.None">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.DependencyFlags.ByRegion">
            <summary>
            Dependency is per pixel region 
            </summary>
        </member>
        <member name="T:SharpVk.DescriptorBufferInfo">
            <summary>
            Structure specifying descriptor buffer info.
            </summary>
        </member>
        <member name="P:SharpVk.DescriptorBufferInfo.Buffer">
            <summary>
            pname:buffer is the buffer resource.
            </summary>
        </member>
        <member name="P:SharpVk.DescriptorBufferInfo.Offset">
            <summary>
            pname:offset is the offset in bytes from the start of pname:buffer.
            Access to buffer memory via this descriptor uses addressing that is
            relative to this starting offset.
            </summary>
        </member>
        <member name="P:SharpVk.DescriptorBufferInfo.Range">
            <summary>
            pname:range is the size in bytes that is used for this descriptor
            update, or ename:VK_WHOLE_SIZE to use the range from pname:offset
            to the end of the buffer. + -- [NOTE] .Note ==== When using
            ename:VK_WHOLE_SIZE, the effective range must: not be larger than
            the maximum range for the descriptor type
            (&lt;&lt;features-limits-maxUniformBufferRange, maxUniformBufferRange&gt;&gt;
            or &lt;&lt;features-limits-maxStorageBufferRange,
            maxStorageBufferRange&gt;&gt;). This means that ename:VK_WHOLE_SIZE
            is not typically useful in the common case where uniform buffer
            descriptors are suballocated from a buffer that is much larger than
            pname:maxUniformBufferRange. ==== -- + For
            ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC and
            ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC descriptor types,
            pname:offset is the base offset from which the dynamic offset is
            applied and pname:range is the static size used for all dynamic
            offsets.
            </summary>
        </member>
        <member name="T:SharpVk.DescriptorImageInfo">
            <summary>
            <para>
            Structure specifying descriptor image info.
            </para>
            <para>
            Members of sname:VkDescriptorImageInfo that are not used in an update
            (as described above) are ignored.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.DescriptorImageInfo.Sampler">
            <summary>
            pname:sampler is a sampler handle, and is used in descriptor
            updates for types ename:VK_DESCRIPTOR_TYPE_SAMPLER and
            ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER if the binding
            being updated does not use immutable samplers.
            </summary>
        </member>
        <member name="P:SharpVk.DescriptorImageInfo.ImageView">
            <summary>
            pname:imageView is an image view handle, and is used in descriptor
            updates for types ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
            ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,
            and ename:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT.
            </summary>
        </member>
        <member name="P:SharpVk.DescriptorImageInfo.ImageLayout">
            <summary>
            pname:imageLayout is the layout that the image will be in at the
            time this descriptor is accessed. pname:imageLayout is used in
            descriptor updates for types
            ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE,
            ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, and
            ename:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT.
            </summary>
        </member>
        <member name="T:SharpVk.DescriptorPool">
            <summary>
            <para>
            Opaque handle to a descriptor pool object.
            </para>
            <para>
            A _descriptor pool_ maintains a pool of descriptors, from which
            descriptor sets are allocated. Descriptor pools are externally
            synchronized, meaning that the application must: not allocate and/or
            free descriptor sets from the same pool in multiple threads
            simultaneously.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.DescriptorPool.Destroy">
            <summary>
            Destroy a descriptor pool object.
            </summary>
        </member>
        <member name="M:SharpVk.DescriptorPool.Reset(SharpVk.DescriptorPoolResetFlags)">
            <summary>
            Resets a descriptor pool object.
            </summary>
        </member>
        <member name="M:SharpVk.DescriptorPool.FreeDescriptorSets(SharpVk.ArrayProxy{SharpVk.DescriptorSet})">
            <summary>
            Free one or more descriptor sets.
            </summary>
        </member>
        <member name="P:SharpVk.DescriptorPool.RawHandle">
            <summary>
            The interop handle for this DescriptorPool.
            </summary>
        </member>
        <member name="M:SharpVk.DescriptorPool.Dispose">
            <summary>
            Releases the unmanaged resources associated with this instance and
            destroys the underlying Vulkan handle.
            </summary>
        </member>
        <member name="T:SharpVk.DescriptorPoolCreateFlags">
            <summary>
            <para>
            Bitmask specifying certain supported operations on a descriptor pool.
            </para>
            <para>
            If multiple sname:VkDescriptorPoolSize structures appear in the
            pname:pPoolSizes array then the pool will be created with enough
            storage for the total number of descriptors of each type.
            </para>
            <para>
            Fragmentation of a descriptor pool is possible and may: lead to
            descriptor set allocation failures. A failure due to fragmentation is
            defined as failing a descriptor set allocation despite the sum of all
            outstanding descriptor set allocations from the pool plus the requested
            allocation requiring no more than the total number of descriptors
            requested at pool creation. Implementations provide certain guarantees
            of when fragmentation must: not cause allocation failure, as described
            below.
            </para>
            <para>
            If a descriptor pool has not had any descriptor sets freed since it was
            created or most recently reset then fragmentation must: not cause an
            allocation failure (note that this is always the case for a pool
            created without the
            ename:VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT bit set).
            Additionally, if all sets allocated from the pool since it was created
            or most recently reset use the same number of descriptors (of each
            type) and the requested allocation also uses that same number of
            descriptors (of each type), then fragmentation must: not cause an
            allocation failure.
            </para>
            <para>
            If an allocation failure occurs due to fragmentation, an application
            can: create an additional descriptor pool to perform further descriptor
            set allocations.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DescriptorPoolCreateFlags.None">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.DescriptorPoolCreateFlags.FreeDescriptorSet">
            <summary>
            Descriptor sets may be freed individually
            </summary>
        </member>
        <member name="T:SharpVk.DescriptorPoolCreateInfo">
            <summary>
            Structure specifying parameters of a newly created descriptor pool.
            </summary>
        </member>
        <member name="P:SharpVk.DescriptorPoolCreateInfo.Flags">
            <summary>
            pname:flags specifies certain supported operations on the pool.
            Bits which can: be set include: + --
            </summary>
        </member>
        <member name="P:SharpVk.DescriptorPoolCreateInfo.MaxSets">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.DescriptorPoolCreateInfo.PoolSizes">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.DescriptorPoolResetFlags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.DescriptorPoolResetFlags.None">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.DescriptorPoolSize">
            <summary>
            Structure specifying descriptor pool size.
            </summary>
        </member>
        <member name="M:SharpVk.DescriptorPoolSize.#ctor(SharpVk.DescriptorType,System.UInt32)">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.DescriptorPoolSize.Type">
            <summary>
            pname:type is the type of descriptor.
            </summary>
        </member>
        <member name="F:SharpVk.DescriptorPoolSize.DescriptorCount">
            <summary>
            pname:descriptorCount is the number of descriptors of that type to
            allocate.
            </summary>
        </member>
        <member name="M:SharpVk.DescriptorPoolSize.ToString">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.DescriptorSet">
            <summary>
            Opaque handle to a descriptor set object.
            </summary>
        </member>
        <member name="P:SharpVk.DescriptorSet.RawHandle">
            <summary>
            The interop handle for this DescriptorSet.
            </summary>
        </member>
        <member name="T:SharpVk.DescriptorSetAllocateInfo">
            <summary>
            Structure specifying the allocation parameters for descriptor sets.
            </summary>
        </member>
        <member name="P:SharpVk.DescriptorSetAllocateInfo.DescriptorPool">
            <summary>
            pname:descriptorPool is the pool which the sets will be allocated
            from.
            </summary>
        </member>
        <member name="P:SharpVk.DescriptorSetAllocateInfo.SetLayouts">
            <summary>
            pname:pSetLayouts is an array of descriptor set layouts, with each
            member specifying how the corresponding descriptor set is
            allocated.
            </summary>
        </member>
        <member name="T:SharpVk.DescriptorSetLayout">
            <summary>
            <para>
            Opaque handle to a descriptor set layout object.
            </para>
            <para>
            A descriptor set layout object is defined by an array of zero or more
            descriptor bindings. Each individual descriptor binding is specified by
            a descriptor type, a count (array size) of the number of descriptors in
            the binding, a set of shader stages that can: access the binding, and
            (if using immutable samplers) an array of sampler descriptors.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.DescriptorSetLayout.Destroy">
            <summary>
            Destroy a descriptor set layout object.
            </summary>
        </member>
        <member name="P:SharpVk.DescriptorSetLayout.RawHandle">
            <summary>
            The interop handle for this DescriptorSetLayout.
            </summary>
        </member>
        <member name="M:SharpVk.DescriptorSetLayout.Dispose">
            <summary>
            Releases the unmanaged resources associated with this instance and
            destroys the underlying Vulkan handle.
            </summary>
        </member>
        <member name="T:SharpVk.DescriptorSetLayoutBinding">
            <summary>
            <para>
            Structure specifying a descriptor set layout binding.
            </para>
            <para>
            The above layout definition allows the descriptor bindings to be
            specified sparsely such that not all binding numbers between 0 and the
            maximum binding number need to be specified in the pname:pBindings
            array. Bindings that are not specified have a pname:descriptorCount and
            pname:stageFlags of zero, and the pname:descriptorType is treated as
            undefined. However, all binding numbers between 0 and the maximum
            binding number in the
            slink:VkDescriptorSetLayoutCreateInfo::pname:pBindings array may:
            consume memory in the descriptor set layout even if not all descriptor
            bindings are used, though it should: not consume additional memory from
            the descriptor pool.
            </para>
            <para>
            [NOTE] .Note ==== The maximum binding number specified should: be as
            compact as possible to avoid wasted memory. ====
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.DescriptorSetLayoutBinding.Binding">
            <summary>
            pname:binding is the binding number of this entry and corresponds
            to a resource of the same binding number in the shader stages.
            </summary>
        </member>
        <member name="P:SharpVk.DescriptorSetLayoutBinding.DescriptorType">
            <summary>
            pname:descriptorType is a elink:VkDescriptorType specifying which
            type of resource descriptors are used for this binding.
            </summary>
        </member>
        <member name="P:SharpVk.DescriptorSetLayoutBinding.DescriptorCount">
            <summary>
            pname:descriptorCount is the number of descriptors contained in the
            binding, accessed in a shader as an array. If pname:descriptorCount
            is zero this binding entry is reserved and the resource must: not
            be accessed from any stage via this binding within any pipeline
            using the set layout.
            </summary>
        </member>
        <member name="P:SharpVk.DescriptorSetLayoutBinding.StageFlags">
            <summary>
            pname:stageFlags member is a bitmask of elink:VkShaderStageFlagBits
            specifying which pipeline shader stages can: access a resource for
            this binding. ename:VK_SHADER_STAGE_ALL is a shorthand specifying
            that all defined shader stages, including any additional stages
            defined by extensions, can: access the resource. + -- If a shader
            stage is not included in pname:stageFlags, then a resource must:
            not be accessed from that stage via this binding within any
            pipeline using the set layout. There are no limitations on what
            combinations of stages can: be used by a descriptor binding, and in
            particular a binding can: be used by both graphics stages and the
            compute stage. --
            </summary>
        </member>
        <member name="P:SharpVk.DescriptorSetLayoutBinding.ImmutableSamplers">
            <summary>
            pname:pImmutableSamplers affects initialization of samplers. If
            pname:descriptorType specifies a ename:VK_DESCRIPTOR_TYPE_SAMPLER
            or ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER type descriptor,
            then pname:pImmutableSamplers can: be used to initialize a set of
            _immutable samplers_. Immutable samplers are permanently bound into
            the set layout; later binding a sampler into an immutable sampler
            slot in a descriptor set is not allowed. If
            pname:pImmutableSamplers is not `NULL`, then it is considered to be
            a pointer to an array of sampler handles that will be consumed by
            the set layout and used for the corresponding binding. If
            pname:pImmutableSamplers is `NULL`, then the sampler slots are
            dynamic and sampler handles must: be bound into descriptor sets
            using this layout. If pname:descriptorType is not one of these
            descriptor types, then pname:pImmutableSamplers is ignored.
            </summary>
        </member>
        <member name="T:SharpVk.DescriptorSetLayoutCreateFlags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.DescriptorSetLayoutCreateFlags.None">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.DescriptorSetLayoutCreateInfo">
            <summary>
            Structure specifying parameters of a newly created descriptor set
            layout.
            </summary>
        </member>
        <member name="P:SharpVk.DescriptorSetLayoutCreateInfo.Flags">
            <summary>
            pname:flags is reserved for future use.
            </summary>
        </member>
        <member name="P:SharpVk.DescriptorSetLayoutCreateInfo.Bindings">
            <summary>
            pname:pBindings is a pointer to an array of
            slink:VkDescriptorSetLayoutBinding structures.
            </summary>
        </member>
        <member name="T:SharpVk.DescriptorType">
            <summary>
            <para>
            Specifies the type of a descriptor in a descriptor set.
            </para>
            <para>
            If pname:descriptorType is ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
            ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC,
            or ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC, the elements of the
            slink:VkWriteDescriptorSet::pname:pBufferInfo array of
            slink:VkDescriptorBufferInfo structures will be used to update the
            descriptors, and other arrays will be ignored.
            </para>
            <para>
            If pname:descriptorType is
            ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER or
            ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER, the
            slink:VkWriteDescriptorSet::pname:pTexelBufferView array will be used
            to update the descriptors, and other arrays will be ignored.
            </para>
            <para>
            If pname:descriptorType is ename:VK_DESCRIPTOR_TYPE_SAMPLER,
            ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
            ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, or
            ename:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT, the elements of the
            slink:VkWriteDescriptorSet::pname:pImageInfo array of
            slink:VkDescriptorImageInfo structures will be used to update the
            descriptors, and other arrays will be ignored.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.DescriptorType.Sampler">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.DescriptorType.CombinedImageSampler">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.DescriptorType.SampledImage">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.DescriptorType.StorageImage">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.DescriptorType.UniformTexelBuffer">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.DescriptorType.StorageTexelBuffer">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.DescriptorType.UniformBuffer">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.DescriptorType.StorageBuffer">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.DescriptorType.UniformBufferDynamic">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.DescriptorType.StorageBufferDynamic">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.DescriptorType.InputAttachment">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Device">
            <summary>
            Opaque handle to a device object.
            </summary>
        </member>
        <member name="M:SharpVk.Device.GetProcedureAddress(System.String)">
            <summary>
            Return a function pointer for a command.
            </summary>
        </member>
        <member name="M:SharpVk.Device.Destroy">
            <summary>
            Destroy a logical device.
            </summary>
        </member>
        <member name="M:SharpVk.Device.GetQueue(System.UInt32,System.UInt32)">
            <summary>
            Get a queue handle from a device.
            </summary>
        </member>
        <member name="M:SharpVk.Device.WaitIdle">
            <summary>
            Wait for a device to become idle.
            </summary>
        </member>
        <member name="M:SharpVk.Device.AllocateMemory(SharpVk.MemoryAllocateInfo)">
            <summary>
            Allocate GPU memory.
            </summary>
        </member>
        <member name="M:SharpVk.Device.FreeMemory(SharpVk.DeviceMemory)">
            <summary>
            Free GPU memory.
            </summary>
        </member>
        <member name="M:SharpVk.Device.FlushMappedMemoryRanges(SharpVk.ArrayProxy{SharpVk.MappedMemoryRange})">
            <summary>
            Flush mapped memory ranges.
            </summary>
        </member>
        <member name="M:SharpVk.Device.InvalidateMappedMemoryRanges(SharpVk.ArrayProxy{SharpVk.MappedMemoryRange})">
            <summary>
            Invalidate ranges of mapped memory objects.
            </summary>
        </member>
        <member name="M:SharpVk.Device.CreateFence(SharpVk.FenceCreateInfo)">
            <summary>
            Create a new fence object.
            </summary>
        </member>
        <member name="M:SharpVk.Device.ResetFences(SharpVk.ArrayProxy{SharpVk.Fence})">
            <summary>
            Resets one or more fence objects.
            </summary>
        </member>
        <member name="M:SharpVk.Device.WaitForFences(SharpVk.ArrayProxy{SharpVk.Fence},SharpVk.Bool32,System.UInt64)">
            <summary>
            Wait for one or more fences to become signaled.
            </summary>
        </member>
        <member name="M:SharpVk.Device.CreateSemaphore(SharpVk.SemaphoreCreateInfo)">
            <summary>
            Create a new queue semaphore object.
            </summary>
        </member>
        <member name="M:SharpVk.Device.CreateEvent(SharpVk.EventCreateInfo)">
            <summary>
            Create a new event object.
            </summary>
        </member>
        <member name="M:SharpVk.Device.CreateQueryPool(SharpVk.QueryPoolCreateInfo)">
            <summary>
            Create a new query pool object.
            </summary>
        </member>
        <member name="M:SharpVk.Device.CreateBuffer(SharpVk.BufferCreateInfo)">
            <summary>
            Create a new buffer object.
            </summary>
        </member>
        <member name="M:SharpVk.Device.CreateBufferView(SharpVk.BufferViewCreateInfo)">
            <summary>
            Create a new buffer view object.
            </summary>
        </member>
        <member name="M:SharpVk.Device.CreateImage(SharpVk.ImageCreateInfo)">
            <summary>
            Create a new image object.
            </summary>
        </member>
        <member name="M:SharpVk.Device.CreateImageView(SharpVk.ImageViewCreateInfo)">
            <summary>
            Create an image view from an existing image.
            </summary>
        </member>
        <member name="M:SharpVk.Device.CreateShaderModule(SharpVk.ShaderModuleCreateInfo)">
            <summary>
            Creates a new shader module object.
            </summary>
        </member>
        <member name="M:SharpVk.Device.CreatePipelineCache(SharpVk.PipelineCacheCreateInfo)">
            <summary>
            Creates a new pipeline cache.
            </summary>
        </member>
        <member name="M:SharpVk.Device.CreateGraphicsPipelines(SharpVk.PipelineCache,SharpVk.ArrayProxy{SharpVk.GraphicsPipelineCreateInfo})">
            <summary>
            Create graphics pipelines.
            </summary>
        </member>
        <member name="M:SharpVk.Device.CreateComputePipelines(SharpVk.PipelineCache,SharpVk.ArrayProxy{SharpVk.ComputePipelineCreateInfo})">
            <summary>
            Creates a new compute pipeline object.
            </summary>
        </member>
        <member name="M:SharpVk.Device.CreatePipelineLayout(SharpVk.PipelineLayoutCreateInfo)">
            <summary>
            Creates a new pipeline layout object.
            </summary>
        </member>
        <member name="M:SharpVk.Device.CreateSampler(SharpVk.SamplerCreateInfo)">
            <summary>
            Create a new sampler object.
            </summary>
        </member>
        <member name="M:SharpVk.Device.CreateDescriptorSetLayout(SharpVk.DescriptorSetLayoutCreateInfo)">
            <summary>
            Create a new descriptor set layout.
            </summary>
        </member>
        <member name="M:SharpVk.Device.CreateDescriptorPool(SharpVk.DescriptorPoolCreateInfo)">
            <summary>
            Creates a descriptor pool object.
            </summary>
        </member>
        <member name="M:SharpVk.Device.AllocateDescriptorSets(SharpVk.DescriptorSetAllocateInfo)">
            <summary>
            Allocate one or more descriptor sets.
            </summary>
        </member>
        <member name="M:SharpVk.Device.UpdateDescriptorSets(SharpVk.ArrayProxy{SharpVk.WriteDescriptorSet},SharpVk.ArrayProxy{SharpVk.CopyDescriptorSet})">
            <summary>
            Update the contents of a descriptor set object.
            </summary>
        </member>
        <member name="M:SharpVk.Device.CreateFramebuffer(SharpVk.FramebufferCreateInfo)">
            <summary>
            Create a new framebuffer object.
            </summary>
        </member>
        <member name="M:SharpVk.Device.CreateRenderPass(SharpVk.RenderPassCreateInfo)">
            <summary>
            Create a new render pass object.
            </summary>
        </member>
        <member name="M:SharpVk.Device.CreateCommandPool(SharpVk.CommandPoolCreateInfo)">
            <summary>
            Create a new command pool object.
            </summary>
        </member>
        <member name="M:SharpVk.Device.AllocateCommandBuffers(SharpVk.CommandBufferAllocateInfo)">
            <summary>
            Allocate command buffers from an existing command pool.
            </summary>
        </member>
        <member name="M:SharpVk.Device.CreateSwapchain(SharpVk.SwapchainCreateInfo)">
            <summary>
            Create a swapchain.
            </summary>
        </member>
        <member name="M:SharpVk.Device.CreateSharedSwapchains(SharpVk.ArrayProxy{SharpVk.SwapchainCreateInfo})">
            <summary>
            Create multiple swapchains that share presentable images.
            </summary>
        </member>
        <member name="M:SharpVk.Device.DebugMarkerSetObjectTag(SharpVk.DebugMarkerObjectTagInfo)">
            <summary>
            Attach arbitrary data to an object.
            </summary>
        </member>
        <member name="M:SharpVk.Device.DebugMarkerSetObjectName(SharpVk.DebugMarkerObjectNameInfo)">
            <summary>
            Give a user-friendly name to an object.
            </summary>
        </member>
        <member name="M:SharpVk.Device.CreateIndirectCommandsLayout(SharpVk.IndirectCommandsLayoutCreateInfo)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Device.CreateObjectTable(SharpVk.ObjectTableCreateInfo)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Device.DisplayPowerControl(SharpVk.Display,SharpVk.DisplayPowerInfo)">
            <summary>
            Set the power state of a display.
            </summary>
        </member>
        <member name="M:SharpVk.Device.RegisterEvent(SharpVk.DeviceEventInfo)">
            <summary>
            Signal a fence when a device event occurs.
            </summary>
        </member>
        <member name="M:SharpVk.Device.RegisterDisplayEvent(SharpVk.Display,SharpVk.DisplayEventInfo)">
            <summary>
            Signal a fence when a display event occurs.
            </summary>
        </member>
        <member name="P:SharpVk.Device.RawHandle">
            <summary>
            The interop handle for this Device.
            </summary>
        </member>
        <member name="M:SharpVk.Device.Dispose">
            <summary>
            Releases the unmanaged resources associated with this instance and
            destroys the underlying Vulkan handle.
            </summary>
        </member>
        <member name="T:SharpVk.DeviceCreateFlags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.DeviceCreateFlags.None">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.DeviceCreateInfo">
            <summary>
            Structure specifying parameters of a newly created device.
            </summary>
        </member>
        <member name="P:SharpVk.DeviceCreateInfo.Flags">
            <summary>
            pname:flags is reserved for future use.
            </summary>
        </member>
        <member name="P:SharpVk.DeviceCreateInfo.QueueCreateInfos">
            <summary>
            pname:pQueueCreateInfos is a pointer to an array of
            slink:VkDeviceQueueCreateInfo structures describing the queues that
            are requested to be created along with the logical device. Refer to
            the &lt;&lt;devsandqueues-queue-creation,Queue Creation&gt;&gt;
            section below for further details.
            </summary>
        </member>
        <member name="P:SharpVk.DeviceCreateInfo.EnabledLayerNames">
            <summary>
            pname:ppEnabledLayerNames is deprecated and ignored. See
            &lt;&lt;extended-functionality-device-layer-deprecation,Device Layer
            Deprecation&gt;&gt;.
            </summary>
        </member>
        <member name="P:SharpVk.DeviceCreateInfo.EnabledExtensionNames">
            <summary>
            pname:ppEnabledExtensionNames is a pointer to an array of
            pname:enabledExtensionCount null-terminated UTF-8 strings
            containing the names of extensions to enable for the created
            device. See the
            &lt;&lt;extended-functionality-extensions,Extensions&gt;&gt; section
            for further details.
            </summary>
        </member>
        <member name="P:SharpVk.DeviceCreateInfo.EnabledFeatures">
            <summary>
            pname:pEnabledFeatures is `NULL` or a pointer to a
            slink:VkPhysicalDeviceFeatures structure that contains boolean
            indicators of all the features to be enabled. Refer to the
            &lt;&lt;features-features,Features&gt;&gt; section for further
            details.
            </summary>
        </member>
        <member name="T:SharpVk.DeviceEventInfo">
            <summary>
            Describe a device event to create.
            </summary>
        </member>
        <member name="P:SharpVk.DeviceEventInfo.DeviceEvent">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.DeviceEventType">
            <summary>
            Events that can occur on a device object.
            </summary>
        </member>
        <member name="F:SharpVk.DeviceEventType.DisplayHotplug">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.DeviceGeneratedCommandsFeatures">
            <summary>
            Structure specifying physical device support.
            </summary>
        </member>
        <member name="P:SharpVk.DeviceGeneratedCommandsFeatures.ComputeBindingPointSupport">
            <summary>
            pname:computeBindingPointSupport indicates whether the
            sname:VkObjectTableNVX supports entries with
            ename:VK_OBJECT_ENTRY_USAGE_GRAPHICS_BIT_NVX bit set and
            sname:VkIndirectCommandsLayoutNVX supports
            ename:VK_PIPELINE_BIND_POINT_COMPUTE.
            </summary>
        </member>
        <member name="T:SharpVk.DeviceGeneratedCommandsLimits">
            <summary>
            Structure specifying physical device limits.
            </summary>
        </member>
        <member name="P:SharpVk.DeviceGeneratedCommandsLimits.MaxIndirectCommandsLayoutTokenCount">
            <summary>
            pname:maxIndirectCommandsLayoutTokenCount the maximum number of
            tokens in sname:VkIndirectCommandsLayoutNVX.
            </summary>
        </member>
        <member name="P:SharpVk.DeviceGeneratedCommandsLimits.MaxObjectEntryCounts">
            <summary>
            pname:maxObjectEntryCounts the maximum number of entries per
            resource type in sname:VkObjectTableNVX.
            </summary>
        </member>
        <member name="P:SharpVk.DeviceGeneratedCommandsLimits.MinSequenceCountBufferOffsetAlignment">
            <summary>
            pname:minSequenceCountBufferOffsetAlignment the minimum alignment
            for memory addresses optionally used in
            fname:vkCmdProcessCommandsNVX.
            </summary>
        </member>
        <member name="P:SharpVk.DeviceGeneratedCommandsLimits.MinSequenceIndexBufferOffsetAlignment">
            <summary>
            pname:minSequenceIndexBufferOffsetAlignment the minimum alignment
            for memory addresses optionally used in
            fname:vkCmdProcessCommandsNVX.
            </summary>
        </member>
        <member name="P:SharpVk.DeviceGeneratedCommandsLimits.MinCommandsTokenBufferOffsetAlignment">
            <summary>
            pname:minCommandsTokenBufferOffsetAlignment the minimum alignment
            for memory addresses optionally used in
            fname:vkCmdProcessCommandsNVX.
            </summary>
        </member>
        <member name="T:SharpVk.DeviceMemory">
            <summary>
            <para>
            Opaque handle to a device memory object.
            </para>
            <para>
            A Vulkan device operates on data in device memory via memory objects
            that are represented in the API by a sname:VkDeviceMemory handle.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.DeviceMemory.MapMemory(SharpVk.DeviceSize,SharpVk.DeviceSize,SharpVk.MemoryMapFlags,System.IntPtr@)">
            <summary>
            Map a memory object into application address space.
            </summary>
        </member>
        <member name="M:SharpVk.DeviceMemory.UnmapMemory">
            <summary>
            Unmap a previously mapped memory object.
            </summary>
        </member>
        <member name="M:SharpVk.DeviceMemory.GetCommitment">
            <summary>
            Query the current commitment for a VkDeviceMemory.
            </summary>
        </member>
        <member name="M:SharpVk.DeviceMemory.GetMemoryWin32Handle(SharpVk.ExternalMemoryHandleTypeFlags)">
            <summary>
            Retrieve Win32 handle to a device memory object.
            </summary>
        </member>
        <member name="P:SharpVk.DeviceMemory.RawHandle">
            <summary>
            The interop handle for this DeviceMemory.
            </summary>
        </member>
        <member name="T:SharpVk.DeviceQueueCreateFlags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.DeviceQueueCreateFlags.None">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.DeviceQueueCreateInfo">
            <summary>
            Structure specifying parameters of a newly created device queue.
            </summary>
        </member>
        <member name="P:SharpVk.DeviceQueueCreateInfo.Flags">
            <summary>
            pname:flags is reserved for future use.
            </summary>
        </member>
        <member name="P:SharpVk.DeviceQueueCreateInfo.QueueFamilyIndex">
            <summary>
            pname:queueFamilyIndex is an unsigned integer indicating the index
            of the queue family to create on this device. This index
            corresponds to the index of an element of the
            pname:pQueueFamilyProperties array that was returned by
            fname:vkGetPhysicalDeviceQueueFamilyProperties.
            </summary>
        </member>
        <member name="P:SharpVk.DeviceQueueCreateInfo.QueuePriorities">
            <summary>
            pname:pQueuePriorities is an array of pname:queueCount normalized
            floating point values, specifying priorities of work that will be
            submitted to each created queue. See
            &lt;&lt;devsandqueues-priority,Queue Priority&gt;&gt; for more
            information.
            </summary>
        </member>
        <member name="T:SharpVk.DispatchIndirectCommand">
            <summary>
            <para>
            Structure specifying a dispatch indirect command.
            </para>
            <para>
            The members of sname:VkDispatchIndirectCommand structure have the same
            meaning as the similarly named parameters of flink:vkCmdDispatch.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.DispatchIndirectCommand.#ctor(System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.DispatchIndirectCommand.X">
            <summary>
            pname:x is the number of local workgroups to dispatch in the X
            dimension.
            </summary>
        </member>
        <member name="F:SharpVk.DispatchIndirectCommand.Y">
            <summary>
            pname:y is the number of local workgroups to dispatch in the Y
            dimension.
            </summary>
        </member>
        <member name="F:SharpVk.DispatchIndirectCommand.Z">
            <summary>
            pname:z is the number of local workgroups to dispatch in the Z
            dimension.
            </summary>
        </member>
        <member name="M:SharpVk.DispatchIndirectCommand.ToString">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Display">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.Display.RawHandle">
            <summary>
            The interop handle for this Display.
            </summary>
        </member>
        <member name="T:SharpVk.DisplayEventInfo">
            <summary>
            Describe a display event to create.
            </summary>
        </member>
        <member name="P:SharpVk.DisplayEventInfo.DisplayEvent">
            <summary>
            pname:displayEvent specifies when the fence will be signaled.
            Possible values are: + --
            </summary>
        </member>
        <member name="T:SharpVk.DisplayEventType">
            <summary>
            Events that can occur on a display object.
            </summary>
        </member>
        <member name="F:SharpVk.DisplayEventType.FirstPixelOut">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.DisplayMode">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.DisplayMode.GetDisplayPlaneCapabilities(System.UInt32)">
            <summary>
            Query capabilities of a mode and plane combination.
            </summary>
        </member>
        <member name="P:SharpVk.DisplayMode.RawHandle">
            <summary>
            The interop handle for this DisplayMode.
            </summary>
        </member>
        <member name="T:SharpVk.DisplayModeCreateFlags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.DisplayModeCreateFlags.None">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.DisplayModeCreateInfo">
            <summary>
            Structure specifying parameters of a newly created display mode object.
            </summary>
        </member>
        <member name="P:SharpVk.DisplayModeCreateInfo.Flags">
            <summary>
            pname:flags is reserved for future use, and must: be zero.
            </summary>
        </member>
        <member name="P:SharpVk.DisplayModeCreateInfo.Parameters">
            <summary>
            pname:parameters is a sname:VkDisplayModeParametersKHR structure
            describing the display parameters to use in creating the new mode.
            If the parameters are not compatible with the specified display,
            the implementation must: return
            ename:VK_ERROR_INITIALIZATION_FAILED.
            </summary>
        </member>
        <member name="T:SharpVk.DisplayModeParameters">
            <summary>
            <para>
            Structure describing display parameters associated with a display mode.
            </para>
            <para>
            [NOTE] .Note ==== For example, a 60Hz display mode would report a
            pname:refreshRate of 60,000. ====
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.DisplayModeParameters.#ctor(SharpVk.Extent2D,System.UInt32)">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.DisplayModeParameters.VisibleRegion">
            <summary>
            pname:visibleRegion is the 2D extents of the visible region.
            </summary>
        </member>
        <member name="F:SharpVk.DisplayModeParameters.RefreshRate">
            <summary>
            pname:refreshRate is a code:uint32_t that is the number of times
            the display is refreshed each second multiplied by 1000.
            </summary>
        </member>
        <member name="M:SharpVk.DisplayModeParameters.ToString">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.DisplayModeProperties">
            <summary>
            Structure describing display mode properties.
            </summary>
        </member>
        <member name="P:SharpVk.DisplayModeProperties.DisplayMode">
            <summary>
            pname:displayMode is a handle to the display mode described in this
            structure. This handle will be valid for the lifetime of the Vulkan
            instance.
            </summary>
        </member>
        <member name="P:SharpVk.DisplayModeProperties.Parameters">
            <summary>
            pname:parameters is a sname:VkDisplayModeParametersKHR structure
            describing the display parameters associated with
            pname:displayMode.
            </summary>
        </member>
        <member name="T:SharpVk.DisplayPlaneAlphaFlags">
            <summary>
            Alpha blending type.
            </summary>
        </member>
        <member name="F:SharpVk.DisplayPlaneAlphaFlags.None">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.DisplayPlaneAlphaFlags.Opaque">
            <summary>
            ename:VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR: The source image will
            be treated as opaque.
            </summary>
        </member>
        <member name="F:SharpVk.DisplayPlaneAlphaFlags.Global">
            <summary>
            ename:VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR: A global alpha value
            must: be specified that will be applied to all pixels in the source
            image.
            </summary>
        </member>
        <member name="F:SharpVk.DisplayPlaneAlphaFlags.PerPixel">
            <summary>
            ename:VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR: The alpha value
            will be determined by the alpha channel of the source image's
            pixels. If the source format contains no alpha values, no blending
            will be applied. The source alpha values are not premultiplied into
            the source image's other color channels.
            </summary>
        </member>
        <member name="F:SharpVk.DisplayPlaneAlphaFlags.PerPixelPremultiplied">
            <summary>
            ename:VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR: This
            is equivalent to ename:VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR
            except the source alpha values are assumed to be premultiplied into
            the source image's other color channels.
            </summary>
        </member>
        <member name="T:SharpVk.DisplayPlaneCapabilities">
            <summary>
            <para>
            Structure describing capabilities of a mode and plane combination.
            </para>
            <para>
            The minimum and maximum position and extent fields describe the
            hardware limits, if any, as they apply to the specified display mode
            and plane. Vendors may: support displaying a subset of a swapchain's
            presentable images on the specified display plane. This is expressed by
            returning pname:minSrcPosition, pname:maxSrcPosition,
            pname:minSrcExtent, and pname:maxSrcExtent values that indicate a range
            of possible positions and sizes may: be used to specify the region
            within the presentable images that source pixels will be read from when
            creating a swapchain on the specified display mode and plane.
            </para>
            <para>
            Vendors may: also support mapping the presentable images' content to a
            subset or superset of the visible region in the specified display mode.
            This is expressed by returning pname:minDstPosition,
            pname:maxDstPosition, pname:minDstExtent and pname:maxDstExtent values
            that indicate a range of possible positions and sizes may: be used to
            describe the region within the display mode that the source pixels will
            be mapped to.
            </para>
            <para>
            Other vendors may: support only a 1-1 mapping between pixels in the
            presentable images and the display mode. This may: be indicated by
            returning [eq]#(0,0)# for pname:minSrcPosition, pname:maxSrcPosition,
            pname:minDstPosition, and pname:maxDstPosition, and (display mode
            width, display mode height) for pname:minSrcExtent, pname:maxSrcExtent,
            pname:minDstExtent, and pname:maxDstExtent.
            </para>
            <para>
            These values indicate the limits of the hardware's individual fields.
            Not all combinations of values within the offset and extent ranges
            returned in sname:VkDisplayPlaneCapabilitiesKHR are guaranteed to be
            supported. Vendors may: still fail presentation requests that specify
            unsupported combinations.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.DisplayPlaneCapabilities.#ctor(SharpVk.DisplayPlaneAlphaFlags,SharpVk.Offset2D,SharpVk.Offset2D,SharpVk.Extent2D,SharpVk.Extent2D,SharpVk.Offset2D,SharpVk.Offset2D,SharpVk.Extent2D,SharpVk.Extent2D)">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.DisplayPlaneCapabilities.SupportedAlpha">
            <summary>
            pname:supportedAlpha is a bitmask of
            elink:VkDisplayPlaneAlphaFlagBitsKHR describing the supported alpha
            blending modes.
            </summary>
        </member>
        <member name="F:SharpVk.DisplayPlaneCapabilities.MinSourcePosition">
            <summary>
            pname:minSrcPosition is the minimum source rectangle offset
            supported by this plane using the specified mode.
            </summary>
        </member>
        <member name="F:SharpVk.DisplayPlaneCapabilities.MaxSourcePosition">
            <summary>
            pname:maxSrcPosition is the maximum source rectangle offset
            supported by this plane using the specified mode. The pname:x and
            pname:y components of pname:maxSrcPosition must: each be greater
            than or equal to the pname:x and pname:y components of
            pname:minSrcPosition, respectively.
            </summary>
        </member>
        <member name="F:SharpVk.DisplayPlaneCapabilities.MinSourceExtent">
            <summary>
            pname:minSrcExtent is the minimum source rectangle size supported
            by this plane using the specified mode.
            </summary>
        </member>
        <member name="F:SharpVk.DisplayPlaneCapabilities.MaxSourceExtent">
            <summary>
            pname:maxSrcExtent is the maximum source rectangle size supported
            by this plane using the specified mode.
            </summary>
        </member>
        <member name="F:SharpVk.DisplayPlaneCapabilities.MinDestinationPosition">
            <summary>
            pname:minDstPosition, pname:maxDstPosition, pname:minDstExtent,
            pname:maxDstExtent all have similar semantics to their
            corresponding "Src" equivalents, but apply to the output region
            within the mode rather than the input region within the source
            image. Unlike the "Src" offsets, pname:minDstPosition and
            pname:maxDstPosition may: contain negative values.
            </summary>
        </member>
        <member name="F:SharpVk.DisplayPlaneCapabilities.MaxDestinationPosition">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.DisplayPlaneCapabilities.MinDestinationExtent">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.DisplayPlaneCapabilities.MaxDestinationExtent">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.DisplayPlaneCapabilities.ToString">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.DisplayPlaneProperties">
            <summary>
            Structure describing display plane properties.
            </summary>
        </member>
        <member name="P:SharpVk.DisplayPlaneProperties.CurrentDisplay">
            <summary>
            pname:currentDisplay is the handle of the display the plane is
            currently associated with. If the plane is not currently attached
            to any displays, this will be sname:VK_NULL_HANDLE.
            </summary>
        </member>
        <member name="P:SharpVk.DisplayPlaneProperties.CurrentStackIndex">
            <summary>
            pname:currentStackIndex is the current z-order of the plane. This
            will be between 0 and the value returned by
            fname:vkGetPhysicalDeviceDisplayPlanePropertiesKHR() in
            pname:pPropertyCount.
            </summary>
        </member>
        <member name="T:SharpVk.DisplayPowerInfo">
            <summary>
            Describe the power state of a display.
            </summary>
        </member>
        <member name="P:SharpVk.DisplayPowerInfo.PowerState">
            <summary>
            pname:powerState is the new power state of the display. Possible
            values are: + --
            </summary>
        </member>
        <member name="T:SharpVk.DisplayPowerState">
            <summary>
            Possible power states for a VkDisplay.
            </summary>
        </member>
        <member name="F:SharpVk.DisplayPowerState.Off">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.DisplayPowerState.Suspend">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.DisplayPowerState.On">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.DisplayPresentInfo">
            <summary>
            <para>
            Structure describing parameters of a queue presentation to a swapchain.
            </para>
            <para>
            If the extent of the pname:srcRect and pname:dstRect are not equal, the
            presented pixels will be scaled accordingly.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.DisplayPresentInfo.SourceRect">
            <summary>
            pname:srcRect is a rectangular region of pixels to present. It
            must: be a subset of the image being presented. If
            sname:VkDisplayPresentInfoKHR is not specified, this region will be
            assumed to be the entire presentable image.
            </summary>
        </member>
        <member name="P:SharpVk.DisplayPresentInfo.DestinationRect">
            <summary>
            pname:dstRect is a rectangular region within the visible region of
            the swapchain's display mode. If sname:VkDisplayPresentInfoKHR is
            not specified, this region will be assumed to be the entire visible
            region of the visible region of the swapchain's mode. If the
            specified rectangle is a subset of the display mode's visible
            region, content from display planes below the swapchain's plane
            will be visible outside the rectangle. If there are no planes below
            the swapchain's, the area outside the specified rectangle will be
            black. If portions of the specified rectangle are outside of the
            display's visible region, pixels mapping only to those portions of
            the rectangle will be discarded.
            </summary>
        </member>
        <member name="P:SharpVk.DisplayPresentInfo.Persistent">
            <summary>
            pname:persistent: If this is ename:VK_TRUE, the display engine will
            enable buffered mode on displays that support it. This allows the
            display engine to stop sending content to the display until a new
            image is presented. The display will instead maintain a copy of the
            last presented image. This allows less power to be used, but may:
            increase presentation latency. If sname:VkDisplayPresentInfoKHR is
            not specified, persistent mode will not be used.
            </summary>
        </member>
        <member name="T:SharpVk.DisplayProperties">
            <summary>
            <para>
            Structure describing an available display device.
            </para>
            <para>
            [NOTE] .Note ==== For devices which have no natural value to return
            here, implementations should: return the maximum resolution supported.
            ====
            </para>
            <para>
            * pname:supportedTransforms tells which transforms are supported by
            this display. This will contain one or more of the bits from
            sname:VkSurfaceTransformFlagsKHR. * pname:planeReorderPossible tells
            whether the planes on this display can: have their z order changed. If
            this is ename:VK_TRUE, the application can: re-arrange the planes on
            this display in any order relative to each other. *
            pname:persistentContent tells whether the display supports
            self-refresh/internal buffering. If this is true, the application can:
            submit persistent present operations on swapchains created against this
            display.
            </para>
            <para>
            [NOTE] .Note ==== Persistent presents may: have higher latency, and
            may: use less power when the screen content is updated infrequently, or
            when only a portion of the screen needs to be updated in most frames.
            ====
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.DisplayProperties.Display">
            <summary>
            pname:display is a handle that is used to refer to the display
            described here. This handle will be valid for the lifetime of the
            Vulkan instance.
            </summary>
        </member>
        <member name="P:SharpVk.DisplayProperties.DisplayName">
            <summary>
            pname:displayName is a pointer to a NULL-terminated string
            containing the name of the display. Generally, this will be the
            name provided by the display's EDID. It can: be `NULL` if no
            suitable name is available.
            </summary>
        </member>
        <member name="P:SharpVk.DisplayProperties.PhysicalDimensions">
            <summary>
            pname:physicalDimensions describes the physical width and height of
            the visible portion of the display, in millimeters.
            </summary>
        </member>
        <member name="P:SharpVk.DisplayProperties.PhysicalResolution">
            <summary>
            pname:physicalResolution describes the physical, native, or
            preferred resolution of the display.
            </summary>
        </member>
        <member name="P:SharpVk.DisplayProperties.SupportedTransforms">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.DisplayProperties.PlaneReorderPossible">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.DisplayProperties.PersistentContent">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.DisplaySurfaceCreateFlags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.DisplaySurfaceCreateFlags.None">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.DisplaySurfaceCreateInfo">
            <summary>
            <para>
            Structure specifying parameters of a newly created display plane
            surface object.
            </para>
            <para>
            [NOTE] .Note ==== Creating a display surface must: not modify the state
            of the displays, planes, or other resources it names. For example, it
            must: not apply the specified mode to be set on the associated display.
            Application of display configuration occurs as a side effect of
            presenting to a display surface. ====
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.DisplaySurfaceCreateInfo.Flags">
            <summary>
            pname:flags is reserved for future use, and must: be zero.
            </summary>
        </member>
        <member name="P:SharpVk.DisplaySurfaceCreateInfo.DisplayMode">
            <summary>
            pname:displayMode is the mode to use when displaying this surface.
            </summary>
        </member>
        <member name="P:SharpVk.DisplaySurfaceCreateInfo.PlaneIndex">
            <summary>
            pname:planeIndex is the plane on which this surface appears.
            </summary>
        </member>
        <member name="P:SharpVk.DisplaySurfaceCreateInfo.PlaneStackIndex">
            <summary>
            pname:planeStackIndex is the z-order of the plane.
            </summary>
        </member>
        <member name="P:SharpVk.DisplaySurfaceCreateInfo.Transform">
            <summary>
            pname:transform is the transform to apply to the images as part of
            the scanout operation.
            </summary>
        </member>
        <member name="P:SharpVk.DisplaySurfaceCreateInfo.GlobalAlpha">
            <summary>
            pname:globalAlpha is the global alpha value. This value is ignored
            if pname:alphaMode is not
            ename:VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR.
            </summary>
        </member>
        <member name="P:SharpVk.DisplaySurfaceCreateInfo.AlphaMode">
            <summary>
            pname:alphaMode is the type of alpha blending to use.
            </summary>
        </member>
        <member name="P:SharpVk.DisplaySurfaceCreateInfo.ImageExtent">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.DrawIndexedIndirectCommand">
            <summary>
            <para>
            Structure specifying a draw indexed indirect command.
            </para>
            <para>
            The members of sname:VkDrawIndexedIndirectCommand have the same meaning
            as the similarly named parameters of flink:vkCmdDrawIndexed.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.DrawIndexedIndirectCommand.#ctor(System.UInt32,System.UInt32,System.UInt32,System.Int32,System.UInt32)">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.DrawIndexedIndirectCommand.IndexCount">
            <summary>
            pname:indexCount is the number of vertices to draw.
            </summary>
        </member>
        <member name="F:SharpVk.DrawIndexedIndirectCommand.InstanceCount">
            <summary>
            pname:instanceCount is the number of instances to draw.
            </summary>
        </member>
        <member name="F:SharpVk.DrawIndexedIndirectCommand.FirstIndex">
            <summary>
            pname:firstIndex is the base index within the index buffer.
            </summary>
        </member>
        <member name="F:SharpVk.DrawIndexedIndirectCommand.VertexOffset">
            <summary>
            pname:vertexOffset is the value added to the vertex index before
            indexing into the vertex buffer.
            </summary>
        </member>
        <member name="F:SharpVk.DrawIndexedIndirectCommand.FirstInstance">
            <summary>
            pname:firstInstance is the instance ID of the first instance to
            draw.
            </summary>
        </member>
        <member name="M:SharpVk.DrawIndexedIndirectCommand.ToString">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.DrawIndirectCommand">
            <summary>
            <para>
            Structure specifying a draw indirect command.
            </para>
            <para>
            The members of sname:VkDrawIndirectCommand have the same meaning as the
            similarly named parameters of flink:vkCmdDraw.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.DrawIndirectCommand.#ctor(System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.DrawIndirectCommand.VertexCount">
            <summary>
            pname:vertexCount is the number of vertices to draw.
            </summary>
        </member>
        <member name="F:SharpVk.DrawIndirectCommand.InstanceCount">
            <summary>
            pname:instanceCount is the number of instances to draw.
            </summary>
        </member>
        <member name="F:SharpVk.DrawIndirectCommand.FirstVertex">
            <summary>
            pname:firstVertex is the index of the first vertex to draw.
            </summary>
        </member>
        <member name="F:SharpVk.DrawIndirectCommand.FirstInstance">
            <summary>
            pname:firstInstance is the instance ID of the first instance to
            draw.
            </summary>
        </member>
        <member name="M:SharpVk.DrawIndirectCommand.ToString">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.DynamicState">
            <summary>
            Indicate which dynamic state is taken from dynamic state commands.
            </summary>
        </member>
        <member name="F:SharpVk.DynamicState.Viewport">
            <summary>
            ename:VK_DYNAMIC_STATE_VIEWPORT indicates that the pname:pViewports
            state in sname:VkPipelineViewportStateCreateInfo will be ignored
            and must: be set dynamically with flink:vkCmdSetViewport before any
            draw commands. The number of viewports used by a pipeline is still
            specified by the pname:viewportCount member of
            sname:VkPipelineViewportStateCreateInfo.
            </summary>
        </member>
        <member name="F:SharpVk.DynamicState.Scissor">
            <summary>
            ename:VK_DYNAMIC_STATE_SCISSOR indicates that the pname:pScissors
            state in sname:VkPipelineViewportStateCreateInfo will be ignored
            and must: be set dynamically with flink:vkCmdSetScissor before any
            draw commands. The number of scissor rectangles used by a pipeline
            is still specified by the pname:scissorCount member of
            sname:VkPipelineViewportStateCreateInfo.
            </summary>
        </member>
        <member name="F:SharpVk.DynamicState.LineWidth">
            <summary>
            ename:VK_DYNAMIC_STATE_LINE_WIDTH indicates that the
            pname:lineWidth state in
            sname:VkPipelineRasterizationStateCreateInfo will be ignored and
            must: be set dynamically with flink:vkCmdSetLineWidth before any
            draw commands that generate line primitives for the rasterizer.
            </summary>
        </member>
        <member name="F:SharpVk.DynamicState.DepthBias">
            <summary>
            ename:VK_DYNAMIC_STATE_DEPTH_BIAS indicates that the
            pname:depthBiasConstantFactor, pname:depthBiasClamp and
            pname:depthBiasSlopeFactor states in
            sname:VkPipelineRasterizationStateCreateInfo will be ignored and
            must: be set dynamically with flink:vkCmdSetDepthBias before any
            draws are performed with pname:depthBiasEnable in
            sname:VkPipelineRasterizationStateCreateInfo set to ename:VK_TRUE.
            </summary>
        </member>
        <member name="F:SharpVk.DynamicState.BlendConstants">
            <summary>
            ename:VK_DYNAMIC_STATE_BLEND_CONSTANTS indicates that the
            pname:blendConstants state in
            sname:VkPipelineColorBlendStateCreateInfo will be ignored and must:
            be set dynamically with flink:vkCmdSetBlendConstants before any
            draws are performed with a pipeline state with
            sname:VkPipelineColorBlendAttachmentState member pname:blendEnable
            set to ename:VK_TRUE and any of the blend functions using a
            constant blend color.
            </summary>
        </member>
        <member name="F:SharpVk.DynamicState.DepthBounds">
            <summary>
            ename:VK_DYNAMIC_STATE_DEPTH_BOUNDS indicates that the
            pname:minDepthBounds and pname:maxDepthBounds states of
            slink:VkPipelineDepthStencilStateCreateInfo will be ignored and
            must: be set dynamically with flink:vkCmdSetDepthBounds before any
            draws are performed with a pipeline state with
            sname:VkPipelineDepthStencilStateCreateInfo member
            pname:depthBoundsTestEnable set to ename:VK_TRUE.
            </summary>
        </member>
        <member name="F:SharpVk.DynamicState.StencilCompareMask">
            <summary>
            ename:VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK indicates that the
            pname:compareMask state in
            sname:VkPipelineDepthStencilStateCreateInfo for both pname:front
            and pname:back will be ignored and must: be set dynamically with
            flink:vkCmdSetStencilCompareMask before any draws are performed
            with a pipeline state with
            sname:VkPipelineDepthStencilStateCreateInfo member
            pname:stencilTestEnable set to ename:VK_TRUE
            </summary>
        </member>
        <member name="F:SharpVk.DynamicState.StencilWriteMask">
            <summary>
            ename:VK_DYNAMIC_STATE_STENCIL_WRITE_MASK indicates that the
            pname:writeMask state in
            sname:VkPipelineDepthStencilStateCreateInfo for both pname:front
            and pname:back will be ignored and must: be set dynamically with
            flink:vkCmdSetStencilWriteMask before any draws are performed with
            a pipeline state with sname:VkPipelineDepthStencilStateCreateInfo
            member pname:stencilTestEnable set to ename:VK_TRUE
            </summary>
        </member>
        <member name="F:SharpVk.DynamicState.StencilReference">
            <summary>
            ename:VK_DYNAMIC_STATE_STENCIL_REFERENCE indicates that the
            pname:reference state in
            sname:VkPipelineDepthStencilStateCreateInfo for both pname:front
            and pname:back will be ignored and must: be set dynamically with
            flink:vkCmdSetStencilReference before any draws are performed with
            a pipeline state with sname:VkPipelineDepthStencilStateCreateInfo
            member pname:stencilTestEnable set to ename:VK_TRUE
            </summary>
        </member>
        <member name="T:SharpVk.Event">
            <summary>
            <para>
            Opaque handle to a event object.
            </para>
            <para>
            Events are a synchronization primitive that can: be used to insert a
            fine-grained dependency between commands submitted to the same queue,
            or between the host and a queue. Events have two states - signaled and
            unsignaled. An application can: signal an event, or unsignal it, on
            either the host or the device. A device can: wait for an event to
            become signaled before executing further operations. No command exists
            to wait for an event to become signaled on the host, but the current
            state of an event can: be queried.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Event.Destroy">
            <summary>
            Destroy an event object.
            </summary>
        </member>
        <member name="M:SharpVk.Event.GetStatus">
            <summary>
            Retrieve the status of an event object.
            </summary>
        </member>
        <member name="M:SharpVk.Event.Set">
            <summary>
            Set an event to signaled state.
            </summary>
        </member>
        <member name="M:SharpVk.Event.Reset">
            <summary>
            Reset an event to non-signaled state.
            </summary>
        </member>
        <member name="P:SharpVk.Event.RawHandle">
            <summary>
            The interop handle for this Event.
            </summary>
        </member>
        <member name="M:SharpVk.Event.Dispose">
            <summary>
            Releases the unmanaged resources associated with this instance and
            destroys the underlying Vulkan handle.
            </summary>
        </member>
        <member name="T:SharpVk.EventCreateFlags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.EventCreateFlags.None">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.EventCreateInfo">
            <summary>
            Structure specifying parameters of a newly created event.
            </summary>
        </member>
        <member name="P:SharpVk.EventCreateInfo.Flags">
            <summary>
            pname:flags is reserved for future use.
            </summary>
        </member>
        <member name="T:SharpVk.SharpVkException">
            <summary>
            The base type for exceptions thrown by the SharpVK library.
            </summary>
        </member>
        <member name="M:SharpVk.SharpVkException.#ctor(System.String)">
            <summary>
            Creates a new instance of the <see
            cref="T:SharpVk.SharpVkException"/> class .
            </summary>
            <param name="message">
            The message that describes the error.
            </param>
        </member>
        <member name="M:SharpVk.SharpVkException.IsError(SharpVk.Result)">
            <summary>
            Returns a value indicating whether the given Vulkan result code
            represents an error.
            </summary>
        </member>
        <member name="M:SharpVk.SharpVkException.Create(SharpVk.Result)">
            <summary>
            Creates and returns a new, specifically-typed exception that
            represents the given result code.
            </summary>
        </member>
        <member name="P:SharpVk.SharpVkException.ResultCode">
            <summary>
            The Vulkan result code represented by this exception.
            </summary>
        </member>
        <member name="T:SharpVk.UnknownSharpVkException">
            <summary>
            An exception representing a result code not recognised by the SharpVk
            library.
            </summary>
        </member>
        <member name="P:SharpVk.UnknownSharpVkException.ResultCode">
            <summary>
            The Vulkan result code represented by this exception.
            </summary>
        </member>
        <member name="T:SharpVk.OutOfHostMemoryException">
            <summary>
            A host memory allocation has failed
            </summary>
        </member>
        <member name="P:SharpVk.OutOfHostMemoryException.ResultCode">
            <summary>
            The Vulkan result code represented by this exception.
            </summary>
        </member>
        <member name="T:SharpVk.OutOfDeviceMemoryException">
            <summary>
            A device memory allocation has failed
            </summary>
        </member>
        <member name="P:SharpVk.OutOfDeviceMemoryException.ResultCode">
            <summary>
            The Vulkan result code represented by this exception.
            </summary>
        </member>
        <member name="T:SharpVk.InitializationFailedException">
            <summary>
            Initialization of a object has failed
            </summary>
        </member>
        <member name="P:SharpVk.InitializationFailedException.ResultCode">
            <summary>
            The Vulkan result code represented by this exception.
            </summary>
        </member>
        <member name="T:SharpVk.DeviceLostException">
            <summary>
            The logical device has been lost. See
            &lt;&lt;devsandqueues-lost-device&gt;&gt;
            </summary>
        </member>
        <member name="P:SharpVk.DeviceLostException.ResultCode">
            <summary>
            The Vulkan result code represented by this exception.
            </summary>
        </member>
        <member name="T:SharpVk.MemoryMapFailedException">
            <summary>
            Mapping of a memory object has failed
            </summary>
        </member>
        <member name="P:SharpVk.MemoryMapFailedException.ResultCode">
            <summary>
            The Vulkan result code represented by this exception.
            </summary>
        </member>
        <member name="T:SharpVk.LayerNotPresentException">
            <summary>
            Layer specified does not exist
            </summary>
        </member>
        <member name="P:SharpVk.LayerNotPresentException.ResultCode">
            <summary>
            The Vulkan result code represented by this exception.
            </summary>
        </member>
        <member name="T:SharpVk.ExtensionNotPresentException">
            <summary>
            Extension specified does not exist
            </summary>
        </member>
        <member name="P:SharpVk.ExtensionNotPresentException.ResultCode">
            <summary>
            The Vulkan result code represented by this exception.
            </summary>
        </member>
        <member name="T:SharpVk.FeatureNotPresentException">
            <summary>
            Requested feature is not available on this device
            </summary>
        </member>
        <member name="P:SharpVk.FeatureNotPresentException.ResultCode">
            <summary>
            The Vulkan result code represented by this exception.
            </summary>
        </member>
        <member name="T:SharpVk.IncompatibleDriverException">
            <summary>
            Unable to find a Vulkan driver
            </summary>
        </member>
        <member name="P:SharpVk.IncompatibleDriverException.ResultCode">
            <summary>
            The Vulkan result code represented by this exception.
            </summary>
        </member>
        <member name="T:SharpVk.TooManyObjectsException">
            <summary>
            Too many objects of the type have already been created
            </summary>
        </member>
        <member name="P:SharpVk.TooManyObjectsException.ResultCode">
            <summary>
            The Vulkan result code represented by this exception.
            </summary>
        </member>
        <member name="T:SharpVk.FormatNotSupportedException">
            <summary>
            Requested format is not supported on this device
            </summary>
        </member>
        <member name="P:SharpVk.FormatNotSupportedException.ResultCode">
            <summary>
            The Vulkan result code represented by this exception.
            </summary>
        </member>
        <member name="T:SharpVk.FragmentedPoolException">
            <summary>
            A requested pool allocation has failed due to fragmentation of the
            pool's memory
            </summary>
        </member>
        <member name="P:SharpVk.FragmentedPoolException.ResultCode">
            <summary>
            The Vulkan result code represented by this exception.
            </summary>
        </member>
        <member name="T:SharpVk.SurfaceLostException">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.SurfaceLostException.ResultCode">
            <summary>
            The Vulkan result code represented by this exception.
            </summary>
        </member>
        <member name="T:SharpVk.NativeWindowInUseException">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.NativeWindowInUseException.ResultCode">
            <summary>
            The Vulkan result code represented by this exception.
            </summary>
        </member>
        <member name="T:SharpVk.OutOfDateException">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.OutOfDateException.ResultCode">
            <summary>
            The Vulkan result code represented by this exception.
            </summary>
        </member>
        <member name="T:SharpVk.IncompatibleDisplayException">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.IncompatibleDisplayException.ResultCode">
            <summary>
            The Vulkan result code represented by this exception.
            </summary>
        </member>
        <member name="T:SharpVk.ValidationFailedException">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.ValidationFailedException.ResultCode">
            <summary>
            The Vulkan result code represented by this exception.
            </summary>
        </member>
        <member name="T:SharpVk.InvalidShaderException">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.InvalidShaderException.ResultCode">
            <summary>
            The Vulkan result code represented by this exception.
            </summary>
        </member>
        <member name="T:SharpVk.OutOfPoolMemoryException">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.OutOfPoolMemoryException.ResultCode">
            <summary>
            The Vulkan result code represented by this exception.
            </summary>
        </member>
        <member name="T:SharpVk.ExportMemoryAllocateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.ExportMemoryAllocateInfo.HandleTypes">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.ExportMemoryWin32HandleInfo">
            <summary>
            <para>
            Specify security attributes and access rights for Win32 memory handles.
            </para>
            <para>
            When slink:VkExportMemoryAllocateInfoNV::pname:handleTypes includes
            ename:VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV, add a
            sname:VkExportMemoryWin32HandleInfoNV to the pname:pNext chain of the
            slink:VkExportMemoryAllocateInfoNV structure to specify security
            attributes and access rights for the memory object's external handle.
            </para>
            <para>
            If this structure is not present, or if pname:pAttributes is set to
            `NULL`, default security descriptor values will be used, and child
            processes created by the application will not inherit the handle, as
            described in the MSDN documentation for "`Synchronization Object
            Security and Access Rights`"[1]. Further, if the structure is not
            present, the access rights will be
            </para>
            <para>
            code:DXGI_SHARED_RESOURCE_READ | code:DXGI_SHARED_RESOURCE_WRITE
            </para>
            <para>
            [1]
            https://msdn.microsoft.com/en-us/library/windows/desktop/ms686670.aspx
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.ExportMemoryWin32HandleInfo.Attributes">
            <summary>
            pname:pAttributes is a pointer to a Windows
            code:SECURITY_ATTRIBUTES structure specifying security attributes
            of the handle.
            </summary>
        </member>
        <member name="P:SharpVk.ExportMemoryWin32HandleInfo.DwAccess">
            <summary>
            pname:dwAccess is a code:DWORD specifying access rights of the
            handle.
            </summary>
        </member>
        <member name="T:SharpVk.ExtensionProperties">
            <summary>
            Structure specifying a extension properties.
            </summary>
        </member>
        <member name="P:SharpVk.ExtensionProperties.ExtensionName">
            <summary>
            pname:extensionName is a null-terminated string specifying the name
            of the extension.
            </summary>
        </member>
        <member name="P:SharpVk.ExtensionProperties.SpecVersion">
            <summary>
            pname:specVersion is the version of this extension. It is an
            integer, incremented with backward compatible changes.
            </summary>
        </member>
        <member name="T:SharpVk.Extent2D">
            <summary>
            Structure specifying a two-dimensional extent.
            </summary>
        </member>
        <member name="M:SharpVk.Extent2D.#ctor(System.UInt32,System.UInt32)">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Extent2D.Width">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Extent2D.Height">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Extent2D.ToString">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Extent3D">
            <summary>
            Structure specifying a three-dimensional extent.
            </summary>
        </member>
        <member name="M:SharpVk.Extent3D.#ctor(System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Extent3D.Width">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Extent3D.Height">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Extent3D.Depth">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Extent3D.ToString">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.ExternalImageFormatProperties">
            <summary>
            Structure specifying external image format properties.
            </summary>
        </member>
        <member name="M:SharpVk.ExternalImageFormatProperties.#ctor(SharpVk.ImageFormatProperties,SharpVk.ExternalMemoryFeatureFlags,SharpVk.ExternalMemoryHandleTypeFlags,SharpVk.ExternalMemoryHandleTypeFlags)">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.ExternalImageFormatProperties.ImageFormatProperties">
            <summary>
            pname:imageFormatProperties will be filled in as when calling
            flink:vkGetPhysicalDeviceImageFormatProperties, but the values
            returned may: vary depending on the external handle type requested.
            </summary>
        </member>
        <member name="F:SharpVk.ExternalImageFormatProperties.ExternalMemoryFeatures">
            <summary>
            pname:externalMemoryFeatures is a bitmask of
            elink:VkExternalMemoryFeatureFlagBitsNV indicating properties of
            the external memory handle type
            (flink:vkGetPhysicalDeviceExternalImageFormatPropertiesNV::pname:externalHandleType) being
            queried, or 0 if the external memory handle type is 0.
            </summary>
        </member>
        <member name="F:SharpVk.ExternalImageFormatProperties.ExportFromImportedHandleTypes">
            <summary>
            pname:exportFromImportedHandleTypes is a bitmask of
            elink:VkExternalMemoryHandleTypeFlagBitsNV containing a bit set for
            every external handle type that may: be used to create memory from
            which the handles of the type specified in
            flink:vkGetPhysicalDeviceExternalImageFormatPropertiesNV::pname:externalHandleType can:
            be exported, or 0 if the external memory handle type is 0.
            </summary>
        </member>
        <member name="F:SharpVk.ExternalImageFormatProperties.CompatibleHandleTypes">
            <summary>
            pname:compatibleHandleTypes is a bitmask of
            elink:VkExternalMemoryHandleTypeFlagBitsNV containing a bit set for
            every external handle type that may: be specified simultaneously
            with the handle type specified by
            flink:vkGetPhysicalDeviceExternalImageFormatPropertiesNV::pname:externalHandleType when
            calling flink:vkAllocateMemory, or 0 if the external memory handle
            type is 0. pname:compatibleHandleTypes will always contain
            flink:vkGetPhysicalDeviceExternalImageFormatPropertiesNV::pname:externalHandleType
            </summary>
        </member>
        <member name="M:SharpVk.ExternalImageFormatProperties.ToString">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.ExternalMemoryFeatureFlags">
            <summary>
            Bitmask specifying external memory features.
            </summary>
        </member>
        <member name="F:SharpVk.ExternalMemoryFeatureFlags.None">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.ExternalMemoryFeatureFlags.DedicatedOnly">
            <summary>
            ename:VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV: External
            memory of the specified type must: be created as a dedicated
            allocation when used in the manner specified.
            </summary>
        </member>
        <member name="F:SharpVk.ExternalMemoryFeatureFlags.Exportable">
            <summary>
            ename:VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV: The
            implementation supports exporting handles of the specified type.
            </summary>
        </member>
        <member name="F:SharpVk.ExternalMemoryFeatureFlags.Importable">
            <summary>
            ename:VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV: The
            implementation supports importing handles of the specified type.
            </summary>
        </member>
        <member name="T:SharpVk.ExternalMemoryHandleTypeFlags">
            <summary>
            <para>
            Bitmask specifying memory handle types.
            </para>
            <para>
            If pname:handleType is 0, this structure is ignored by consumers of the
            slink:VkMemoryAllocateInfo structure it is chained from.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ExternalMemoryHandleTypeFlags.None">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.ExternalMemoryHandleTypeFlags.OpaqueWin32">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.ExternalMemoryHandleTypeFlags.OpaqueWin32Kmt">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.ExternalMemoryHandleTypeFlags.D3D11Image">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.ExternalMemoryHandleTypeFlags.D3D11ImageKmt">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.ExternalMemoryImageCreateInfo">
            <summary>
            <para>
            Specify that an image may be backed by external memory.
            </para>
            <para>
            If the pname:pNext list includes a
            sname:VkExternalMemoryImageCreateInfoNV structure, then that structure
            defines a set of external memory handle types that may: be used as
            backing store for the image.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.ExternalMemoryImageCreateInfo.HandleTypes">
            <summary>
            pname:handleTypes is a bitmask of
            elink:VkExternalMemoryHandleTypeFlagBitsNV specifying one or more
            external memory handle types. The types must: all be compatible
            with each other and the other image creation parameters, as
            reported by
            flink:vkGetPhysicalDeviceExternalImageFormatPropertiesNV.
            </summary>
        </member>
        <member name="T:SharpVk.Fence">
            <summary>
            <para>
            Opaque handle to a fence object.
            </para>
            <para>
            Fences are a synchronization primitive that can: be used to insert a
            dependency from a queue to the host. Fences have two states - signaled
            and unsignaled. A fence can: be signaled as part of the execution of a
            &lt;&lt;devsandqueues-submission, queue submission&gt;&gt; command.
            Fences can: be unsignaled on the host with flink:vkResetFences. Fences
            can: be waited on by the host with the flink:vkWaitForFences command,
            and the current state can: be queried with flink:vkGetFenceStatus.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Fence.Destroy">
            <summary>
            Destroy a fence object.
            </summary>
        </member>
        <member name="M:SharpVk.Fence.GetStatus">
            <summary>
            Return the status of a fence.
            </summary>
        </member>
        <member name="P:SharpVk.Fence.RawHandle">
            <summary>
            The interop handle for this Fence.
            </summary>
        </member>
        <member name="M:SharpVk.Fence.Dispose">
            <summary>
            Releases the unmanaged resources associated with this instance and
            destroys the underlying Vulkan handle.
            </summary>
        </member>
        <member name="T:SharpVk.FenceCreateFlags">
            <summary>
            Bitmask specifying initial state and behavior of a fence.
            </summary>
        </member>
        <member name="F:SharpVk.FenceCreateFlags.None">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.FenceCreateFlags.Signaled">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.FenceCreateInfo">
            <summary>
            Structure specifying parameters of a newly created fence.
            </summary>
        </member>
        <member name="P:SharpVk.FenceCreateInfo.Flags">
            <summary>
            pname:flags defines the initial state and behavior of the fence.
            Bits which can: be set include: + --
            </summary>
        </member>
        <member name="T:SharpVk.Filter">
            <summary>
            Specify filters used for texture lookups.
            </summary>
        </member>
        <member name="F:SharpVk.Filter.Nearest">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Filter.Linear">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Filter.Cubic">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Format">
            <summary>
            Available image formats.
            </summary>
        </member>
        <member name="F:SharpVk.Format.Undefined">
            <summary>
            ename:VK_FORMAT_UNDEFINED:: The format is not specified.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R4G4UNormPack8">
            <summary>
            ename:VK_FORMAT_R4G4_UNORM_PACK8:: A two-component, 8-bit packed
            unsigned normalized format that has a 4-bit R component in bits
            4..7, and a 4-bit G component in bits 0..3.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R4G4B4A4UNormPack16">
            <summary>
            ename:VK_FORMAT_R4G4B4A4_UNORM_PACK16:: A four-component, 16-bit
            packed unsigned normalized format that has a 4-bit R component in
            bits 12..15, a 4-bit G component in bits 8..11, a 4-bit B component
            in bits 4..7, and a 4-bit A component in bits 0..3.
            </summary>
        </member>
        <member name="F:SharpVk.Format.B4G4R4A4UNormPack16">
            <summary>
            ename:VK_FORMAT_B4G4R4A4_UNORM_PACK16:: A four-component, 16-bit
            packed unsigned normalized format that has a 4-bit B component in
            bits 12..15, a 4-bit G component in bits 8..11, a 4-bit R component
            in bits 4..7, and a 4-bit A component in bits 0..3.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R5G6B5UNormPack16">
            <summary>
            ename:VK_FORMAT_R5G6B5_UNORM_PACK16:: A three-component, 16-bit
            packed unsigned normalized format that has a 5-bit R component in
            bits 11..15, a 6-bit G component in bits 5..10, and a 5-bit B
            component in bits 0..4.
            </summary>
        </member>
        <member name="F:SharpVk.Format.B5G6R5UNormPack16">
            <summary>
            ename:VK_FORMAT_B5G6R5_UNORM_PACK16:: A three-component, 16-bit
            packed unsigned normalized format that has a 5-bit B component in
            bits 11..15, a 6-bit G component in bits 5..10, and a 5-bit R
            component in bits 0..4.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R5G5B5A1UNormPack16">
            <summary>
            ename:VK_FORMAT_R5G5B5A1_UNORM_PACK16:: A four-component, 16-bit
            packed unsigned normalized format that has a 5-bit R component in
            bits 11..15, a 5-bit G component in bits 6..10, a 5-bit B component
            in bits 1..5, and a 1-bit A component in bit 0.
            </summary>
        </member>
        <member name="F:SharpVk.Format.B5G5R5A1UNormPack16">
            <summary>
            ename:VK_FORMAT_B5G5R5A1_UNORM_PACK16:: A four-component, 16-bit
            packed unsigned normalized format that has a 5-bit B component in
            bits 11..15, a 5-bit G component in bits 6..10, a 5-bit R component
            in bits 1..5, and a 1-bit A component in bit 0.
            </summary>
        </member>
        <member name="F:SharpVk.Format.A1R5G5B5UNormPack16">
            <summary>
            ename:VK_FORMAT_A1R5G5B5_UNORM_PACK16:: A four-component, 16-bit
            packed unsigned normalized format that has a 1-bit A component in
            bit 15, a 5-bit R component in bits 10..14, a 5-bit G component in
            bits 5..9, and a 5-bit B component in bits 0..4.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R8UNorm">
            <summary>
            ename:VK_FORMAT_R8_UNORM:: A one-component, 8-bit unsigned
            normalized format that has a single 8-bit R component.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R8SNorm">
            <summary>
            ename:VK_FORMAT_R8_SNORM:: A one-component, 8-bit signed normalized
            format that has a single 8-bit R component.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R8UScaled">
            <summary>
            ename:VK_FORMAT_R8_USCALED:: A one-component, 8-bit unsigned scaled
            integer format that has a single 8-bit R component.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R8SScaled">
            <summary>
            ename:VK_FORMAT_R8_SSCALED:: A one-component, 8-bit signed scaled
            integer format that has a single 8-bit R component.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R8UInt">
            <summary>
            ename:VK_FORMAT_R8_UINT:: A one-component, 8-bit unsigned integer
            format that has a single 8-bit R component.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R8SInt">
            <summary>
            ename:VK_FORMAT_R8_SINT:: A one-component, 8-bit signed integer
            format that has a single 8-bit R component.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R8Srgb">
            <summary>
            ename:VK_FORMAT_R8_SRGB:: A one-component, 8-bit unsigned
            normalized format that has a single 8-bit R component stored with
            sRGB nonlinear encoding.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R8G8UNorm">
            <summary>
            ename:VK_FORMAT_R8G8_UNORM:: A two-component, 16-bit unsigned
            normalized format that has an 8-bit R component in byte 0, and an
            8-bit G component in byte 1.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R8G8SNorm">
            <summary>
            ename:VK_FORMAT_R8G8_SNORM:: A two-component, 16-bit signed
            normalized format that has an 8-bit R component in byte 0, and an
            8-bit G component in byte 1.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R8G8UScaled">
            <summary>
            ename:VK_FORMAT_R8G8_USCALED:: A two-component, 16-bit unsigned
            scaled integer format that has an 8-bit R component in byte 0, and
            an 8-bit G component in byte 1.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R8G8SScaled">
            <summary>
            ename:VK_FORMAT_R8G8_SSCALED:: A two-component, 16-bit signed
            scaled integer format that has an 8-bit R component in byte 0, and
            an 8-bit G component in byte 1.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R8G8UInt">
            <summary>
            ename:VK_FORMAT_R8G8_UINT:: A two-component, 16-bit unsigned
            integer format that has an 8-bit R component in byte 0, and an
            8-bit G component in byte 1.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R8G8SInt">
            <summary>
            ename:VK_FORMAT_R8G8_SINT:: A two-component, 16-bit signed integer
            format that has an 8-bit R component in byte 0, and an 8-bit G
            component in byte 1.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R8G8Srgb">
            <summary>
            ename:VK_FORMAT_R8G8_SRGB:: A two-component, 16-bit unsigned
            normalized format that has an 8-bit R component stored with sRGB
            nonlinear encoding in byte 0, and an 8-bit G component stored with
            sRGB nonlinear encoding in byte 1.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R8G8B8UNorm">
            <summary>
            ename:VK_FORMAT_R8G8B8_UNORM:: A three-component, 24-bit unsigned
            normalized format that has an 8-bit R component in byte 0, an 8-bit
            G component in byte 1, and an 8-bit B component in byte 2.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R8G8B8SNorm">
            <summary>
            ename:VK_FORMAT_R8G8B8_SNORM:: A three-component, 24-bit signed
            normalized format that has an 8-bit R component in byte 0, an 8-bit
            G component in byte 1, and an 8-bit B component in byte 2.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R8G8B8UScaled">
            <summary>
            ename:VK_FORMAT_R8G8B8_USCALED:: A three-component, 24-bit unsigned
            scaled format that has an 8-bit R component in byte 0, an 8-bit G
            component in byte 1, and an 8-bit B component in byte 2.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R8G8B8SScaled">
            <summary>
            ename:VK_FORMAT_R8G8B8_SSCALED:: A three-component, 24-bit signed
            scaled format that has an 8-bit R component in byte 0, an 8-bit G
            component in byte 1, and an 8-bit B component in byte 2.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R8G8B8UInt">
            <summary>
            ename:VK_FORMAT_R8G8B8_UINT:: A three-component, 24-bit unsigned
            integer format that has an 8-bit R component in byte 0, an 8-bit G
            component in byte 1, and an 8-bit B component in byte 2.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R8G8B8SInt">
            <summary>
            ename:VK_FORMAT_R8G8B8_SINT:: A three-component, 24-bit signed
            integer format that has an 8-bit R component in byte 0, an 8-bit G
            component in byte 1, and an 8-bit B component in byte 2.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R8G8B8Srgb">
            <summary>
            ename:VK_FORMAT_R8G8B8_SRGB:: A three-component, 24-bit unsigned
            normalized format that has an 8-bit R component stored with sRGB
            nonlinear encoding in byte 0, an 8-bit G component stored with sRGB
            nonlinear encoding in byte 1, and an 8-bit B component stored with
            sRGB nonlinear encoding in byte 2.
            </summary>
        </member>
        <member name="F:SharpVk.Format.B8G8R8UNorm">
            <summary>
            ename:VK_FORMAT_B8G8R8_UNORM:: A three-component, 24-bit unsigned
            normalized format that has an 8-bit B component in byte 0, an 8-bit
            G component in byte 1, and an 8-bit R component in byte 2.
            </summary>
        </member>
        <member name="F:SharpVk.Format.B8G8R8SNorm">
            <summary>
            ename:VK_FORMAT_B8G8R8_SNORM:: A three-component, 24-bit signed
            normalized format that has an 8-bit B component in byte 0, an 8-bit
            G component in byte 1, and an 8-bit R component in byte 2.
            </summary>
        </member>
        <member name="F:SharpVk.Format.B8G8R8UScaled">
            <summary>
            ename:VK_FORMAT_B8G8R8_USCALED:: A three-component, 24-bit unsigned
            scaled format that has an 8-bit B component in byte 0, an 8-bit G
            component in byte 1, and an 8-bit R component in byte 2.
            </summary>
        </member>
        <member name="F:SharpVk.Format.B8G8R8SScaled">
            <summary>
            ename:VK_FORMAT_B8G8R8_SSCALED:: A three-component, 24-bit signed
            scaled format that has an 8-bit B component in byte 0, an 8-bit G
            component in byte 1, and an 8-bit R component in byte 2.
            </summary>
        </member>
        <member name="F:SharpVk.Format.B8G8R8UInt">
            <summary>
            ename:VK_FORMAT_B8G8R8_UINT:: A three-component, 24-bit unsigned
            integer format that has an 8-bit B component in byte 0, an 8-bit G
            component in byte 1, and an 8-bit R component in byte 2.
            </summary>
        </member>
        <member name="F:SharpVk.Format.B8G8R8SInt">
            <summary>
            ename:VK_FORMAT_B8G8R8_SINT:: A three-component, 24-bit signed
            integer format that has an 8-bit B component in byte 0, an 8-bit G
            component in byte 1, and an 8-bit R component in byte 2.
            </summary>
        </member>
        <member name="F:SharpVk.Format.B8G8R8Srgb">
            <summary>
            ename:VK_FORMAT_B8G8R8_SRGB:: A three-component, 24-bit unsigned
            normalized format that has an 8-bit B component stored with sRGB
            nonlinear encoding in byte 0, an 8-bit G component stored with sRGB
            nonlinear encoding in byte 1, and an 8-bit R component stored with
            sRGB nonlinear encoding in byte 2.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R8G8B8A8UNorm">
            <summary>
            ename:VK_FORMAT_R8G8B8A8_UNORM:: A four-component, 32-bit unsigned
            normalized format that has an 8-bit R component in byte 0, an 8-bit
            G component in byte 1, an 8-bit B component in byte 2, and an 8-bit
            A component in byte 3.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R8G8B8A8SNorm">
            <summary>
            ename:VK_FORMAT_R8G8B8A8_SNORM:: A four-component, 32-bit signed
            normalized format that has an 8-bit R component in byte 0, an 8-bit
            G component in byte 1, an 8-bit B component in byte 2, and an 8-bit
            A component in byte 3.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R8G8B8A8UScaled">
            <summary>
            ename:VK_FORMAT_R8G8B8A8_USCALED:: A four-component, 32-bit
            unsigned scaled format that has an 8-bit R component in byte 0, an
            8-bit G component in byte 1, an 8-bit B component in byte 2, and an
            8-bit A component in byte 3.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R8G8B8A8SScaled">
            <summary>
            ename:VK_FORMAT_R8G8B8A8_SSCALED:: A four-component, 32-bit signed
            scaled format that has an 8-bit R component in byte 0, an 8-bit G
            component in byte 1, an 8-bit B component in byte 2, and an 8-bit A
            component in byte 3.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R8G8B8A8UInt">
            <summary>
            ename:VK_FORMAT_R8G8B8A8_UINT:: A four-component, 32-bit unsigned
            integer format that has an 8-bit R component in byte 0, an 8-bit G
            component in byte 1, an 8-bit B component in byte 2, and an 8-bit A
            component in byte 3.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R8G8B8A8SInt">
            <summary>
            ename:VK_FORMAT_R8G8B8A8_SINT:: A four-component, 32-bit signed
            integer format that has an 8-bit R component in byte 0, an 8-bit G
            component in byte 1, an 8-bit B component in byte 2, and an 8-bit A
            component in byte 3.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R8G8B8A8Srgb">
            <summary>
            ename:VK_FORMAT_R8G8B8A8_SRGB:: A four-component, 32-bit unsigned
            normalized format that has an 8-bit R component stored with sRGB
            nonlinear encoding in byte 0, an 8-bit G component stored with sRGB
            nonlinear encoding in byte 1, an 8-bit B component stored with sRGB
            nonlinear encoding in byte 2, and an 8-bit A component in byte 3.
            </summary>
        </member>
        <member name="F:SharpVk.Format.B8G8R8A8UNorm">
            <summary>
            ename:VK_FORMAT_B8G8R8A8_UNORM:: A four-component, 32-bit unsigned
            normalized format that has an 8-bit B component in byte 0, an 8-bit
            G component in byte 1, an 8-bit R component in byte 2, and an 8-bit
            A component in byte 3.
            </summary>
        </member>
        <member name="F:SharpVk.Format.B8G8R8A8SNorm">
            <summary>
            ename:VK_FORMAT_B8G8R8A8_SNORM:: A four-component, 32-bit signed
            normalized format that has an 8-bit B component in byte 0, an 8-bit
            G component in byte 1, an 8-bit R component in byte 2, and an 8-bit
            A component in byte 3.
            </summary>
        </member>
        <member name="F:SharpVk.Format.B8G8R8A8UScaled">
            <summary>
            ename:VK_FORMAT_B8G8R8A8_USCALED:: A four-component, 32-bit
            unsigned scaled format that has an 8-bit B component in byte 0, an
            8-bit G component in byte 1, an 8-bit R component in byte 2, and an
            8-bit A component in byte 3.
            </summary>
        </member>
        <member name="F:SharpVk.Format.B8G8R8A8SScaled">
            <summary>
            ename:VK_FORMAT_B8G8R8A8_SSCALED:: A four-component, 32-bit signed
            scaled format that has an 8-bit B component in byte 0, an 8-bit G
            component in byte 1, an 8-bit R component in byte 2, and an 8-bit A
            component in byte 3.
            </summary>
        </member>
        <member name="F:SharpVk.Format.B8G8R8A8UInt">
            <summary>
            ename:VK_FORMAT_B8G8R8A8_UINT:: A four-component, 32-bit unsigned
            integer format that has an 8-bit B component in byte 0, an 8-bit G
            component in byte 1, an 8-bit R component in byte 2, and an 8-bit A
            component in byte 3.
            </summary>
        </member>
        <member name="F:SharpVk.Format.B8G8R8A8SInt">
            <summary>
            ename:VK_FORMAT_B8G8R8A8_SINT:: A four-component, 32-bit signed
            integer format that has an 8-bit B component in byte 0, an 8-bit G
            component in byte 1, an 8-bit R component in byte 2, and an 8-bit A
            component in byte 3.
            </summary>
        </member>
        <member name="F:SharpVk.Format.B8G8R8A8Srgb">
            <summary>
            ename:VK_FORMAT_B8G8R8A8_SRGB:: A four-component, 32-bit unsigned
            normalized format that has an 8-bit B component stored with sRGB
            nonlinear encoding in byte 0, an 8-bit G component stored with sRGB
            nonlinear encoding in byte 1, an 8-bit R component stored with sRGB
            nonlinear encoding in byte 2, and an 8-bit A component in byte 3.
            </summary>
        </member>
        <member name="F:SharpVk.Format.A8B8G8R8UNormPack32">
            <summary>
            ename:VK_FORMAT_A8B8G8R8_UNORM_PACK32:: A four-component, 32-bit
            packed unsigned normalized format that has an 8-bit A component in
            bits 24..31, an 8-bit B component in bits 16..23, an 8-bit G
            component in bits 8..15, and an 8-bit R component in bits 0..7.
            </summary>
        </member>
        <member name="F:SharpVk.Format.A8B8G8R8SNormPack32">
            <summary>
            ename:VK_FORMAT_A8B8G8R8_SNORM_PACK32:: A four-component, 32-bit
            packed signed normalized format that has an 8-bit A component in
            bits 24..31, an 8-bit B component in bits 16..23, an 8-bit G
            component in bits 8..15, and an 8-bit R component in bits 0..7.
            </summary>
        </member>
        <member name="F:SharpVk.Format.A8B8G8R8UScaledPack32">
            <summary>
            ename:VK_FORMAT_A8B8G8R8_USCALED_PACK32:: A four-component, 32-bit
            packed unsigned scaled integer format that has an 8-bit A component
            in bits 24..31, an 8-bit B component in bits 16..23, an 8-bit G
            component in bits 8..15, and an 8-bit R component in bits 0..7.
            </summary>
        </member>
        <member name="F:SharpVk.Format.A8B8G8R8SScaledPack32">
            <summary>
            ename:VK_FORMAT_A8B8G8R8_SSCALED_PACK32:: A four-component, 32-bit
            packed signed scaled integer format that has an 8-bit A component
            in bits 24..31, an 8-bit B component in bits 16..23, an 8-bit G
            component in bits 8..15, and an 8-bit R component in bits 0..7.
            </summary>
        </member>
        <member name="F:SharpVk.Format.A8B8G8R8UIntPack32">
            <summary>
            ename:VK_FORMAT_A8B8G8R8_UINT_PACK32:: A four-component, 32-bit
            packed unsigned integer format that has an 8-bit A component in
            bits 24..31, an 8-bit B component in bits 16..23, an 8-bit G
            component in bits 8..15, and an 8-bit R component in bits 0..7.
            </summary>
        </member>
        <member name="F:SharpVk.Format.A8B8G8R8SIntPack32">
            <summary>
            ename:VK_FORMAT_A8B8G8R8_SINT_PACK32:: A four-component, 32-bit
            packed signed integer format that has an 8-bit A component in bits
            24..31, an 8-bit B component in bits 16..23, an 8-bit G component
            in bits 8..15, and an 8-bit R component in bits 0..7.
            </summary>
        </member>
        <member name="F:SharpVk.Format.A8B8G8R8SrgbPack32">
            <summary>
            ename:VK_FORMAT_A8B8G8R8_SRGB_PACK32:: A four-component, 32-bit
            packed unsigned normalized format that has an 8-bit A component in
            bits 24..31, an 8-bit B component stored with sRGB nonlinear
            encoding in bits 16..23, an 8-bit G component stored with sRGB
            nonlinear encoding in bits 8..15, and an 8-bit R component stored
            with sRGB nonlinear encoding in bits 0..7.
            </summary>
        </member>
        <member name="F:SharpVk.Format.A2R10G10B10UNormPack32">
            <summary>
            ename:VK_FORMAT_A2R10G10B10_UNORM_PACK32:: A four-component, 32-bit
            packed unsigned normalized format that has a 2-bit A component in
            bits 30..31, a 10-bit R component in bits 20..29, a 10-bit G
            component in bits 10..19, and a 10-bit B component in bits 0..9.
            </summary>
        </member>
        <member name="F:SharpVk.Format.A2R10G10B10SNormPack32">
            <summary>
            ename:VK_FORMAT_A2R10G10B10_SNORM_PACK32:: A four-component, 32-bit
            packed signed normalized format that has a 2-bit A component in
            bits 30..31, a 10-bit R component in bits 20..29, a 10-bit G
            component in bits 10..19, and a 10-bit B component in bits 0..9.
            </summary>
        </member>
        <member name="F:SharpVk.Format.A2R10G10B10UScaledPack32">
            <summary>
            ename:VK_FORMAT_A2R10G10B10_USCALED_PACK32:: A four-component,
            32-bit packed unsigned scaled integer format that has a 2-bit A
            component in bits 30..31, a 10-bit R component in bits 20..29, a
            10-bit G component in bits 10..19, and a 10-bit B component in bits
            0..9.
            </summary>
        </member>
        <member name="F:SharpVk.Format.A2R10G10B10SScaledPack32">
            <summary>
            ename:VK_FORMAT_A2R10G10B10_SSCALED_PACK32:: A four-component,
            32-bit packed signed scaled integer format that has a 2-bit A
            component in bits 30..31, a 10-bit R component in bits 20..29, a
            10-bit G component in bits 10..19, and a 10-bit B component in bits
            0..9.
            </summary>
        </member>
        <member name="F:SharpVk.Format.A2R10G10B10UIntPack32">
            <summary>
            ename:VK_FORMAT_A2R10G10B10_UINT_PACK32:: A four-component, 32-bit
            packed unsigned integer format that has a 2-bit A component in bits
            30..31, a 10-bit R component in bits 20..29, a 10-bit G component
            in bits 10..19, and a 10-bit B component in bits 0..9.
            </summary>
        </member>
        <member name="F:SharpVk.Format.A2R10G10B10SIntPack32">
            <summary>
            ename:VK_FORMAT_A2R10G10B10_SINT_PACK32:: A four-component, 32-bit
            packed signed integer format that has a 2-bit A component in bits
            30..31, a 10-bit R component in bits 20..29, a 10-bit G component
            in bits 10..19, and a 10-bit B component in bits 0..9.
            </summary>
        </member>
        <member name="F:SharpVk.Format.A2B10G10R10UNormPack32">
            <summary>
            ename:VK_FORMAT_A2B10G10R10_UNORM_PACK32:: A four-component, 32-bit
            packed unsigned normalized format that has a 2-bit A component in
            bits 30..31, a 10-bit B component in bits 20..29, a 10-bit G
            component in bits 10..19, and a 10-bit R component in bits 0..9.
            </summary>
        </member>
        <member name="F:SharpVk.Format.A2B10G10R10SNormPack32">
            <summary>
            ename:VK_FORMAT_A2B10G10R10_SNORM_PACK32:: A four-component, 32-bit
            packed signed normalized format that has a 2-bit A component in
            bits 30..31, a 10-bit B component in bits 20..29, a 10-bit G
            component in bits 10..19, and a 10-bit R component in bits 0..9.
            </summary>
        </member>
        <member name="F:SharpVk.Format.A2B10G10R10UScaledPack32">
            <summary>
            ename:VK_FORMAT_A2B10G10R10_USCALED_PACK32:: A four-component,
            32-bit packed unsigned scaled integer format that has a 2-bit A
            component in bits 30..31, a 10-bit B component in bits 20..29, a
            10-bit G component in bits 10..19, and a 10-bit R component in bits
            0..9.
            </summary>
        </member>
        <member name="F:SharpVk.Format.A2B10G10R10SScaledPack32">
            <summary>
            ename:VK_FORMAT_A2B10G10R10_SSCALED_PACK32:: A four-component,
            32-bit packed signed scaled integer format that has a 2-bit A
            component in bits 30..31, a 10-bit B component in bits 20..29, a
            10-bit G component in bits 10..19, and a 10-bit R component in bits
            0..9.
            </summary>
        </member>
        <member name="F:SharpVk.Format.A2B10G10R10UIntPack32">
            <summary>
            ename:VK_FORMAT_A2B10G10R10_UINT_PACK32:: A four-component, 32-bit
            packed unsigned integer format that has a 2-bit A component in bits
            30..31, a 10-bit B component in bits 20..29, a 10-bit G component
            in bits 10..19, and a 10-bit R component in bits 0..9.
            </summary>
        </member>
        <member name="F:SharpVk.Format.A2B10G10R10SIntPack32">
            <summary>
            ename:VK_FORMAT_A2B10G10R10_SINT_PACK32:: A four-component, 32-bit
            packed signed integer format that has a 2-bit A component in bits
            30..31, a 10-bit B component in bits 20..29, a 10-bit G component
            in bits 10..19, and a 10-bit R component in bits 0..9.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R16UNorm">
            <summary>
            ename:VK_FORMAT_R16_UNORM:: A one-component, 16-bit unsigned
            normalized format that has a single 16-bit R component.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R16SNorm">
            <summary>
            ename:VK_FORMAT_R16_SNORM:: A one-component, 16-bit signed
            normalized format that has a single 16-bit R component.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R16UScaled">
            <summary>
            ename:VK_FORMAT_R16_USCALED:: A one-component, 16-bit unsigned
            scaled integer format that has a single 16-bit R component.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R16SScaled">
            <summary>
            ename:VK_FORMAT_R16_SSCALED:: A one-component, 16-bit signed scaled
            integer format that has a single 16-bit R component.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R16UInt">
            <summary>
            ename:VK_FORMAT_R16_UINT:: A one-component, 16-bit unsigned integer
            format that has a single 16-bit R component.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R16SInt">
            <summary>
            ename:VK_FORMAT_R16_SINT:: A one-component, 16-bit signed integer
            format that has a single 16-bit R component.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R16SFloat">
            <summary>
            ename:VK_FORMAT_R16_SFLOAT:: A one-component, 16-bit signed
            floating-point format that has a single 16-bit R component.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R16G16UNorm">
            <summary>
            ename:VK_FORMAT_R16G16_UNORM:: A two-component, 32-bit unsigned
            normalized format that has a 16-bit R component in bytes 0..1, and
            a 16-bit G component in bytes 2..3.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R16G16SNorm">
            <summary>
            ename:VK_FORMAT_R16G16_SNORM:: A two-component, 32-bit signed
            normalized format that has a 16-bit R component in bytes 0..1, and
            a 16-bit G component in bytes 2..3.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R16G16UScaled">
            <summary>
            ename:VK_FORMAT_R16G16_USCALED:: A two-component, 32-bit unsigned
            scaled integer format that has a 16-bit R component in bytes 0..1,
            and a 16-bit G component in bytes 2..3.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R16G16SScaled">
            <summary>
            ename:VK_FORMAT_R16G16_SSCALED:: A two-component, 32-bit signed
            scaled integer format that has a 16-bit R component in bytes 0..1,
            and a 16-bit G component in bytes 2..3.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R16G16UInt">
            <summary>
            ename:VK_FORMAT_R16G16_UINT:: A two-component, 32-bit unsigned
            integer format that has a 16-bit R component in bytes 0..1, and a
            16-bit G component in bytes 2..3.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R16G16SInt">
            <summary>
            ename:VK_FORMAT_R16G16_SINT:: A two-component, 32-bit signed
            integer format that has a 16-bit R component in bytes 0..1, and a
            16-bit G component in bytes 2..3.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R16G16SFloat">
            <summary>
            ename:VK_FORMAT_R16G16_SFLOAT:: A two-component, 32-bit signed
            floating-point format that has a 16-bit R component in bytes 0..1,
            and a 16-bit G component in bytes 2..3.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R16G16B16UNorm">
            <summary>
            ename:VK_FORMAT_R16G16B16_UNORM:: A three-component, 48-bit
            unsigned normalized format that has a 16-bit R component in bytes
            0..1, a 16-bit G component in bytes 2..3, and a 16-bit B component
            in bytes 4..5.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R16G16B16SNorm">
            <summary>
            ename:VK_FORMAT_R16G16B16_SNORM:: A three-component, 48-bit signed
            normalized format that has a 16-bit R component in bytes 0..1, a
            16-bit G component in bytes 2..3, and a 16-bit B component in bytes
            4..5.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R16G16B16UScaled">
            <summary>
            ename:VK_FORMAT_R16G16B16_USCALED:: A three-component, 48-bit
            unsigned scaled integer format that has a 16-bit R component in
            bytes 0..1, a 16-bit G component in bytes 2..3, and a 16-bit B
            component in bytes 4..5.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R16G16B16SScaled">
            <summary>
            ename:VK_FORMAT_R16G16B16_SSCALED:: A three-component, 48-bit
            signed scaled integer format that has a 16-bit R component in bytes
            0..1, a 16-bit G component in bytes 2..3, and a 16-bit B component
            in bytes 4..5.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R16G16B16UInt">
            <summary>
            ename:VK_FORMAT_R16G16B16_UINT:: A three-component, 48-bit unsigned
            integer format that has a 16-bit R component in bytes 0..1, a
            16-bit G component in bytes 2..3, and a 16-bit B component in bytes
            4..5.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R16G16B16SInt">
            <summary>
            ename:VK_FORMAT_R16G16B16_SINT:: A three-component, 48-bit signed
            integer format that has a 16-bit R component in bytes 0..1, a
            16-bit G component in bytes 2..3, and a 16-bit B component in bytes
            4..5.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R16G16B16SFloat">
            <summary>
            ename:VK_FORMAT_R16G16B16_SFLOAT:: A three-component, 48-bit signed
            floating-point format that has a 16-bit R component in bytes 0..1,
            a 16-bit G component in bytes 2..3, and a 16-bit B component in
            bytes 4..5.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R16G16B16A16UNorm">
            <summary>
            ename:VK_FORMAT_R16G16B16A16_UNORM:: A four-component, 64-bit
            unsigned normalized format that has a 16-bit R component in bytes
            0..1, a 16-bit G component in bytes 2..3, a 16-bit B component in
            bytes 4..5, and a 16-bit A component in bytes 6..7.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R16G16B16A16SNorm">
            <summary>
            ename:VK_FORMAT_R16G16B16A16_SNORM:: A four-component, 64-bit
            signed normalized format that has a 16-bit R component in bytes
            0..1, a 16-bit G component in bytes 2..3, a 16-bit B component in
            bytes 4..5, and a 16-bit A component in bytes 6..7.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R16G16B16A16UScaled">
            <summary>
            ename:VK_FORMAT_R16G16B16A16_USCALED:: A four-component, 64-bit
            unsigned scaled integer format that has a 16-bit R component in
            bytes 0..1, a 16-bit G component in bytes 2..3, a 16-bit B
            component in bytes 4..5, and a 16-bit A component in bytes 6..7.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R16G16B16A16SScaled">
            <summary>
            ename:VK_FORMAT_R16G16B16A16_SSCALED:: A four-component, 64-bit
            signed scaled integer format that has a 16-bit R component in bytes
            0..1, a 16-bit G component in bytes 2..3, a 16-bit B component in
            bytes 4..5, and a 16-bit A component in bytes 6..7.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R16G16B16A16UInt">
            <summary>
            ename:VK_FORMAT_R16G16B16A16_UINT:: A four-component, 64-bit
            unsigned integer format that has a 16-bit R component in bytes
            0..1, a 16-bit G component in bytes 2..3, a 16-bit B component in
            bytes 4..5, and a 16-bit A component in bytes 6..7.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R16G16B16A16SInt">
            <summary>
            ename:VK_FORMAT_R16G16B16A16_SINT:: A four-component, 64-bit signed
            integer format that has a 16-bit R component in bytes 0..1, a
            16-bit G component in bytes 2..3, a 16-bit B component in bytes
            4..5, and a 16-bit A component in bytes 6..7.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R16G16B16A16SFloat">
            <summary>
            ename:VK_FORMAT_R16G16B16A16_SFLOAT:: A four-component, 64-bit
            signed floating-point format that has a 16-bit R component in bytes
            0..1, a 16-bit G component in bytes 2..3, a 16-bit B component in
            bytes 4..5, and a 16-bit A component in bytes 6..7.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R32UInt">
            <summary>
            ename:VK_FORMAT_R32_UINT:: A one-component, 32-bit unsigned integer
            format that has a single 32-bit R component.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R32SInt">
            <summary>
            ename:VK_FORMAT_R32_SINT:: A one-component, 32-bit signed integer
            format that has a single 32-bit R component.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R32SFloat">
            <summary>
            ename:VK_FORMAT_R32_SFLOAT:: A one-component, 32-bit signed
            floating-point format that has a single 32-bit R component.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R32G32UInt">
            <summary>
            ename:VK_FORMAT_R32G32_UINT:: A two-component, 64-bit unsigned
            integer format that has a 32-bit R component in bytes 0..3, and a
            32-bit G component in bytes 4..7.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R32G32SInt">
            <summary>
            ename:VK_FORMAT_R32G32_SINT:: A two-component, 64-bit signed
            integer format that has a 32-bit R component in bytes 0..3, and a
            32-bit G component in bytes 4..7.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R32G32SFloat">
            <summary>
            ename:VK_FORMAT_R32G32_SFLOAT:: A two-component, 64-bit signed
            floating-point format that has a 32-bit R component in bytes 0..3,
            and a 32-bit G component in bytes 4..7.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R32G32B32UInt">
            <summary>
            ename:VK_FORMAT_R32G32B32_UINT:: A three-component, 96-bit unsigned
            integer format that has a 32-bit R component in bytes 0..3, a
            32-bit G component in bytes 4..7, and a 32-bit B component in bytes
            8..11.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R32G32B32SInt">
            <summary>
            ename:VK_FORMAT_R32G32B32_SINT:: A three-component, 96-bit signed
            integer format that has a 32-bit R component in bytes 0..3, a
            32-bit G component in bytes 4..7, and a 32-bit B component in bytes
            8..11.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R32G32B32SFloat">
            <summary>
            ename:VK_FORMAT_R32G32B32_SFLOAT:: A three-component, 96-bit signed
            floating-point format that has a 32-bit R component in bytes 0..3,
            a 32-bit G component in bytes 4..7, and a 32-bit B component in
            bytes 8..11.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R32G32B32A32UInt">
            <summary>
            ename:VK_FORMAT_R32G32B32A32_UINT:: A four-component, 128-bit
            unsigned integer format that has a 32-bit R component in bytes
            0..3, a 32-bit G component in bytes 4..7, a 32-bit B component in
            bytes 8..11, and a 32-bit A component in bytes 12..15.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R32G32B32A32SInt">
            <summary>
            ename:VK_FORMAT_R32G32B32A32_SINT:: A four-component, 128-bit
            signed integer format that has a 32-bit R component in bytes 0..3,
            a 32-bit G component in bytes 4..7, a 32-bit B component in bytes
            8..11, and a 32-bit A component in bytes 12..15.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R32G32B32A32SFloat">
            <summary>
            ename:VK_FORMAT_R32G32B32A32_SFLOAT:: A four-component, 128-bit
            signed floating-point format that has a 32-bit R component in bytes
            0..3, a 32-bit G component in bytes 4..7, a 32-bit B component in
            bytes 8..11, and a 32-bit A component in bytes 12..15.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R64UInt">
            <summary>
            ename:VK_FORMAT_R64_UINT:: A one-component, 64-bit unsigned integer
            format that has a single 64-bit R component.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R64SInt">
            <summary>
            ename:VK_FORMAT_R64_SINT:: A one-component, 64-bit signed integer
            format that has a single 64-bit R component.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R64SFloat">
            <summary>
            ename:VK_FORMAT_R64_SFLOAT:: A one-component, 64-bit signed
            floating-point format that has a single 64-bit R component.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R64G64UInt">
            <summary>
            ename:VK_FORMAT_R64G64_UINT:: A two-component, 128-bit unsigned
            integer format that has a 64-bit R component in bytes 0..7, and a
            64-bit G component in bytes 8..15.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R64G64SInt">
            <summary>
            ename:VK_FORMAT_R64G64_SINT:: A two-component, 128-bit signed
            integer format that has a 64-bit R component in bytes 0..7, and a
            64-bit G component in bytes 8..15.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R64G64SFloat">
            <summary>
            ename:VK_FORMAT_R64G64_SFLOAT:: A two-component, 128-bit signed
            floating-point format that has a 64-bit R component in bytes 0..7,
            and a 64-bit G component in bytes 8..15.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R64G64B64UInt">
            <summary>
            ename:VK_FORMAT_R64G64B64_UINT:: A three-component, 192-bit
            unsigned integer format that has a 64-bit R component in bytes
            0..7, a 64-bit G component in bytes 8..15, and a 64-bit B component
            in bytes 16..23.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R64G64B64SInt">
            <summary>
            ename:VK_FORMAT_R64G64B64_SINT:: A three-component, 192-bit signed
            integer format that has a 64-bit R component in bytes 0..7, a
            64-bit G component in bytes 8..15, and a 64-bit B component in
            bytes 16..23.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R64G64B64SFloat">
            <summary>
            ename:VK_FORMAT_R64G64B64_SFLOAT:: A three-component, 192-bit
            signed floating-point format that has a 64-bit R component in bytes
            0..7, a 64-bit G component in bytes 8..15, and a 64-bit B component
            in bytes 16..23.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R64G64B64A64UInt">
            <summary>
            ename:VK_FORMAT_R64G64B64A64_UINT:: A four-component, 256-bit
            unsigned integer format that has a 64-bit R component in bytes
            0..7, a 64-bit G component in bytes 8..15, a 64-bit B component in
            bytes 16..23, and a 64-bit A component in bytes 24..31.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R64G64B64A64SInt">
            <summary>
            ename:VK_FORMAT_R64G64B64A64_SINT:: A four-component, 256-bit
            signed integer format that has a 64-bit R component in bytes 0..7,
            a 64-bit G component in bytes 8..15, a 64-bit B component in bytes
            16..23, and a 64-bit A component in bytes 24..31.
            </summary>
        </member>
        <member name="F:SharpVk.Format.R64G64B64A64SFloat">
            <summary>
            ename:VK_FORMAT_R64G64B64A64_SFLOAT:: A four-component, 256-bit
            signed floating-point format that has a 64-bit R component in bytes
            0..7, a 64-bit G component in bytes 8..15, a 64-bit B component in
            bytes 16..23, and a 64-bit A component in bytes 24..31.
            </summary>
        </member>
        <member name="F:SharpVk.Format.B10G11R11UfloatPack32">
            <summary>
            ename:VK_FORMAT_B10G11R11_UFLOAT_PACK32:: A three-component, 32-bit
            packed unsigned floating-point format that has a 10-bit B component
            in bits 22..31, an 11-bit G component in bits 11..21, an 11-bit R
            component in bits 0..10. See &lt;&lt;fundamentals-fp10&gt;&gt; and
            &lt;&lt;fundamentals-fp11&gt;&gt;.
            </summary>
        </member>
        <member name="F:SharpVk.Format.E5b9g9r9UfloatPack32">
            <summary>
            ename:VK_FORMAT_E5B9G9R9_UFLOAT_PACK32:: A three-component, 32-bit
            packed unsigned floating-point format that has a 5-bit shared
            exponent in bits 27..31, a 9-bit B component mantissa in bits
            18..26, a 9-bit G component mantissa in bits 9..17, and a 9-bit R
            component mantissa in bits 0..8.
            </summary>
        </member>
        <member name="F:SharpVk.Format.D16UNorm">
            <summary>
            ename:VK_FORMAT_D16_UNORM:: A one-component, 16-bit unsigned
            normalized format that has a single 16-bit depth component.
            </summary>
        </member>
        <member name="F:SharpVk.Format.X8D24UNormPack32">
            <summary>
            ename:VK_FORMAT_X8_D24_UNORM_PACK32:: A two-component, 32-bit
            format that has 24 unsigned normalized bits in the depth component
            and, optionally:, 8 bits that are unused.
            </summary>
        </member>
        <member name="F:SharpVk.Format.D32SFloat">
            <summary>
            ename:VK_FORMAT_D32_SFLOAT:: A one-component, 32-bit signed
            floating-point format that has 32-bits in the depth component.
            </summary>
        </member>
        <member name="F:SharpVk.Format.S8UInt">
            <summary>
            ename:VK_FORMAT_S8_UINT:: A one-component, 8-bit unsigned integer
            format that has 8-bits in the stencil component.
            </summary>
        </member>
        <member name="F:SharpVk.Format.D16UNormS8UInt">
            <summary>
            ename:VK_FORMAT_D16_UNORM_S8_UINT:: A two-component, 24-bit format
            that has 16 unsigned normalized bits in the depth component and 8
            unsigned integer bits in the stencil component.
            </summary>
        </member>
        <member name="F:SharpVk.Format.D24UNormS8UInt">
            <summary>
            ename:VK_FORMAT_D24_UNORM_S8_UINT:: A two-component, 32-bit packed
            format that has 8 unsigned integer bits in the stencil component,
            and 24 unsigned normalized bits in the depth component.
            </summary>
        </member>
        <member name="F:SharpVk.Format.D32SFloatS8UInt">
            <summary>
            ename:VK_FORMAT_D32_SFLOAT_S8_UINT:: A two-component format that
            has 32 signed float bits in the depth component and 8 unsigned
            integer bits in the stencil component. There are optionally:
            24-bits that are unused.
            </summary>
        </member>
        <member name="F:SharpVk.Format.Bc1RgbUNormBlock">
            <summary>
            ename:VK_FORMAT_BC1_RGB_UNORM_BLOCK:: A three-component,
            block-compressed format where each 64-bit compressed texel block
            encodes a 4x4 rectangle of unsigned normalized RGB texel data. This
            format has no alpha and is considered opaque.
            </summary>
        </member>
        <member name="F:SharpVk.Format.Bc1RgbSrgbBlock">
            <summary>
            ename:VK_FORMAT_BC1_RGB_SRGB_BLOCK:: A three-component,
            block-compressed format where each 64-bit compressed texel block
            encodes a 4x4 rectangle of unsigned normalized RGB texel data with
            sRGB nonlinear encoding. This format has no alpha and is considered
            opaque.
            </summary>
        </member>
        <member name="F:SharpVk.Format.Bc1RgbaUNormBlock">
            <summary>
            ename:VK_FORMAT_BC1_RGBA_UNORM_BLOCK:: A four-component,
            block-compressed format where each 64-bit compressed texel block
            encodes a 4x4 rectangle of unsigned normalized RGB texel data, and
            provides 1 bit of alpha.
            </summary>
        </member>
        <member name="F:SharpVk.Format.Bc1RgbaSrgbBlock">
            <summary>
            ename:VK_FORMAT_BC1_RGBA_SRGB_BLOCK:: A four-component,
            block-compressed format where each 64-bit compressed texel block
            encodes a 4x4 rectangle of unsigned normalized RGB texel data with
            sRGB nonlinear encoding, and provides 1 bit of alpha.
            </summary>
        </member>
        <member name="F:SharpVk.Format.Bc2UNormBlock">
            <summary>
            ename:VK_FORMAT_BC2_UNORM_BLOCK:: A four-component,
            block-compressed format where each 128-bit compressed texel block
            encodes a 4x4 rectangle of unsigned normalized RGBA texel data with
            the first 64 bits encoding alpha values followed by 64 bits
            encoding RGB values.
            </summary>
        </member>
        <member name="F:SharpVk.Format.Bc2SrgbBlock">
            <summary>
            ename:VK_FORMAT_BC2_SRGB_BLOCK:: A four-component, block-compressed
            format where each 128-bit compressed texel block encodes a 4x4
            rectangle of unsigned normalized RGBA texel data with the first 64
            bits encoding alpha values followed by 64 bits encoding RGB values
            with sRGB nonlinear encoding.
            </summary>
        </member>
        <member name="F:SharpVk.Format.Bc3UNormBlock">
            <summary>
            ename:VK_FORMAT_BC3_UNORM_BLOCK:: A four-component,
            block-compressed format where each 128-bit compressed texel block
            encodes a 4x4 rectangle of unsigned normalized RGBA texel data with
            the first 64 bits encoding alpha values followed by 64 bits
            encoding RGB values.
            </summary>
        </member>
        <member name="F:SharpVk.Format.Bc3SrgbBlock">
            <summary>
            ename:VK_FORMAT_BC3_SRGB_BLOCK:: A four-component, block-compressed
            format where each 128-bit compressed texel block encodes a 4x4
            rectangle of unsigned normalized RGBA texel data with the first 64
            bits encoding alpha values followed by 64 bits encoding RGB values
            with sRGB nonlinear encoding.
            </summary>
        </member>
        <member name="F:SharpVk.Format.Bc4UNormBlock">
            <summary>
            ename:VK_FORMAT_BC4_UNORM_BLOCK:: A one-component, block-compressed
            format where each 64-bit compressed texel block encodes a 4x4
            rectangle of unsigned normalized red texel data.
            </summary>
        </member>
        <member name="F:SharpVk.Format.Bc4SNormBlock">
            <summary>
            ename:VK_FORMAT_BC4_SNORM_BLOCK:: A one-component, block-compressed
            format where each 64-bit compressed texel block encodes a 4x4
            rectangle of signed normalized red texel data.
            </summary>
        </member>
        <member name="F:SharpVk.Format.Bc5UNormBlock">
            <summary>
            ename:VK_FORMAT_BC5_UNORM_BLOCK:: A two-component, block-compressed
            format where each 128-bit compressed texel block encodes a 4x4
            rectangle of unsigned normalized RG texel data with the first 64
            bits encoding red values followed by 64 bits encoding green values.
            </summary>
        </member>
        <member name="F:SharpVk.Format.Bc5SNormBlock">
            <summary>
            ename:VK_FORMAT_BC5_SNORM_BLOCK:: A two-component, block-compressed
            format where each 128-bit compressed texel block encodes a 4x4
            rectangle of signed normalized RG texel data with the first 64 bits
            encoding red values followed by 64 bits encoding green values.
            </summary>
        </member>
        <member name="F:SharpVk.Format.Bc6hUfloatBlock">
            <summary>
            ename:VK_FORMAT_BC6H_UFLOAT_BLOCK:: A three-component,
            block-compressed format where each 128-bit compressed texel block
            encodes a 4x4 rectangle of unsigned floating-point RGB texel data.
            </summary>
        </member>
        <member name="F:SharpVk.Format.Bc6hSFloatBlock">
            <summary>
            ename:VK_FORMAT_BC6H_SFLOAT_BLOCK:: A three-component,
            block-compressed format where each 128-bit compressed texel block
            encodes a 4x4 rectangle of signed floating-point RGB texel data.
            </summary>
        </member>
        <member name="F:SharpVk.Format.Bc7UNormBlock">
            <summary>
            ename:VK_FORMAT_BC7_UNORM_BLOCK:: A four-component,
            block-compressed format where each 128-bit compressed texel block
            encodes a 4x4 rectangle of unsigned normalized RGBA texel data.
            </summary>
        </member>
        <member name="F:SharpVk.Format.Bc7SrgbBlock">
            <summary>
            ename:VK_FORMAT_BC7_SRGB_BLOCK:: A four-component, block-compressed
            format where each 128-bit compressed texel block encodes a 4x4
            rectangle of unsigned normalized RGBA texel data with sRGB
            nonlinear encoding applied to the RGB components.
            </summary>
        </member>
        <member name="F:SharpVk.Format.Etc2R8G8B8UNormBlock">
            <summary>
            ename:VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK:: A three-component, ETC2
            compressed format where each 64-bit compressed texel block encodes
            a 4x4 rectangle of unsigned normalized RGB texel data. This format
            has no alpha and is considered opaque.
            </summary>
        </member>
        <member name="F:SharpVk.Format.Etc2R8G8B8SrgbBlock">
            <summary>
            ename:VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK:: A three-component, ETC2
            compressed format where each 64-bit compressed texel block encodes
            a 4x4 rectangle of unsigned normalized RGB texel data with sRGB
            nonlinear encoding. This format has no alpha and is considered
            opaque.
            </summary>
        </member>
        <member name="F:SharpVk.Format.Etc2R8G8B8A1UNormBlock">
            <summary>
            ename:VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK:: A four-component, ETC2
            compressed format where each 64-bit compressed texel block encodes
            a 4x4 rectangle of unsigned normalized RGB texel data, and provides
            1 bit of alpha.
            </summary>
        </member>
        <member name="F:SharpVk.Format.Etc2R8G8B8A1SrgbBlock">
            <summary>
            ename:VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK:: A four-component, ETC2
            compressed format where each 64-bit compressed texel block encodes
            a 4x4 rectangle of unsigned normalized RGB texel data with sRGB
            nonlinear encoding, and provides 1 bit of alpha.
            </summary>
        </member>
        <member name="F:SharpVk.Format.Etc2R8G8B8A8UNormBlock">
            <summary>
            ename:VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK:: A four-component, ETC2
            compressed format where each 128-bit compressed texel block encodes
            a 4x4 rectangle of unsigned normalized RGBA texel data with the
            first 64 bits encoding alpha values followed by 64 bits encoding
            RGB values.
            </summary>
        </member>
        <member name="F:SharpVk.Format.Etc2R8G8B8A8SrgbBlock">
            <summary>
            ename:VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK:: A four-component, ETC2
            compressed format where each 64-bit compressed texel block encodes
            a 4x4 rectangle of unsigned normalized RGBA texel data with the
            first 64 bits encoding alpha values followed by 64 bits encoding
            RGB values with sRGB nonlinear encoding applied.
            </summary>
        </member>
        <member name="F:SharpVk.Format.EacR11UNormBlock">
            <summary>
            ename:VK_FORMAT_EAC_R11_UNORM_BLOCK:: A one-component, ETC2
            compressed format where each 64-bit compressed texel block encodes
            a 4x4 rectangle of unsigned normalized red texel data.
            </summary>
        </member>
        <member name="F:SharpVk.Format.EacR11SNormBlock">
            <summary>
            ename:VK_FORMAT_EAC_R11_SNORM_BLOCK:: A one-component, ETC2
            compressed format where each 64-bit compressed texel block encodes
            a 4x4 rectangle of signed normalized red texel data.
            </summary>
        </member>
        <member name="F:SharpVk.Format.EacR11G11UNormBlock">
            <summary>
            ename:VK_FORMAT_EAC_R11G11_UNORM_BLOCK:: A two-component, ETC2
            compressed format where each 128-bit compressed texel block encodes
            a 4x4 rectangle of unsigned normalized RG texel data with the first
            64 bits encoding red values followed by 64 bits encoding green
            values.
            </summary>
        </member>
        <member name="F:SharpVk.Format.EacR11G11SNormBlock">
            <summary>
            ename:VK_FORMAT_EAC_R11G11_SNORM_BLOCK:: A two-component, ETC2
            compressed format where each 128-bit compressed texel block encodes
            a 4x4 rectangle of signed normalized RG texel data with the first
            64 bits encoding red values followed by 64 bits encoding green
            values.
            </summary>
        </member>
        <member name="F:SharpVk.Format.Astc4x4UNormBlock">
            <summary>
            ename:VK_FORMAT_ASTC_4x4_UNORM_BLOCK:: A four-component, ASTC
            compressed format where each 128-bit compressed texel block encodes
            a 4x4 rectangle of unsigned normalized RGBA texel data.
            </summary>
        </member>
        <member name="F:SharpVk.Format.Astc4x4SrgbBlock">
            <summary>
            ename:VK_FORMAT_ASTC_4x4_SRGB_BLOCK:: A four-component, ASTC
            compressed format where each 128-bit compressed texel block encodes
            a 4x4 rectangle of unsigned normalized RGBA texel data with sRGB
            nonlinear encoding applied to the RGB components.
            </summary>
        </member>
        <member name="F:SharpVk.Format.Astc5x4UNormBlock">
            <summary>
            ename:VK_FORMAT_ASTC_5x4_UNORM_BLOCK:: A four-component, ASTC
            compressed format where each 128-bit compressed texel block encodes
            a 5x4 rectangle of unsigned normalized RGBA texel data.
            </summary>
        </member>
        <member name="F:SharpVk.Format.Astc5x4SrgbBlock">
            <summary>
            ename:VK_FORMAT_ASTC_5x4_SRGB_BLOCK:: A four-component, ASTC
            compressed format where each 128-bit compressed texel block encodes
            a 5x4 rectangle of unsigned normalized RGBA texel data with sRGB
            nonlinear encoding applied to the RGB components.
            </summary>
        </member>
        <member name="F:SharpVk.Format.Astc5x5UNormBlock">
            <summary>
            ename:VK_FORMAT_ASTC_5x5_UNORM_BLOCK:: A four-component, ASTC
            compressed format where each 128-bit compressed texel block encodes
            a 5x5 rectangle of unsigned normalized RGBA texel data.
            </summary>
        </member>
        <member name="F:SharpVk.Format.Astc5x5SrgbBlock">
            <summary>
            ename:VK_FORMAT_ASTC_5x5_SRGB_BLOCK:: A four-component, ASTC
            compressed format where each 128-bit compressed texel block encodes
            a 5x5 rectangle of unsigned normalized RGBA texel data with sRGB
            nonlinear encoding applied to the RGB components.
            </summary>
        </member>
        <member name="F:SharpVk.Format.Astc6x5UNormBlock">
            <summary>
            ename:VK_FORMAT_ASTC_6x5_UNORM_BLOCK:: A four-component, ASTC
            compressed format where each 128-bit compressed texel block encodes
            a 6x5 rectangle of unsigned normalized RGBA texel data.
            </summary>
        </member>
        <member name="F:SharpVk.Format.Astc6x5SrgbBlock">
            <summary>
            ename:VK_FORMAT_ASTC_6x5_SRGB_BLOCK:: A four-component, ASTC
            compressed format where each 128-bit compressed texel block encodes
            a 6x5 rectangle of unsigned normalized RGBA texel data with sRGB
            nonlinear encoding applied to the RGB components.
            </summary>
        </member>
        <member name="F:SharpVk.Format.Astc6x6UNormBlock">
            <summary>
            ename:VK_FORMAT_ASTC_6x6_UNORM_BLOCK:: A four-component, ASTC
            compressed format where each 128-bit compressed texel block encodes
            a 6x6 rectangle of unsigned normalized RGBA texel data.
            </summary>
        </member>
        <member name="F:SharpVk.Format.Astc6x6SrgbBlock">
            <summary>
            ename:VK_FORMAT_ASTC_6x6_SRGB_BLOCK:: A four-component, ASTC
            compressed format where each 128-bit compressed texel block encodes
            a 6x6 rectangle of unsigned normalized RGBA texel data with sRGB
            nonlinear encoding applied to the RGB components.
            </summary>
        </member>
        <member name="F:SharpVk.Format.Astc8x5UNormBlock">
            <summary>
            ename:VK_FORMAT_ASTC_8x5_UNORM_BLOCK:: A four-component, ASTC
            compressed format where each 128-bit compressed texel block encodes
            an 8x5 rectangle of unsigned normalized RGBA texel data.
            </summary>
        </member>
        <member name="F:SharpVk.Format.Astc8x5SrgbBlock">
            <summary>
            ename:VK_FORMAT_ASTC_8x5_SRGB_BLOCK:: A four-component, ASTC
            compressed format where each 128-bit compressed texel block encodes
            an 8x5 rectangle of unsigned normalized RGBA texel data with sRGB
            nonlinear encoding applied to the RGB components.
            </summary>
        </member>
        <member name="F:SharpVk.Format.Astc8x6UNormBlock">
            <summary>
            ename:VK_FORMAT_ASTC_8x6_UNORM_BLOCK:: A four-component, ASTC
            compressed format where each 128-bit compressed texel block encodes
            an 8x6 rectangle of unsigned normalized RGBA texel data.
            </summary>
        </member>
        <member name="F:SharpVk.Format.Astc8x6SrgbBlock">
            <summary>
            ename:VK_FORMAT_ASTC_8x6_SRGB_BLOCK:: A four-component, ASTC
            compressed format where each 128-bit compressed texel block encodes
            an 8x6 rectangle of unsigned normalized RGBA texel data with sRGB
            nonlinear encoding applied to the RGB components.
            </summary>
        </member>
        <member name="F:SharpVk.Format.Astc8x8UNormBlock">
            <summary>
            ename:VK_FORMAT_ASTC_8x8_UNORM_BLOCK:: A four-component, ASTC
            compressed format where each 128-bit compressed texel block encodes
            an 8x8 rectangle of unsigned normalized RGBA texel data.
            </summary>
        </member>
        <member name="F:SharpVk.Format.Astc8x8SrgbBlock">
            <summary>
            ename:VK_FORMAT_ASTC_8x8_SRGB_BLOCK:: A four-component, ASTC
            compressed format where each 128-bit compressed texel block encodes
            an 8x8 rectangle of unsigned normalized RGBA texel data with sRGB
            nonlinear encoding applied to the RGB components.
            </summary>
        </member>
        <member name="F:SharpVk.Format.Astc10x5UNormBlock">
            <summary>
            ename:VK_FORMAT_ASTC_10x5_UNORM_BLOCK:: A four-component, ASTC
            compressed format where each 128-bit compressed texel block encodes
            a 10x5 rectangle of unsigned normalized RGBA texel data.
            </summary>
        </member>
        <member name="F:SharpVk.Format.Astc10x5SrgbBlock">
            <summary>
            ename:VK_FORMAT_ASTC_10x5_SRGB_BLOCK:: A four-component, ASTC
            compressed format where each 128-bit compressed texel block encodes
            a 10x5 rectangle of unsigned normalized RGBA texel data with sRGB
            nonlinear encoding applied to the RGB components.
            </summary>
        </member>
        <member name="F:SharpVk.Format.Astc10x6UNormBlock">
            <summary>
            ename:VK_FORMAT_ASTC_10x6_UNORM_BLOCK:: A four-component, ASTC
            compressed format where each 128-bit compressed texel block encodes
            a 10x6 rectangle of unsigned normalized RGBA texel data.
            </summary>
        </member>
        <member name="F:SharpVk.Format.Astc10x6SrgbBlock">
            <summary>
            ename:VK_FORMAT_ASTC_10x6_SRGB_BLOCK:: A four-component, ASTC
            compressed format where each 128-bit compressed texel block encodes
            a 10x6 rectangle of unsigned normalized RGBA texel data with sRGB
            nonlinear encoding applied to the RGB components.
            </summary>
        </member>
        <member name="F:SharpVk.Format.Astc10x8UNormBlock">
            <summary>
            ename:VK_FORMAT_ASTC_10x8_UNORM_BLOCK:: A four-component, ASTC
            compressed format where each 128-bit compressed texel block encodes
            a 10x8 rectangle of unsigned normalized RGBA texel data.
            </summary>
        </member>
        <member name="F:SharpVk.Format.Astc10x8SrgbBlock">
            <summary>
            ename:VK_FORMAT_ASTC_10x8_SRGB_BLOCK:: A four-component, ASTC
            compressed format where each 128-bit compressed texel block encodes
            a 10x8 rectangle of unsigned normalized RGBA texel data with sRGB
            nonlinear encoding applied to the RGB components.
            </summary>
        </member>
        <member name="F:SharpVk.Format.Astc10x10UNormBlock">
            <summary>
            ename:VK_FORMAT_ASTC_10x10_UNORM_BLOCK:: A four-component, ASTC
            compressed format where each 128-bit compressed texel block encodes
            a 10x10 rectangle of unsigned normalized RGBA texel data.
            </summary>
        </member>
        <member name="F:SharpVk.Format.Astc10x10SrgbBlock">
            <summary>
            ename:VK_FORMAT_ASTC_10x10_SRGB_BLOCK:: A four-component, ASTC
            compressed format where each 128-bit compressed texel block encodes
            a 10x10 rectangle of unsigned normalized RGBA texel data with sRGB
            nonlinear encoding applied to the RGB components.
            </summary>
        </member>
        <member name="F:SharpVk.Format.Astc12x10UNormBlock">
            <summary>
            ename:VK_FORMAT_ASTC_12x10_UNORM_BLOCK:: A four-component, ASTC
            compressed format where each 128-bit compressed texel block encodes
            a 12x10 rectangle of unsigned normalized RGBA texel data.
            </summary>
        </member>
        <member name="F:SharpVk.Format.Astc12x10SrgbBlock">
            <summary>
            ename:VK_FORMAT_ASTC_12x10_SRGB_BLOCK:: A four-component, ASTC
            compressed format where each 128-bit compressed texel block encodes
            a 12x10 rectangle of unsigned normalized RGBA texel data with sRGB
            nonlinear encoding applied to the RGB components.
            </summary>
        </member>
        <member name="F:SharpVk.Format.Astc12x12UNormBlock">
            <summary>
            ename:VK_FORMAT_ASTC_12x12_UNORM_BLOCK:: A four-component, ASTC
            compressed format where each 128-bit compressed texel block encodes
            a 12x12 rectangle of unsigned normalized RGBA texel data.
            </summary>
        </member>
        <member name="F:SharpVk.Format.Astc12x12SrgbBlock">
            <summary>
            ename:VK_FORMAT_ASTC_12x12_SRGB_BLOCK:: A four-component, ASTC
            compressed format where each 128-bit compressed texel block encodes
            a 12x12 rectangle of unsigned normalized RGBA texel data with sRGB
            nonlinear encoding applied to the RGB components.
            </summary>
        </member>
        <member name="F:SharpVk.Format.Pvrtc12bppUNormBlock">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Format.Pvrtc14bppUNormBlock">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Format.Pvrtc22bppUNormBlock">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Format.Pvrtc24bppUNormBlock">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Format.Pvrtc12bppSrgbBlock">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Format.Pvrtc14bppSrgbBlock">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Format.Pvrtc22bppSrgbBlock">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Format.Pvrtc24bppSrgbBlock">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.FormatFeatureFlags">
            <summary>
            <para>
            Bitmask specifying features supported by a buffer.
            </para>
            <para>
            The pname:linearTilingFeatures and pname:optimalTilingFeatures members
            of the sname:VkFormatProperties structure describe what features are
            supported by ename:VK_IMAGE_TILING_LINEAR and
            ename:VK_IMAGE_TILING_OPTIMAL images, respectively.
            </para>
            <para>
            The following bits may: be set in pname:linearTilingFeatures and
            pname:optimalTilingFeatures, indicating they are supported by images or
            image views created with the queried
            flink:vkGetPhysicalDeviceFormatProperties::pname:format:
            </para>
            <para>
            ename:VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT:: sname:VkImageView can: be
            sampled from. See &lt;&lt;descriptorsets-sampledimage, sampled
            images&gt;&gt; section.
            </para>
            <para>
            ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT:: sname:VkImageView can: be
            used as storage image. See &lt;&lt;descriptorsets-storageimage, storage
            images&gt;&gt; section.
            </para>
            <para>
            ename:VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT:: sname:VkImageView
            can: be used as storage image that supports atomic operations.
            </para>
            <para>
            ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT:: sname:VkImageView can:
            be used as a framebuffer color attachment and as an input attachment.
            </para>
            <para>
            ename:VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT:: sname:VkImageView
            can: be used as a framebuffer color attachment that supports blending
            and as an input attachment.
            </para>
            <para>
            ename:VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT::
            sname:VkImageView can: be used as a framebuffer depth/stencil
            attachment and as an input attachment.
            </para>
            <para>
            ename:VK_FORMAT_FEATURE_BLIT_SRC_BIT:: sname:VkImage can: be used as
            pname:srcImage for the fname:vkCmdBlitImage command.
            </para>
            <para>
            ename:VK_FORMAT_FEATURE_BLIT_DST_BIT:: sname:VkImage can: be used as
            pname:dstImage for the fname:vkCmdBlitImage command.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.FormatFeatureFlags.None">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.FormatFeatureFlags.SampledImage">
            <summary>
            Format can be used for sampled images (SAMPLED_IMAGE and
            COMBINED_IMAGE_SAMPLER descriptor types)
            </summary>
        </member>
        <member name="F:SharpVk.FormatFeatureFlags.StorageImage">
            <summary>
            Format can be used for storage images (STORAGE_IMAGE descriptor
            type)
            </summary>
        </member>
        <member name="F:SharpVk.FormatFeatureFlags.StorageImageAtomic">
            <summary>
            Format supports atomic operations in case it is used for storage
            images
            </summary>
        </member>
        <member name="F:SharpVk.FormatFeatureFlags.UniformTexelBuffer">
            <summary>
            Format can be used for uniform texel buffers (TBOs)
            </summary>
        </member>
        <member name="F:SharpVk.FormatFeatureFlags.StorageTexelBuffer">
            <summary>
            Format can be used for storage texel buffers (IBOs)
            </summary>
        </member>
        <member name="F:SharpVk.FormatFeatureFlags.StorageTexelBufferAtomic">
            <summary>
            Format supports atomic operations in case it is used for storage
            texel buffers
            </summary>
        </member>
        <member name="F:SharpVk.FormatFeatureFlags.VertexBuffer">
            <summary>
            Format can be used for vertex buffers (VBOs)
            </summary>
        </member>
        <member name="F:SharpVk.FormatFeatureFlags.ColorAttachment">
            <summary>
            Format can be used for color attachment images
            </summary>
        </member>
        <member name="F:SharpVk.FormatFeatureFlags.ColorAttachmentBlend">
            <summary>
            Format supports blending in case it is used for color attachment
            images
            </summary>
        </member>
        <member name="F:SharpVk.FormatFeatureFlags.DepthStencilAttachment">
            <summary>
            Format can be used for depth/stencil attachment images
            </summary>
        </member>
        <member name="F:SharpVk.FormatFeatureFlags.BlitSource">
            <summary>
            Format can be used as the source image of blits with vkCmdBlitImage
            </summary>
        </member>
        <member name="F:SharpVk.FormatFeatureFlags.BlitDestination">
            <summary>
            Format can be used as the destination image of blits with
            vkCmdBlitImage
            </summary>
        </member>
        <member name="F:SharpVk.FormatFeatureFlags.SampledImageFilterLinear">
            <summary>
            Format can be filtered with VK_FILTER_LINEAR when being sampled
            </summary>
        </member>
        <member name="F:SharpVk.FormatFeatureFlags.SampledImageFilterCubic">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.FormatFeatureFlags.TransferSource">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.FormatFeatureFlags.TransferDestination">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.FormatProperties">
            <summary>
            <para>
            Structure specifying image format properties.
            </para>
            <para>
            Supported features are described as a set of
            elink:VkFormatFeatureFlagBits:
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.FormatProperties.#ctor(SharpVk.FormatFeatureFlags,SharpVk.FormatFeatureFlags,SharpVk.FormatFeatureFlags)">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.FormatProperties.LinearTilingFeatures">
            <summary>
            pname:linearTilingFeatures describes the features supported by
            ename:VK_IMAGE_TILING_LINEAR.
            </summary>
        </member>
        <member name="F:SharpVk.FormatProperties.OptimalTilingFeatures">
            <summary>
            pname:optimalTilingFeatures describes the features supported by
            ename:VK_IMAGE_TILING_OPTIMAL.
            </summary>
        </member>
        <member name="F:SharpVk.FormatProperties.BufferFeatures">
            <summary>
            pname:bufferFeatures describes the features supported by buffers.
            </summary>
        </member>
        <member name="M:SharpVk.FormatProperties.ToString">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.FormatProperties2">
            <summary>
            Structure specifying image format properties.
            </summary>
        </member>
        <member name="P:SharpVk.FormatProperties2.FormatProperties">
            <summary>
            pname:formatProperties is a structure of type
            slink:VkFormatProperties describing features supported by the
            requested format.
            </summary>
        </member>
        <member name="T:SharpVk.Framebuffer">
            <summary>
            <para>
            Opaque handle to a framebuffer object.
            </para>
            <para>
            Render passes operate in conjunction with _framebuffers_. Framebuffers
            represent a collection of specific memory attachments that a render
            pass instance uses.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Framebuffer.Destroy">
            <summary>
            Destroy a framebuffer object.
            </summary>
        </member>
        <member name="P:SharpVk.Framebuffer.RawHandle">
            <summary>
            The interop handle for this Framebuffer.
            </summary>
        </member>
        <member name="M:SharpVk.Framebuffer.Dispose">
            <summary>
            Releases the unmanaged resources associated with this instance and
            destroys the underlying Vulkan handle.
            </summary>
        </member>
        <member name="T:SharpVk.FramebufferCreateFlags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.FramebufferCreateFlags.None">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.FramebufferCreateInfo">
            <summary>
            <para>
            Structure specifying parameters of a newly created framebuffer.
            </para>
            <para>
            Image subresources used as attachments must: not be used via any
            non-attachment usage for the duration of a render pass instance.
            </para>
            <para>
            [NOTE] .Note ==== This restriction means that the render pass has full
            knowledge of all uses of all of the attachments, so that the
            implementation is able to make correct decisions about when and how to
            perform layout transitions, when to overlap execution of subpasses,
            etc. ====
            </para>
            <para>
            It is legal for a subpass to use no color or depth/stencil attachments,
            and rather use shader side effects such as image stores and atomics to
            produce an output. In this case, the subpass continues to use the
            pname:width, pname:height, and pname:layers of the framebuffer to
            define the dimensions of the rendering area, and the
            pname:rasterizationSamples from each pipeline's
            slink:VkPipelineMultisampleStateCreateInfo to define the number of
            samples used in rasterization; however, if
            slink:VkPhysicalDeviceFeatures::pname:variableMultisampleRate is
            code:VK_FALSE, then all pipelines to be bound with a given
            zero-attachment subpass must: have the same value for
            slink:VkPipelineMultisampleStateCreateInfo::pname:rasterizationSamples.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.FramebufferCreateInfo.Flags">
            <summary>
            pname:flags is reserved for future use.
            </summary>
        </member>
        <member name="P:SharpVk.FramebufferCreateInfo.RenderPass">
            <summary>
            pname:renderPass is a render pass that defines what render passes
            the framebuffer will be compatible with. See
            &lt;&lt;renderpass-compatibility,Render Pass Compatibility&gt;&gt;
            for details.
            </summary>
        </member>
        <member name="P:SharpVk.FramebufferCreateInfo.Attachments">
            <summary>
            pname:pAttachments is an array of sname:VkImageView handles, each
            of which will be used as the corresponding attachment in a render
            pass instance.
            </summary>
        </member>
        <member name="P:SharpVk.FramebufferCreateInfo.Width">
            <summary>
            pname:width, pname:height and pname:layers define the dimensions of
            the framebuffer.
            </summary>
        </member>
        <member name="P:SharpVk.FramebufferCreateInfo.Height">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.FramebufferCreateInfo.Layers">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.FrontFace">
            <summary>
            <para>
            Interpret polygon front-facing orientation.
            </para>
            <para>
            The first step of polygon rasterization is to determine whether the
            triangle is _back-facing_ or _front-facing_. This determination is made
            based on the sign of the (clipped or unclipped) polygon's area computed
            in framebuffer coordinates. One way to compute this area is:
            </para>
            <para>
            [latexmath]
            ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ a
            = -{1 \over 2}\sum_{i=0}^{n-1} x_f^i y_f^{i \oplus 1} - x_f^{i \oplus
            1} y_f^i
            ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
            </para>
            <para>
            where latexmath:[x_f^i] and latexmath:[y_f^i] are the [eq]#x# and
            [eq]#y# framebuffer coordinates of the [eq]##i##th vertex of the
            [eq]#n#-vertex polygon (vertices are numbered starting at zero for the
            purposes of this computation) and [eq]#i {oplus} 1# is [eq]#(i + 1) mod
            n#.
            </para>
            <para>
            If pname:frontFace is set to ename:VK_FRONT_FACE_COUNTER_CLOCKWISE, a
            triangle with positive area is considered front-facing. If it is set to
            ename:VK_FRONT_FACE_CLOCKWISE, a triangle with negative area is
            considered front-facing. Any triangle which is not front-facing is
            back-facing, including zero-area triangles.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.FrontFace.CounterClockwise">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.FrontFace.Clockwise">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.GraphicsPipelineCreateInfo">
            <summary>
            <para>
            Structure specifying parameters of a newly created graphics pipeline.
            </para>
            <para>
            The parameters pname:basePipelineHandle and pname:basePipelineIndex are
            described in more detail in
            &lt;&lt;pipelines-pipeline-derivatives,Pipeline Derivatives&gt;&gt;.
            </para>
            <para>
            pname:pStages points to an array of
            slink:VkPipelineShaderStageCreateInfo structures, which were previously
            described in &lt;&lt;pipelines-compute,Compute Pipelines&gt;&gt;.
            </para>
            <para>
            Bits which can: be set in pname:flags are:
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.GraphicsPipelineCreateInfo.Flags">
            <summary>
            pname:flags is a bitmask of elink:VkPipelineCreateFlagBits
            controlling how the pipeline will be generated, as described below.
            </summary>
        </member>
        <member name="P:SharpVk.GraphicsPipelineCreateInfo.Stages">
            <summary>
            pname:pStages is an array of size pname:stageCount structures of
            type slink:VkPipelineShaderStageCreateInfo describing the set of
            the shader stages to be included in the graphics pipeline.
            </summary>
        </member>
        <member name="P:SharpVk.GraphicsPipelineCreateInfo.VertexInputState">
            <summary>
            pname:pVertexInputState is a pointer to an instance of the
            slink:VkPipelineVertexInputStateCreateInfo structure.
            </summary>
        </member>
        <member name="P:SharpVk.GraphicsPipelineCreateInfo.InputAssemblyState">
            <summary>
            pname:pInputAssemblyState is a pointer to an instance of the
            slink:VkPipelineInputAssemblyStateCreateInfo structure which
            determines input assembly behavior, as described in
            &lt;&lt;drawing, Drawing Commands&gt;&gt;.
            </summary>
        </member>
        <member name="P:SharpVk.GraphicsPipelineCreateInfo.TessellationState">
            <summary>
            pname:pTessellationState is a pointer to an instance of the
            slink:VkPipelineTessellationStateCreateInfo structure, or `NULL` if
            the pipeline does not include a tessellation control shader stage
            and tessellation evaluation shader stage.
            </summary>
        </member>
        <member name="P:SharpVk.GraphicsPipelineCreateInfo.ViewportState">
            <summary>
            pname:pViewportState is a pointer to an instance of the
            slink:VkPipelineViewportStateCreateInfo structure, or `NULL` if the
            pipeline has rasterization disabled.
            </summary>
        </member>
        <member name="P:SharpVk.GraphicsPipelineCreateInfo.RasterizationState">
            <summary>
            pname:pRasterizationState is a pointer to an instance of the
            slink:VkPipelineRasterizationStateCreateInfo structure.
            </summary>
        </member>
        <member name="P:SharpVk.GraphicsPipelineCreateInfo.MultisampleState">
            <summary>
            pname:pMultisampleState is a pointer to an instance of the
            slink:VkPipelineMultisampleStateCreateInfo, or `NULL` if the
            pipeline has rasterization disabled.
            </summary>
        </member>
        <member name="P:SharpVk.GraphicsPipelineCreateInfo.DepthStencilState">
            <summary>
            pname:pDepthStencilState is a pointer to an instance of the
            slink:VkPipelineDepthStencilStateCreateInfo structure, or `NULL` if
            the pipeline has rasterization disabled or if the subpass of the
            render pass the pipeline is created against does not use a
            depth/stencil attachment.
            </summary>
        </member>
        <member name="P:SharpVk.GraphicsPipelineCreateInfo.ColorBlendState">
            <summary>
            pname:pColorBlendState is a pointer to an instance of the
            slink:VkPipelineColorBlendStateCreateInfo structure, or `NULL` if
            the pipeline has rasterization disabled or if the subpass of the
            render pass the pipeline is created against does not use any color
            attachments.
            </summary>
        </member>
        <member name="P:SharpVk.GraphicsPipelineCreateInfo.DynamicState">
            <summary>
            pname:pDynamicState is a pointer to
            slink:VkPipelineDynamicStateCreateInfo and is used to indicate
            which properties of the pipeline state object are dynamic and can:
            be changed independently of the pipeline state. This can: be
            `NULL`, which means no state in the pipeline is considered dynamic.
            </summary>
        </member>
        <member name="P:SharpVk.GraphicsPipelineCreateInfo.Layout">
            <summary>
            pname:layout is the description of binding locations used by both
            the pipeline and descriptor sets used with the pipeline.
            </summary>
        </member>
        <member name="P:SharpVk.GraphicsPipelineCreateInfo.RenderPass">
            <summary>
            pname:renderPass is a handle to a render pass object describing the
            environment in which the pipeline will be used; the pipeline must:
            only be used with an instance of any render pass compatible with
            the one provided. See &lt;&lt;renderpass-compatibility,Render Pass
            Compatibility&gt;&gt; for more information.
            </summary>
        </member>
        <member name="P:SharpVk.GraphicsPipelineCreateInfo.Subpass">
            <summary>
            pname:subpass is the index of the subpass in the render pass where
            this pipeline will be used.
            </summary>
        </member>
        <member name="P:SharpVk.GraphicsPipelineCreateInfo.BasePipelineHandle">
            <summary>
            pname:basePipelineHandle is a pipeline to derive from.
            </summary>
        </member>
        <member name="P:SharpVk.GraphicsPipelineCreateInfo.BasePipelineIndex">
            <summary>
            pname:basePipelineIndex is an index into the pname:pCreateInfos
            parameter to use as a pipeline to derive from.
            </summary>
        </member>
        <member name="T:SharpVk.Image">
            <summary>
            <para>
            Opaque handle to a image object.
            </para>
            <para>
            Images represent multidimensional - up to 3 - arrays of data which can:
            be used for various purposes (e.g. attachments, textures), by binding
            them to a graphics or compute pipeline via descriptor sets, or by
            directly specifying them as parameters to certain commands.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Image.BindMemory(SharpVk.DeviceMemory,SharpVk.DeviceSize)">
            <summary>
            Bind device memory to an image object.
            </summary>
        </member>
        <member name="M:SharpVk.Image.GetMemoryRequirements">
            <summary>
            Returns the memory requirements for specified Vulkan object.
            </summary>
        </member>
        <member name="M:SharpVk.Image.GetSparseMemoryRequirements">
            <summary>
            Query the memory requirements for a sparse image.
            </summary>
        </member>
        <member name="M:SharpVk.Image.Destroy">
            <summary>
            Destroy an image object.
            </summary>
        </member>
        <member name="M:SharpVk.Image.GetSubresourceLayout(SharpVk.ImageSubresource)">
            <summary>
            Retrieve information about an image subresource.
            </summary>
        </member>
        <member name="P:SharpVk.Image.RawHandle">
            <summary>
            The interop handle for this Image.
            </summary>
        </member>
        <member name="M:SharpVk.Image.Dispose">
            <summary>
            Releases the unmanaged resources associated with this instance and
            destroys the underlying Vulkan handle.
            </summary>
        </member>
        <member name="T:SharpVk.ImageAspectFlags">
            <summary>
            <para>
            Bitmask specifying which aspects of an image are included in a view.
            </para>
            <para>
            The mask must: be only ename:VK_IMAGE_ASPECT_COLOR_BIT,
            ename:VK_IMAGE_ASPECT_DEPTH_BIT or ename:VK_IMAGE_ASPECT_STENCIL_BIT if
            pname:format is a color, depth-only or stencil-only format,
            respectively. If using a depth/stencil format with both depth and
            stencil components, pname:aspectMask must: include at least one of
            ename:VK_IMAGE_ASPECT_DEPTH_BIT and ename:VK_IMAGE_ASPECT_STENCIL_BIT,
            and can: include both.
            </para>
            <para>
            When using an imageView of a depth/stencil image to populate a
            descriptor set (e.g. for sampling in the shader, or for use as an input
            attachment), the pname:aspectMask must: only include one bit and
            selects whether the imageView is used for depth reads (i.e. using a
            floating-point sampler or input attachment in the shader) or stencil
            reads (i.e. using an unsigned integer sampler or input attachment in
            the shader). When an imageView of a depth/stencil image is used as a
            depth/stencil framebuffer attachment, the pname:aspectMask is ignored
            and both depth and stencil image subresources are used.
            </para>
            <para>
            The pname:components member is of type slink:VkComponentMapping, and
            describes a remapping from components of the image to components of the
            vector returned by shader image instructions. This remapping must: be
            identity for storage image descriptors, input attachment descriptors,
            and framebuffer attachments.
            </para>
            <para>
            ****
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ImageAspectFlags.None">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.ImageAspectFlags.Color">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.ImageAspectFlags.Depth">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.ImageAspectFlags.Stencil">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.ImageAspectFlags.Metadata">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.ImageBlit">
            <summary>
            <para>
            Structure specifying an image blit operation.
            </para>
            <para>
            For each element of the pname:pRegions array, a blit operation is
            performed the specified source and destination regions.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.ImageBlit.SourceSubresource">
            <summary>
            pname:srcSubresource is the subresource to blit from.
            </summary>
        </member>
        <member name="P:SharpVk.ImageBlit.SourceOffsets">
            <summary>
            pname:srcOffsets is an array of two slink:VkOffset3D structures
            specifying the bounds of the source region within
            pname:srcSubresource.
            </summary>
        </member>
        <member name="P:SharpVk.ImageBlit.DestinationSubresource">
            <summary>
            pname:dstSubresource is the subresource to blit into.
            </summary>
        </member>
        <member name="P:SharpVk.ImageBlit.DestinationOffsets">
            <summary>
            pname:dstOffsets is an array of two slink:VkOffset3D structures
            specifying the bounds of the destination region within
            pname:dstSubresource.
            </summary>
        </member>
        <member name="T:SharpVk.ImageCopy">
            <summary>
            <para>
            Structure specifying an image copy operation.
            </para>
            <para>
            ifdef::VK_KHR_maintenance1[] For ename:VK_IMAGE_TYPE_3D images, copies
            are performed slice by slice starting with the pname:z member of the
            pname:srcOffset or pname:dstOffset, and copying pname:depth slices. For
            images with multiple layers, copies are performed layer by layer
            starting with the pname:baseArrayLayer member of the
            pname:srcSubresource or pname:dstSubresource and copying
            pname:layerCount layers. Image data can: be copied between images with
            different image types. If one image is ename:VK_IMAGE_TYPE_3D and the
            other image is ename:VK_IMAGE_TYPE_2D with multiple layers, then each
            slice is copied to or from a different layer.
            endif::VK_KHR_maintenance1[] ifndef::VK_KHR_maintenance1[] Copies are
            done layer by layer starting with pname:baseArrayLayer member of
            pname:srcSubresource for the source and pname:dstSubresource for the
            destination. pname:layerCount layers are copied to the destination
            image. endif::VK_KHR_maintenance1[]
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.ImageCopy.#ctor(SharpVk.ImageSubresourceLayers,SharpVk.Offset3D,SharpVk.ImageSubresourceLayers,SharpVk.Offset3D,SharpVk.Extent3D)">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.ImageCopy.SourceSubresource">
            <summary>
            pname:srcSubresource and pname:dstSubresource are
            slink:VkImageSubresourceLayers structures specifying the image
            subresources of the images used for the source and destination
            image data, respectively.
            </summary>
        </member>
        <member name="F:SharpVk.ImageCopy.SourceOffset">
            <summary>
            pname:srcOffset and pname:dstOffset select the initial x, y, and z
            offsets in texels of the sub-regions of the source and destination
            image data.
            </summary>
        </member>
        <member name="F:SharpVk.ImageCopy.DestinationSubresource">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.ImageCopy.DestinationOffset">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.ImageCopy.Extent">
            <summary>
            pname:extent is the size in texels of the source image to copy in
            pname:width, pname:height and pname:depth.
            </summary>
        </member>
        <member name="M:SharpVk.ImageCopy.ToString">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.ImageCreateFlags">
            <summary>
            <para>
            Bitmask specifying additional parameters of an image.
            </para>
            <para>
            If any of the bits ename:VK_IMAGE_CREATE_SPARSE_BINDING_BIT,
            ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT, or
            ename:VK_IMAGE_CREATE_SPARSE_ALIASED_BIT are set,
            ename:VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT must: not also be set.
            </para>
            <para>
            See &lt;&lt;sparsememory-sparseresourcefeatures,Sparse Resource
            Features&gt;&gt; and &lt;&lt;sparsememory-physicalfeatures,Sparse
            Physical Device Features&gt;&gt; for more details.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ImageCreateFlags.None">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.ImageCreateFlags.SparseBinding">
            <summary>
            ename:VK_IMAGE_CREATE_SPARSE_BINDING_BIT indicates that the image
            will be backed using sparse memory binding.
            </summary>
        </member>
        <member name="F:SharpVk.ImageCreateFlags.SparseResidency">
            <summary>
            ename:VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT indicates that the image
            can: be partially backed using sparse memory binding. Images
            created with this flag must: also be created with the
            ename:VK_IMAGE_CREATE_SPARSE_BINDING_BIT flag.
            </summary>
        </member>
        <member name="F:SharpVk.ImageCreateFlags.SparseAliased">
            <summary>
            ename:VK_IMAGE_CREATE_SPARSE_ALIASED_BIT indicates that the image
            will be backed using sparse memory binding with memory ranges that
            might also simultaneously be backing another image (or another
            portion of the same image). Images created with this flag must:
            also be created with the ename:VK_IMAGE_CREATE_SPARSE_BINDING_BIT
            flag
            </summary>
        </member>
        <member name="F:SharpVk.ImageCreateFlags.MutableFormat">
            <summary>
            ename:VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT indicates that the image
            can: be used to create a sname:VkImageView with a different format
            from the image.
            </summary>
        </member>
        <member name="F:SharpVk.ImageCreateFlags.CubeCompatible">
            <summary>
            ename:VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT indicates that the image
            can: be used to create a sname:VkImageView of type
            ename:VK_IMAGE_VIEW_TYPE_CUBE or
            ename:VK_IMAGE_VIEW_TYPE_CUBE_ARRAY. ifdef::VK_KHR_maintenance1[]
            </summary>
        </member>
        <member name="F:SharpVk.ImageCreateFlags.ImageCreate2dArrayCompatible">
            <summary>
            ename:VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR indicates that
            the image can: be used to create a sname:VkImageView of type
            ename:VK_IMAGE_VIEW_TYPE_2D or ename:VK_IMAGE_VIEW_TYPE_2D_ARRAY.
            endif::VK_KHR_maintenance1[]
            </summary>
        </member>
        <member name="T:SharpVk.ImageCreateInfo">
            <summary>
            <para>
            Structure specifying the parameters of a newly created image object.
            </para>
            <para>
            Images created with pname:tiling equal to ename:VK_IMAGE_TILING_LINEAR
            have further restrictions on their limits and capabilities compared to
            images created with pname:tiling equal to
            ename:VK_IMAGE_TILING_OPTIMAL. Creation of images with tiling
            ename:VK_IMAGE_TILING_LINEAR may: not be supported unless other
            parameters meet all of the constraints:
            </para>
            <para>
            * pname:imageType is ename:VK_IMAGE_TYPE_2D * pname:format is not a
            depth/stencil format * pname:mipLevels is 1 * pname:arrayLayers is 1 *
            pname:samples is ename:VK_SAMPLE_COUNT_1_BIT * pname:usage only
            includes ename:VK_IMAGE_USAGE_TRANSFER_SRC_BIT and/or
            ename:VK_IMAGE_USAGE_TRANSFER_DST_BIT
            </para>
            <para>
            Implementations may: support additional limits and capabilities beyond
            those listed above.
            </para>
            <para>
            To query an implementation's specific capabilities for a given
            combination of pname:format, pname:type, pname:tiling, pname:usage, and
            pname:flags, call flink:vkGetPhysicalDeviceImageFormatProperties. The
            return value indicates whether that combination of image settings is
            supported. On success, the sname:VkImageFormatProperties output
            parameter indicates the set of valid pname:samples bits and the limits
            for pname:extent, pname:mipLevels, and pname:arrayLayers.
            </para>
            <para>
            To determine the set of valid pname:usage bits for a given format, call
            flink:vkGetPhysicalDeviceFormatProperties.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.ImageCreateInfo.Flags">
            <summary>
            pname:flags is a bitmask describing additional parameters of the
            image. See elink:VkImageCreateFlagBits below for a description of
            the supported bits.
            </summary>
        </member>
        <member name="P:SharpVk.ImageCreateInfo.ImageType">
            <summary>
            pname:imageType is a elink:VkImageType specifying the basic
            dimensionality of the image, as described below. Layers in array
            textures do not count as a dimension for the purposes of the image
            type.
            </summary>
        </member>
        <member name="P:SharpVk.ImageCreateInfo.Format">
            <summary>
            pname:format is a elink:VkFormat describing the format and type of
            the data elements that will be contained in the image.
            </summary>
        </member>
        <member name="P:SharpVk.ImageCreateInfo.Extent">
            <summary>
            pname:extent is a slink:VkExtent3D describing the number of data
            elements in each dimension of the base level.
            </summary>
        </member>
        <member name="P:SharpVk.ImageCreateInfo.MipLevels">
            <summary>
            pname:mipLevels describes the number of levels of detail available
            for minified sampling of the image.
            </summary>
        </member>
        <member name="P:SharpVk.ImageCreateInfo.ArrayLayers">
            <summary>
            pname:arrayLayers is the number of layers in the image.
            </summary>
        </member>
        <member name="P:SharpVk.ImageCreateInfo.Samples">
            <summary>
            pname:samples is the number of sub-data element samples in the
            image as defined in elink:VkSampleCountFlagBits. See
            &lt;&lt;primsrast-multisampling,Multisampling&gt;&gt;.
            </summary>
        </member>
        <member name="P:SharpVk.ImageCreateInfo.Tiling">
            <summary>
            pname:tiling is a elink:VkImageTiling specifying the tiling
            arrangement of the data elements in memory, as described below.
            </summary>
        </member>
        <member name="P:SharpVk.ImageCreateInfo.Usage">
            <summary>
            pname:usage is a bitmask describing the intended usage of the
            image. See elink:VkImageUsageFlagBits below for a description of
            the supported bits.
            </summary>
        </member>
        <member name="P:SharpVk.ImageCreateInfo.SharingMode">
            <summary>
            pname:sharingMode is the sharing mode of the image when it will be
            accessed by multiple queue families, and must: be one of the values
            described for elink:VkSharingMode in the
            &lt;&lt;resources-sharing,Resource Sharing&gt;&gt; section below.
            </summary>
        </member>
        <member name="P:SharpVk.ImageCreateInfo.QueueFamilyIndices">
            <summary>
            pname:pQueueFamilyIndices is a list of queue families that will
            access this image (ignored if pname:sharingMode is not
            ename:VK_SHARING_MODE_CONCURRENT).
            </summary>
        </member>
        <member name="P:SharpVk.ImageCreateInfo.InitialLayout">
            <summary>
            pname:initialLayout selects the initial elink:VkImageLayout state
            of all image subresources of the image. See
            &lt;&lt;resources-image-layouts,Image Layouts&gt;&gt;.
            pname:initialLayout must: be ename:VK_IMAGE_LAYOUT_UNDEFINED or
            ename:VK_IMAGE_LAYOUT_PREINITIALIZED.
            </summary>
        </member>
        <member name="T:SharpVk.ImageFormatProperties">
            <summary>
            <para>
            Structure specifying a image format properties.
            </para>
            <para>
            [NOTE] .Note ==== There is no mechanism to query the size of an image
            before creating it, to compare that size against pname:maxResourceSize.
            If an application attempts to create an image that exceeds this limit,
            the creation will fail or the image will be invalid. While the
            advertised limit must: be at least 2^31^, it may: not be possible to
            create an image that approaches that size, particularly for
            ename:VK_IMAGE_TYPE_1D. ====
            </para>
            <para>
            If the combination of parameters to
            fname:vkGetPhysicalDeviceImageFormatProperties is not supported by the
            implementation for use in flink:vkCreateImage, then all members of
            sname:VkImageFormatProperties will be filled with zero.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.ImageFormatProperties.#ctor(SharpVk.Extent3D,System.UInt32,System.UInt32,SharpVk.SampleCountFlags,SharpVk.DeviceSize)">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.ImageFormatProperties.MaxExtent">
            <summary>
            pname:maxExtent are the maximum image dimensions. See the
            &lt;&lt;features-extentperimagetype,Allowed Extent Values&gt;&gt;
            section below for how these values are constrained by pname:type.
            </summary>
        </member>
        <member name="F:SharpVk.ImageFormatProperties.MaxMipLevels">
            <summary>
            pname:maxMipLevels is the maximum number of mipmap levels.
            pname:maxMipLevels must: either be equal to 1 (valid only if
            pname:tiling is ename:VK_IMAGE_TILING_LINEAR) or be equal to
            [eq]#{lceil}log~2~(max(pname:width, pname:height,
            pname:depth)){rceil} {plus} 1#. [eq]#pname:width#,
            [eq]#pname:height#, and [eq]#pname:depth# are taken from the
            corresponding members of pname:maxExtent.
            </summary>
        </member>
        <member name="F:SharpVk.ImageFormatProperties.MaxArrayLayers">
            <summary>
            pname:maxArrayLayers is the maximum number of array layers.
            pname:maxArrayLayers must: either be equal to 1 or be greater than
            or equal to the pname:maxImageArrayLayers member of
            slink:VkPhysicalDeviceLimits. A value of 1 is valid only if
            pname:tiling is ename:VK_IMAGE_TILING_LINEAR or if pname:type is
            ename:VK_IMAGE_TYPE_3D.
            </summary>
        </member>
        <member name="F:SharpVk.ImageFormatProperties.SampleCounts">
            <summary>
            pname:sampleCounts is a bitmask of elink:VkSampleCountFlagBits
            specifying all the supported sample counts for this image as
            described &lt;&lt;features-supported-sample-counts, below&gt;&gt;.
            </summary>
        </member>
        <member name="F:SharpVk.ImageFormatProperties.MaxResourceSize">
            <summary>
            pname:maxResourceSize is an upper bound on the total image size in
            bytes, inclusive of all image subresources. Implementations may:
            have an address space limit on total size of a resource, which is
            advertised by this property. pname:maxResourceSize must: be at
            least 2^31^.
            </summary>
        </member>
        <member name="M:SharpVk.ImageFormatProperties.ToString">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.ImageFormatProperties2">
            <summary>
            <para>
            Structure specifying a image format properties.
            </para>
            <para>
            If the combination of parameters to
            fname:vkGetPhysicalDeviceImageFormatProperties2KHR is not supported by
            the implementation for use in flink:vkCreateImage, then all members of
            pname:imageFormatProperties will be filled with zero.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.ImageFormatProperties2.ImageFormatProperties">
            <summary>
            pname:imageFormatProperties is an instance of a
            slink:VkImageFormatProperties structure in which capabilities are
            returned.
            </summary>
        </member>
        <member name="T:SharpVk.ImageLayout">
            <summary>
            <para>
            Layout of image and image subresources.
            </para>
            <para>
            For each mechanism of accessing an image in the API, there is a
            parameter or structure member that controls the image layout used to
            access the image. For transfer commands, this is a parameter to the
            command (see &lt;&lt;clears&gt;&gt; and &lt;&lt;copies&gt;&gt;). For
            use as a framebuffer attachment, this is a member in the substructures
            of the sname:VkRenderPassCreateInfo (see &lt;&lt;renderpass,Render
            Pass&gt;&gt;). For use in a descriptor set, this is a member in the
            sname:VkDescriptorImageInfo structure (see
            &lt;&lt;descriptorsets-updates&gt;&gt;). At the time that any command
            buffer command accessing an image executes on any queue, the layouts of
            the image subresources that are accessed must: all match the layout
            specified via the API controlling those accesses.
            </para>
            <para>
            The image layout of each image subresource must: be well-defined at
            each point in the image subresource's lifetime. This means that when
            performing a layout transition on the image subresource, the old layout
            value must: either equal the current layout of the image subresource
            (at the time the transition executes), or else be
            ename:VK_IMAGE_LAYOUT_UNDEFINED (implying that the contents of the
            image subresource need not be preserved). The new layout used in a
            transition must: not be ename:VK_IMAGE_LAYOUT_UNDEFINED or
            ename:VK_IMAGE_LAYOUT_PREINITIALIZED.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ImageLayout.Undefined">
            <summary>
            ename:VK_IMAGE_LAYOUT_UNDEFINED: Supports no device access. This
            layout must: only be used as the pname:initialLayout member of
            sname:VkImageCreateInfo or sname:VkAttachmentDescription, or as the
            pname:oldLayout in an image transition. When transitioning out of
            this layout, the contents of the memory are not guaranteed to be
            preserved.
            </summary>
        </member>
        <member name="F:SharpVk.ImageLayout.General">
            <summary>
            ename:VK_IMAGE_LAYOUT_GENERAL: Supports all types of device access.
            </summary>
        </member>
        <member name="F:SharpVk.ImageLayout.ColorAttachmentOptimal">
            <summary>
            ename:VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL: must: only be used
            as a color or resolve attachment in a sname:VkFramebuffer. This
            layout is valid only for image subresources of images created with
            the ename:VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT usage bit enabled.
            </summary>
        </member>
        <member name="F:SharpVk.ImageLayout.DepthStencilAttachmentOptimal">
            <summary>
            ename:VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL: must: only
            be used as a depth/stencil attachment in a sname:VkFramebuffer.
            This layout is valid only for image subresources of images created
            with the ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT usage
            bit enabled.
            </summary>
        </member>
        <member name="F:SharpVk.ImageLayout.DepthStencilReadOnlyOptimal">
            <summary>
            ename:VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL: must: only
            be used as a read-only depth/stencil attachment in a
            sname:VkFramebuffer and/or as a read-only image in a shader (which
            can: be read as a sampled image, combined image/sampler and/or
            input attachment). This layout is valid only for image subresources
            of images created with the
            ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT usage bit
            enabled. Only image subresources of images created with
            ename:VK_IMAGE_USAGE_SAMPLED_BIT can: be used as sampled image or
            combined image/sampler in a shader. Similarly, only image
            subresources of images created with
            ename:VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT can: be used as input
            attachments.
            </summary>
        </member>
        <member name="F:SharpVk.ImageLayout.ShaderReadOnlyOptimal">
            <summary>
            ename:VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL: must: only be used
            as a read-only image in a shader (which can: be read as a sampled
            image, combined image/sampler and/or input attachment). This layout
            is valid only for image subresources of images created with the
            ename:VK_IMAGE_USAGE_SAMPLED_BIT or
            ename:VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT usage bit enabled.
            </summary>
        </member>
        <member name="F:SharpVk.ImageLayout.TransferSourceOptimal">
            <summary>
            ename:VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL: must: only be used as a
            source image of a transfer command (see the definition of
            &lt;&lt;synchronization-pipeline-stages-transfer, ename:VK_PIPELINE_STAGE_TRANSFER_BIT&gt;&gt;).
            This layout is valid only for image subresources of images created
            with the ename:VK_IMAGE_USAGE_TRANSFER_SRC_BIT usage bit enabled.
            </summary>
        </member>
        <member name="F:SharpVk.ImageLayout.TransferDestinationOptimal">
            <summary>
            ename:VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL: must: only be used as a
            destination image of a transfer command. This layout is valid only
            for image subresources of images created with the
            ename:VK_IMAGE_USAGE_TRANSFER_DST_BIT usage bit enabled.
            ifdef::VK_KHR_swapchain[]
            </summary>
        </member>
        <member name="F:SharpVk.ImageLayout.Preinitialized">
            <summary>
            ename:VK_IMAGE_LAYOUT_PREINITIALIZED: Supports no device access.
            This layout must: only be used as the pname:initialLayout member of
            sname:VkImageCreateInfo or sname:VkAttachmentDescription, or as the
            pname:oldLayout in an image transition. When transitioning out of
            this layout, the contents of the memory are preserved. This layout
            is intended to be used as the initial layout for an image whose
            contents are written by the host, and hence the data can: be
            written to memory immediately, without first executing a layout
            transition. Currently, ename:VK_IMAGE_LAYOUT_PREINITIALIZED is only
            useful with ename:VK_IMAGE_TILING_LINEAR images because there is
            not a standard layout defined for ename:VK_IMAGE_TILING_OPTIMAL
            images.
            </summary>
        </member>
        <member name="F:SharpVk.ImageLayout.PresentSource">
            <summary>
            ename:VK_IMAGE_LAYOUT_PRESENT_SRC_KHR: must: only be used for
            presenting a presentable image for display. A swapchain's image
            must: be transitioned to this layout before calling
            flink:vkQueuePresentKHR, and must: be transitioned away from this
            layout after calling flink:vkAcquireNextImageKHR.
            endif::VK_KHR_swapchain[]
            </summary>
        </member>
        <member name="T:SharpVk.ImageMemoryBarrier">
            <summary>
            <para>
            Structure specifying the parameters of an image memory barrier.
            </para>
            <para>
            The first &lt;&lt;synchronization-dependencies-access-scopes, access
            scope&gt;&gt; is limited to access to memory through the specified
            image subresource range, via access types in the
            &lt;&lt;synchronization-access-masks, source access mask&gt;&gt;
            specified by pname:srcAccessMask. If pname:srcAccessMask includes
            ename:VK_ACCESS_HOST_WRITE_BIT, memory writes performed by that access
            type are also made visible, as that access type is not performed
            through a resource.
            </para>
            <para>
            The second &lt;&lt;synchronization-dependencies-access-scopes, access
            scope&gt;&gt; is limited to access to memory through the specified
            image subresource range, via access types in the
            &lt;&lt;synchronization-access-masks, destination access mask&gt;&gt;
            specified by pname:dstAccessMask. If pname:dstAccessMask includes
            ename:VK_ACCESS_HOST_WRITE_BIT or ename:VK_ACCESS_HOST_READ_BIT,
            available memory writes are also made visible to accesses of those
            types, as those access types are not performed through a resource.
            </para>
            <para>
            If pname:srcQueueFamilyIndex is not equal to pname:dstQueueFamilyIndex,
            and pname:srcQueueFamilyIndex is equal to the current queue family,
            then the memory barrier defines a
            &lt;&lt;synchronization-queue-transfers-release, queue family release
            operation&gt;&gt; for the specified image subresource range, and the
            second access scope includes no access, as if pname:dstAccessMask was
            `0`.
            </para>
            <para>
            If pname:dstQueueFamilyIndex is not equal to pname:srcQueueFamilyIndex,
            and pname:dstQueueFamilyIndex is equal to the current queue family,
            then the memory barrier defines a
            &lt;&lt;synchronization-queue-transfers-acquire, queue family acquire
            operation&gt;&gt; for the specified image subresource range, and the
            first access scope includes no access, as if pname:srcAccessMask was
            `0`.
            </para>
            <para>
            If pname:oldLayout is not equal to pname:newLayout, then the memory
            barrier defines an &lt;&lt;synchronization-image-layout-transitions,
            image layout transition&gt;&gt; for the specified image subresource
            range.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.ImageMemoryBarrier.SourceAccessMask">
            <summary>
            pname:srcAccessMask defines a &lt;&lt;synchronization-access-masks,
            source access mask&gt;&gt;.
            </summary>
        </member>
        <member name="P:SharpVk.ImageMemoryBarrier.DestinationAccessMask">
            <summary>
            pname:dstAccessMask defines a &lt;&lt;synchronization-access-masks,
            destination access mask&gt;&gt;.
            </summary>
        </member>
        <member name="P:SharpVk.ImageMemoryBarrier.OldLayout">
            <summary>
            pname:oldLayout is the old layout in an
            &lt;&lt;synchronization-image-layout-transitions, image layout
            transition&gt;&gt;.
            </summary>
        </member>
        <member name="P:SharpVk.ImageMemoryBarrier.NewLayout">
            <summary>
            pname:newLayout is the new layout in an
            &lt;&lt;synchronization-image-layout-transitions, image layout
            transition&gt;&gt;.
            </summary>
        </member>
        <member name="P:SharpVk.ImageMemoryBarrier.SourceQueueFamilyIndex">
            <summary>
            pname:srcQueueFamilyIndex is the source queue family for a
            &lt;&lt;synchronization-queue-transfers, queue family ownership
            transfer&gt;&gt;.
            </summary>
        </member>
        <member name="P:SharpVk.ImageMemoryBarrier.DestinationQueueFamilyIndex">
            <summary>
            pname:dstQueueFamilyIndex is the destination queue family for a
            &lt;&lt;synchronization-queue-transfers, queue family ownership
            transfer&gt;&gt;.
            </summary>
        </member>
        <member name="P:SharpVk.ImageMemoryBarrier.Image">
            <summary>
            pname:image is a handle to the image affected by this barrier.
            </summary>
        </member>
        <member name="P:SharpVk.ImageMemoryBarrier.SubresourceRange">
            <summary>
            pname:subresourceRange describes the &lt;&lt;resources-image-views,
            image subresource range&gt;&gt; within pname:image that is affected
            by this barrier.
            </summary>
        </member>
        <member name="T:SharpVk.ImageResolve">
            <summary>
            Structure specifying an image resolve operation.
            </summary>
        </member>
        <member name="M:SharpVk.ImageResolve.#ctor(SharpVk.ImageSubresourceLayers,SharpVk.Offset3D,SharpVk.ImageSubresourceLayers,SharpVk.Offset3D,SharpVk.Extent3D)">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.ImageResolve.SourceSubresource">
            <summary>
            pname:srcSubresource and pname:dstSubresource are
            slink:VkImageSubresourceLayers structures specifying the image
            subresources of the images used for the source and destination
            image data, respectively. Resolve of depth/stencil images is not
            supported.
            </summary>
        </member>
        <member name="F:SharpVk.ImageResolve.SourceOffset">
            <summary>
            pname:srcOffset and pname:dstOffset select the initial x, y, and z
            offsets in texels of the sub-regions of the source and destination
            image data.
            </summary>
        </member>
        <member name="F:SharpVk.ImageResolve.DestinationSubresource">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.ImageResolve.DestinationOffset">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.ImageResolve.Extent">
            <summary>
            pname:extent is the size in texels of the source image to resolve
            in pname:width, pname:height and pname:depth.
            </summary>
        </member>
        <member name="M:SharpVk.ImageResolve.ToString">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.ImageSubresource">
            <summary>
            Structure specifying a image subresource.
            </summary>
        </member>
        <member name="M:SharpVk.ImageSubresource.#ctor(SharpVk.ImageAspectFlags,System.UInt32,System.UInt32)">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.ImageSubresource.AspectMask">
            <summary>
            pname:aspectMask is a elink:VkImageAspectFlags selecting the image
            _aspect_.
            </summary>
        </member>
        <member name="F:SharpVk.ImageSubresource.MipLevel">
            <summary>
            pname:mipLevel selects the mipmap level.
            </summary>
        </member>
        <member name="F:SharpVk.ImageSubresource.ArrayLayer">
            <summary>
            pname:arrayLayer selects the array layer.
            </summary>
        </member>
        <member name="M:SharpVk.ImageSubresource.ToString">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.ImageSubresourceLayers">
            <summary>
            Structure specifying a image subresource layers.
            </summary>
        </member>
        <member name="M:SharpVk.ImageSubresourceLayers.#ctor(SharpVk.ImageAspectFlags,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.ImageSubresourceLayers.AspectMask">
            <summary>
            pname:aspectMask is a combination of elink:VkImageAspectFlagBits,
            selecting the color, depth and/or stencil aspects to be copied.
            </summary>
        </member>
        <member name="F:SharpVk.ImageSubresourceLayers.MipLevel">
            <summary>
            pname:mipLevel is the mipmap level to copy from.
            </summary>
        </member>
        <member name="F:SharpVk.ImageSubresourceLayers.BaseArrayLayer">
            <summary>
            pname:baseArrayLayer and pname:layerCount are the starting layer
            and number of layers to copy.
            </summary>
        </member>
        <member name="F:SharpVk.ImageSubresourceLayers.LayerCount">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.ImageSubresourceLayers.ToString">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.ImageSubresourceRange">
            <summary>
            <para>
            Structure specifying a image subresource range.
            </para>
            <para>
            The number of mipmap levels and array layers must: be a subset of the
            image subresources in the image. If an application wants to use all mip
            levels or layers in an image after the pname:baseMipLevel or
            pname:baseArrayLayer, it can: set pname:levelCount and pname:layerCount
            to the special values ename:VK_REMAINING_MIP_LEVELS and
            ename:VK_REMAINING_ARRAY_LAYERS without knowing the exact number of mip
            levels or layers.
            </para>
            <para>
            For cube and cube array image views, the layers of the image view
            starting at pname:baseArrayLayer correspond to faces in the order +X,
            -X, +Y, -Y, +Z, -Z. For cube arrays, each set of six sequential layers
            is a single cube, so the number of cube maps in a cube map array view
            is _pname:layerCount / 6_, and image array layer _pname:baseArrayLayer
            + i_ is face index _i mod 6_ of cube _i / 6_. If the number of layers
            in the view, whether set explicitly in pname:layerCount or implied by
            ename:VK_REMAINING_ARRAY_LAYERS, is not a multiple of 6, behavior when
            indexing the last cube is undefined.
            </para>
            <para>
            pname:aspectMask is a bitmask indicating the format being used. Bits
            which may: be set include:
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.ImageSubresourceRange.#ctor(SharpVk.ImageAspectFlags,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.ImageSubresourceRange.AspectMask">
            <summary>
            pname:aspectMask is a bitmask indicating which aspect(s) of the
            image are included in the view. See elink:VkImageAspectFlagBits.
            </summary>
        </member>
        <member name="F:SharpVk.ImageSubresourceRange.BaseMipLevel">
            <summary>
            pname:baseMipLevel is the first mipmap level accessible to the
            view.
            </summary>
        </member>
        <member name="F:SharpVk.ImageSubresourceRange.LevelCount">
            <summary>
            pname:levelCount is the number of mipmap levels (starting from
            pname:baseMipLevel) accessible to the view.
            </summary>
        </member>
        <member name="F:SharpVk.ImageSubresourceRange.BaseArrayLayer">
            <summary>
            pname:baseArrayLayer is the first array layer accessible to the
            view.
            </summary>
        </member>
        <member name="F:SharpVk.ImageSubresourceRange.LayerCount">
            <summary>
            pname:layerCount is the number of array layers (starting from
            pname:baseArrayLayer) accessible to the view.
            </summary>
        </member>
        <member name="M:SharpVk.ImageSubresourceRange.ToString">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.ImageTiling">
            <summary>
            <para>
            Specifies the tiling arrangement of data in an image.
            </para>
            <para>
            ename:VK_IMAGE_TILING_OPTIMAL specifies optimal tiling (texels are laid
            out in an implementation-dependent arrangement, for more optimal memory
            access), and ename:VK_IMAGE_TILING_LINEAR specifies linear tiling
            (texels are laid out in memory in row-major order, possibly with some
            padding on each row).
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ImageTiling.Optimal">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.ImageTiling.Linear">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.ImageType">
            <summary>
            <para>
            Specifies the type of an image object.
            </para>
            <para>
            These values specify one-, two-, or three-dimensional images,
            respectively.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ImageType.Image1d">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.ImageType.Image2d">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.ImageType.Image3d">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.ImageUsageFlags">
            <summary>
            Bitmask specifying intended usage of an image.
            </summary>
        </member>
        <member name="F:SharpVk.ImageUsageFlags.None">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.ImageUsageFlags.TransferSource">
            <summary>
            ename:VK_IMAGE_USAGE_TRANSFER_SRC_BIT indicates that the image can:
            be used as the source of a transfer command.
            </summary>
        </member>
        <member name="F:SharpVk.ImageUsageFlags.TransferDestination">
            <summary>
            ename:VK_IMAGE_USAGE_TRANSFER_DST_BIT indicates that the image can:
            be used as the destination of a transfer command.
            </summary>
        </member>
        <member name="F:SharpVk.ImageUsageFlags.Sampled">
            <summary>
            ename:VK_IMAGE_USAGE_SAMPLED_BIT indicates that the image can: be
            used to create a sname:VkImageView suitable for occupying a
            sname:VkDescriptorSet slot either of type
            ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE or
            ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, and be sampled by
            a shader.
            </summary>
        </member>
        <member name="F:SharpVk.ImageUsageFlags.Storage">
            <summary>
            ename:VK_IMAGE_USAGE_STORAGE_BIT indicates that the image can: be
            used to create a sname:VkImageView suitable for occupying a
            sname:VkDescriptorSet slot of type
            ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE.
            </summary>
        </member>
        <member name="F:SharpVk.ImageUsageFlags.ColorAttachment">
            <summary>
            ename:VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT indicates that the image
            can: be used to create a sname:VkImageView suitable for use as a
            color or resolve attachment in a sname:VkFramebuffer.
            </summary>
        </member>
        <member name="F:SharpVk.ImageUsageFlags.DepthStencilAttachment">
            <summary>
            ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT indicates that
            the image can: be used to create a sname:VkImageView suitable for
            use as a depth/stencil attachment in a sname:VkFramebuffer.
            </summary>
        </member>
        <member name="F:SharpVk.ImageUsageFlags.TransientAttachment">
            <summary>
            ename:VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT indicates that the
            memory bound to this image will have been allocated with the
            ename:VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT (see
            &lt;&lt;memory&gt;&gt; for more detail). This bit can: be set for
            any image that can: be used to create a sname:VkImageView suitable
            for use as a color, resolve, depth/stencil, or input attachment.
            </summary>
        </member>
        <member name="F:SharpVk.ImageUsageFlags.InputAttachment">
            <summary>
            ename:VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT indicates that the image
            can: be used to create a sname:VkImageView suitable for occupying
            sname:VkDescriptorSet slot of type
            ename:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT; be read from a shader as
            an input attachment; and be used as an input attachment in a
            framebuffer.
            </summary>
        </member>
        <member name="T:SharpVk.ImageView">
            <summary>
            <para>
            Opaque handle to a image view object.
            </para>
            <para>
            Image objects are not directly accessed by pipeline shaders for reading
            or writing image data. Instead, _image views_ representing contiguous
            ranges of the image subresources and containing additional metadata are
            used for that purpose. Views must: be created on images of compatible
            types, and must: represent a valid subset of image subresources.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.ImageView.Destroy">
            <summary>
            Destroy an image view object.
            </summary>
        </member>
        <member name="P:SharpVk.ImageView.RawHandle">
            <summary>
            The interop handle for this ImageView.
            </summary>
        </member>
        <member name="M:SharpVk.ImageView.Dispose">
            <summary>
            Releases the unmanaged resources associated with this instance and
            destroys the underlying Vulkan handle.
            </summary>
        </member>
        <member name="T:SharpVk.ImageViewCreateFlags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.ImageViewCreateFlags.None">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.ImageViewCreateInfo">
            <summary>
            <para>
            Structure specifying parameters of a newly created image view.
            </para>
            <para>
            If pname:image was created with the
            ename:VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT flag, pname:format can: be
            different from the image's format, but if they are not equal they must:
            be _compatible_. Image format compatibility is defined in the
            &lt;&lt;features-formats-compatibility-classes,Format Compatibility
            Classes&gt;&gt; section.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.ImageViewCreateInfo.Flags">
            <summary>
            pname:flags is reserved for future use.
            </summary>
        </member>
        <member name="P:SharpVk.ImageViewCreateInfo.Image">
            <summary>
            pname:image is a sname:VkImage on which the view will be created.
            </summary>
        </member>
        <member name="P:SharpVk.ImageViewCreateInfo.ViewType">
            <summary>
            pname:viewType is the type of the image view.
            </summary>
        </member>
        <member name="P:SharpVk.ImageViewCreateInfo.Format">
            <summary>
            pname:format is a elink:VkFormat describing the format and type
            used to interpret data elements in the image.
            </summary>
        </member>
        <member name="P:SharpVk.ImageViewCreateInfo.Components">
            <summary>
            pname:components specifies a remapping of color components (or of
            depth or stencil components after they have been converted into
            color components). See slink:VkComponentMapping.
            </summary>
        </member>
        <member name="P:SharpVk.ImageViewCreateInfo.SubresourceRange">
            <summary>
            pname:subresourceRange is a slink:VkImageSubresourceRange selecting
            the set of mipmap levels and array layers to be accessible to the
            view.
            </summary>
        </member>
        <member name="T:SharpVk.ImageViewType">
            <summary>
            <para>
            Image view types.
            </para>
            <para>
            The exact image view type is partially implicit, based on the image's
            type and sample count, as well as the view creation parameters as
            described in the &lt;&lt;resources-image-views-compatibility,table
            below&gt;&gt;. This table also shows which SPIR-V OpTypeImage Dim and
            Arrayed parameters correspond to each image view type.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ImageViewType.ImageView1d">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.ImageViewType.ImageView2d">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.ImageViewType.ImageView3d">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.ImageViewType.Cube">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.ImageViewType.ImageView1dArray">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.ImageViewType.ImageView2dArray">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.ImageViewType.CubeArray">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.ImportMemoryWin32HandleInfo">
            <summary>
            <para>
            Import Win32 memory created on the same physical device.
            </para>
            <para>
            To import memory created on the same physical device but outside of the
            current Vulkan instance, add a slink:VkImportMemoryWin32HandleInfoNV
            structure to the pname:pNext chain of the slink:VkMemoryAllocateInfo
            structure, specifying a handle to and the type of the memory.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.ImportMemoryWin32HandleInfo.HandleType">
            <summary>
            pname:handleType is 0 or a flag specifying the type of memory
            handle in pname:handle. Flags which may: be specified are: + --
            </summary>
        </member>
        <member name="P:SharpVk.ImportMemoryWin32HandleInfo.Handle">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.IndexType">
            <summary>
            Type of index buffer indices.
            </summary>
        </member>
        <member name="F:SharpVk.IndexType.UInt16">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.IndexType.UInt32">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.IndirectCommandsLayout">
            <summary>
            Opaque handle to an indirect commands layout object.
            </summary>
        </member>
        <member name="M:SharpVk.IndirectCommandsLayout.Destroy">
            <summary>
            Destroy a object table.
            </summary>
        </member>
        <member name="P:SharpVk.IndirectCommandsLayout.RawHandle">
            <summary>
            The interop handle for this IndirectCommandsLayout.
            </summary>
        </member>
        <member name="M:SharpVk.IndirectCommandsLayout.Dispose">
            <summary>
            Releases the unmanaged resources associated with this instance and
            destroys the underlying Vulkan handle.
            </summary>
        </member>
        <member name="T:SharpVk.IndirectCommandsLayoutCreateInfo">
            <summary>
            Structure specifying the parameters of a newly created indirect
            commands layout object.
            </summary>
        </member>
        <member name="P:SharpVk.IndirectCommandsLayoutCreateInfo.PipelineBindPoint">
            <summary>
            pname:pipelineBindPoint is the sname:VkPipelineBindPoint that this
            layout targets.
            </summary>
        </member>
        <member name="P:SharpVk.IndirectCommandsLayoutCreateInfo.Flags">
            <summary>
            pname:flags is a bitmask providing usage hints of this layout. See
            elink:VkIndirectCommandsLayoutUsageFlagBitsNVX below for a
            description of the supported bits.
            </summary>
        </member>
        <member name="P:SharpVk.IndirectCommandsLayoutCreateInfo.Tokens">
            <summary>
            pname:pTokens is an array describing each command token in detail.
            See elink:VkIndirectCommandsTokenTypeNVX and
            slink:VkIndirectCommandsLayoutTokenNVX below for details.
            </summary>
        </member>
        <member name="T:SharpVk.IndirectCommandsLayoutToken">
            <summary>
            <para>
            Struct specifying the details of an indirect command layout token.
            </para>
            <para>
            * pname:type specifies the token command type. * pname:bindingUnit has
            a different meaning depending on the type, please refer pseudo code
            further down for details. * pname:dynamicCount has a different meaning
            depending on the type, please refer pseudo code further down for
            details. * pname:divisor defines the rate at which the input data
            buffers are accessed.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.IndirectCommandsLayoutToken.#ctor(SharpVk.IndirectCommandsTokenType,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.IndirectCommandsLayoutToken.TokenType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.IndirectCommandsLayoutToken.BindingUnit">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.IndirectCommandsLayoutToken.DynamicCount">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.IndirectCommandsLayoutToken.Divisor">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.IndirectCommandsLayoutToken.ToString">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.IndirectCommandsLayoutUsageFlags">
            <summary>
            <para>
            Bitmask specifying allowed usage of a indirect commands layout.
            </para>
            <para>
            The following code illustrates some of the key flags:
            </para>
            <para>
            [source,c] --------------------------------------------------- void
            cmdProcessAllSequences(cmd, objectTable, indirectCommandsLayout,
            pIndirectCommandsTokens, sequencesCount, indexbuffer,
            indexbufferoffset) { for (s = 0; s &lt; sequencesCount; s++) { sequence
            = s;
            </para>
            <para>
            if (indirectCommandsLayout.flags &amp;
            VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NVX) {
            sequence = incoherent_implementation_dependent_permutation[ sequence ];
            } if (indirectCommandsLayout.flags &amp;
            VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NVX) { sequence
            = indexbuffer.load_uint32( sequence * sizeof(uint32_t) +
            indexbufferoffset); }
            </para>
            <para>
            cmdProcessSequence( cmd, objectTable, indirectCommandsLayout,
            pIndirectCommandsTokens, sequence ); } }
            ---------------------------------------------------
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.IndirectCommandsLayoutUsageFlags.None">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.IndirectCommandsLayoutUsageFlags.UnorderedSequences">
            <summary>
            ename:VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NVX
            indicates that the processing of sequences can: happen at an
            implementation-dependent order, which is not guaranteed to be
            coherent across multiple invocations.
            </summary>
        </member>
        <member name="F:SharpVk.IndirectCommandsLayoutUsageFlags.SparseSequences">
            <summary>
            ename:VK_INDIRECT_COMMANDS_LAYOUT_USAGE_SPARSE_SEQUENCES_BIT_NVX
            indicates that there is likely a high difference between allocated
            number of sequences and actually used.
            </summary>
        </member>
        <member name="F:SharpVk.IndirectCommandsLayoutUsageFlags.EmptyExecutions">
            <summary>
            ename:VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EMPTY_EXECUTIONS_BIT_NVX
            indicates that there is likely many draw or dispatch calls that are
            zero-sized (zero grid dimension, no primitives to render).
            </summary>
        </member>
        <member name="F:SharpVk.IndirectCommandsLayoutUsageFlags.IndexedSequences">
            <summary>
            ename:VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NVX
            indicates that the input data for the sequences is not implicitly
            indexed from 0..sequencesUsed but a user provided sname:VkBuffer
            encoding the index is provided.
            </summary>
        </member>
        <member name="T:SharpVk.IndirectCommandsToken">
            <summary>
            Structure specifying parameters for the reservation of command buffer
            space.
            </summary>
        </member>
        <member name="P:SharpVk.IndirectCommandsToken.TokenType">
            <summary>
            pname:tokenType specifies the token command type.
            </summary>
        </member>
        <member name="P:SharpVk.IndirectCommandsToken.Buffer">
            <summary>
            pname:buffer specifies the sname:VkBuffer storing the functional
            arguments for each squence. These argumetns can be written by the
            device.
            </summary>
        </member>
        <member name="P:SharpVk.IndirectCommandsToken.Offset">
            <summary>
            pname:offset specified an offset into pname:buffer where the
            arguments start.
            </summary>
        </member>
        <member name="T:SharpVk.IndirectCommandsTokenType">
            <summary>
            <para>
            Enum specifying.
            </para>
            <para>
            .Supported indirect command tokens
            [width="80%",cols="67%,33%",options="header",align="center"] |====
            |Token type | Equivalent command
            |ename:VK_INDIRECT_COMMANDS_TOKEN_PIPELINE_NVX |
            fname:vkCmdBindPipeline |ename:VK_INDIRECT_COMMANDS_TOKEN_DESCRIPTOR_SET_NVX
            | fname:vkCmdBindDescriptorSets
            |ename:VK_INDIRECT_COMMANDS_TOKEN_INDEX_BUFFER_NVX |
            fname:vkCmdBindIndexBuffer |ename:VK_INDIRECT_COMMANDS_TOKEN_VERTEX_BUFFER_NVX
            | fname:vkCmdBindVertexBuffers
            |ename:VK_INDIRECT_COMMANDS_TOKEN_PUSH_CONSTANT_NVX |
            fname:vkCmdPushConstants |ename:VK_INDIRECT_COMMANDS_TOKEN_DRAW_INDEXED_NVX
            | fname:vkCmdDrawIndexedIndirect
            |ename:VK_INDIRECT_COMMANDS_TOKEN_DRAW_NVX | fname:vkCmdDrawIndirect
            |ename:VK_INDIRECT_COMMANDS_TOKEN_DISPATCH_NVX |
            fname:vkCmdDispatchIndirect |====
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.IndirectCommandsTokenType.Pipeline">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.IndirectCommandsTokenType.DescriptorSet">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.IndirectCommandsTokenType.IndexBuffer">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.IndirectCommandsTokenType.VertexBuffer">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.IndirectCommandsTokenType.PushConstant">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.IndirectCommandsTokenType.DrawIndexed">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.IndirectCommandsTokenType.Draw">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.IndirectCommandsTokenType.Dispatch">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Instance">
            <summary>
            <para>
            Opaque handle to a instance object.
            </para>
            <para>
            There is no global state in Vulkan and all per-application state is
            stored in a sname:VkInstance object. Creating a sname:VkInstance object
            initializes the Vulkan library and allows the application to pass
            information about itself to the implementation.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Instance.Create(SharpVk.InstanceCreateInfo,System.Nullable{SharpVk.AllocationCallbacks})">
            <summary>
            Create a new Vulkan instance.
            </summary>
        </member>
        <member name="M:SharpVk.Instance.Destroy">
            <summary>
            Destroy an instance of Vulkan.
            </summary>
        </member>
        <member name="M:SharpVk.Instance.EnumeratePhysicalDevices">
            <summary>
            Enumerates the physical devices accessible to a Vulkan instance.
            </summary>
        </member>
        <member name="M:SharpVk.Instance.GetProcedureAddress(System.String)">
            <summary>
            Return a function pointer for a command.
            </summary>
        </member>
        <member name="M:SharpVk.Instance.EnumerateExtensionProperties(System.String)">
            <summary>
            Returns up to requested number of global extension properties.
            </summary>
        </member>
        <member name="M:SharpVk.Instance.EnumerateLayerProperties">
            <summary>
            Returns up to requested number of global layer properties.
            </summary>
        </member>
        <member name="M:SharpVk.Instance.CreateDisplayPlaneSurface(SharpVk.DisplaySurfaceCreateInfo)">
            <summary>
            Create a slink:VkSurfaceKHR structure representing a display plane
            and mode.
            </summary>
        </member>
        <member name="M:SharpVk.Instance.CreateXlibSurface(SharpVk.XlibSurfaceCreateInfo)">
            <summary>
            Create a slink:VkSurfaceKHR object for an X11 window, using the
            Xlib client-side library.
            </summary>
        </member>
        <member name="M:SharpVk.Instance.CreateXcbSurface(SharpVk.XcbSurfaceCreateInfo)">
            <summary>
            Create a slink:VkSurfaceKHR object for a X11 window, using the XCB
            client-side library.
            </summary>
        </member>
        <member name="M:SharpVk.Instance.CreateWaylandSurface(SharpVk.WaylandSurfaceCreateInfo)">
            <summary>
            Create a slink:VkSurfaceKHR object for a Wayland window.
            </summary>
        </member>
        <member name="M:SharpVk.Instance.CreateMirSurface(SharpVk.MirSurfaceCreateInfo)">
            <summary>
            Create a slink:VkSurfaceKHR object for a Mir window.
            </summary>
        </member>
        <member name="M:SharpVk.Instance.CreateAndroidSurface(SharpVk.AndroidSurfaceCreateInfo)">
            <summary>
            Create a slink:VkSurfaceKHR object for an Android native window.
            </summary>
        </member>
        <member name="M:SharpVk.Instance.CreateWin32Surface(SharpVk.Win32SurfaceCreateInfo)">
            <summary>
            Create a slink:VkSurfaceKHR object for an Win32 native window.
            </summary>
        </member>
        <member name="M:SharpVk.Instance.CreateDebugReportCallback(SharpVk.DebugReportCallbackCreateInfo)">
            <summary>
            Create a debug report callback object.
            </summary>
        </member>
        <member name="M:SharpVk.Instance.DebugReportMessage(SharpVk.DebugReportFlags,SharpVk.DebugReportObjectType,System.UInt64,SharpVk.Size,System.Int32,System.String,System.String)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Instance.CreateViSurface(SharpVk.ViSurfaceCreateInfo)">
            <summary>
            Create a slink:VkSurfaceKHR object for a VI layer.
            </summary>
        </member>
        <member name="P:SharpVk.Instance.RawHandle">
            <summary>
            The interop handle for this Instance.
            </summary>
        </member>
        <member name="M:SharpVk.Instance.Dispose">
            <summary>
            Releases the unmanaged resources associated with this instance and
            destroys the underlying Vulkan handle.
            </summary>
        </member>
        <member name="T:SharpVk.InstanceCreateFlags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.InstanceCreateFlags.None">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.InstanceCreateInfo">
            <summary>
            Structure specifying parameters of a newly created instance.
            </summary>
        </member>
        <member name="P:SharpVk.InstanceCreateInfo.Flags">
            <summary>
            pname:flags is reserved for future use.
            </summary>
        </member>
        <member name="P:SharpVk.InstanceCreateInfo.ApplicationInfo">
            <summary>
            pname:pApplicationInfo is `NULL` or a pointer to an instance of
            sname:VkApplicationInfo. If not `NULL`, this information helps
            implementations recognize behavior inherent to classes of
            applications. slink:VkApplicationInfo is defined in detail below.
            </summary>
        </member>
        <member name="P:SharpVk.InstanceCreateInfo.EnabledLayerNames">
            <summary>
            pname:ppEnabledLayerNames is a pointer to an array of
            pname:enabledLayerCount null-terminated UTF-8 strings containing
            the names of layers to enable for the created instance. See the
            &lt;&lt;extended-functionality-layers,Layers&gt;&gt; section for
            further details.
            </summary>
        </member>
        <member name="P:SharpVk.InstanceCreateInfo.EnabledExtensionNames">
            <summary>
            pname:ppEnabledExtensionNames is a pointer to an array of
            pname:enabledExtensionCount null-terminated UTF-8 strings
            containing the names of extensions to enable.
            </summary>
        </member>
        <member name="T:SharpVk.InternalAllocationType">
            <summary>
            Allocation type.
            </summary>
        </member>
        <member name="F:SharpVk.InternalAllocationType.Executable">
            <summary>
            ename:VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE - The allocation is
            intended for execution by the host.
            </summary>
        </member>
        <member name="T:SharpVk.Interop.AllocationCallbacks">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.AllocationCallbacks.UserData">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.AllocationCallbacks.PfnAllocation">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.AllocationCallbacks.PfnReallocation">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.AllocationCallbacks.PfnFree">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.AllocationCallbacks.PfnInternalAllocation">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.AllocationCallbacks.PfnInternalFree">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.AndroidSurfaceCreateInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.AndroidSurfaceCreateInfo.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.AndroidSurfaceCreateInfo.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.AndroidSurfaceCreateInfo.Flags">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.AndroidSurfaceCreateInfo.Window">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.ApplicationInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ApplicationInfo.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ApplicationInfo.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ApplicationInfo.ApplicationName">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ApplicationInfo.ApplicationVersion">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ApplicationInfo.EngineName">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ApplicationInfo.EngineVersion">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ApplicationInfo.ApiVersion">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.BindSparseInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.BindSparseInfo.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.BindSparseInfo.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.BindSparseInfo.WaitSemaphoreCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.BindSparseInfo.WaitSemaphores">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.BindSparseInfo.BufferBindCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.BindSparseInfo.BufferBinds">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.BindSparseInfo.ImageOpaqueBindCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.BindSparseInfo.ImageOpaqueBinds">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.BindSparseInfo.ImageBindCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.BindSparseInfo.ImageBinds">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.BindSparseInfo.SignalSemaphoreCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.BindSparseInfo.SignalSemaphores">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.Buffer">
            <summary>
            <para>
            Opaque handle to a buffer object.
            </para>
            <para>
            Buffers represent linear arrays of data which are used for various
            purposes by binding them to a graphics or compute pipeline via
            descriptor sets or via certain commands, or by directly specifying them
            as parameters to certain commands.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Buffer.#ctor(System.UInt64)">
            <summary>
            
            </summary>
        </member>
        <member name="P:SharpVk.Interop.Buffer.Null">
            <summary>
            A read-only property that returns a null Buffer handle.
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Buffer.ToUInt64">
            <summary>
            Returns the marshalled value of this handle as an unsigned 64-bit
            integer.
            </summary>
        </member>
        <member name="T:SharpVk.Interop.BufferCreateInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.BufferCreateInfo.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.BufferCreateInfo.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.BufferCreateInfo.Flags">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.BufferCreateInfo.Size">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.BufferCreateInfo.Usage">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.BufferCreateInfo.SharingMode">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.BufferCreateInfo.QueueFamilyIndexCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.BufferCreateInfo.QueueFamilyIndices">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.BufferMemoryBarrier">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.BufferMemoryBarrier.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.BufferMemoryBarrier.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.BufferMemoryBarrier.SourceAccessMask">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.BufferMemoryBarrier.DestinationAccessMask">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.BufferMemoryBarrier.SourceQueueFamilyIndex">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.BufferMemoryBarrier.DestinationQueueFamilyIndex">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.BufferMemoryBarrier.Buffer">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.BufferMemoryBarrier.Offset">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.BufferMemoryBarrier.Size">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.BufferView">
            <summary>
            <para>
            Opaque handle to a buffer view object.
            </para>
            <para>
            A _buffer view_ represents a contiguous range of a buffer and a
            specific format to be used to interpret the data. Buffer views are used
            to enable shaders to access buffer contents interpreted as formatted
            data. In order to create a valid buffer view, the buffer must: have
            been created with at least one of the following usage flags:
            </para>
            <para>
            * ename:VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT *
            ename:VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Interop.BufferView.#ctor(System.UInt64)">
            <summary>
            
            </summary>
        </member>
        <member name="P:SharpVk.Interop.BufferView.Null">
            <summary>
            A read-only property that returns a null BufferView handle.
            </summary>
        </member>
        <member name="M:SharpVk.Interop.BufferView.ToUInt64">
            <summary>
            Returns the marshalled value of this handle as an unsigned 64-bit
            integer.
            </summary>
        </member>
        <member name="T:SharpVk.Interop.BufferViewCreateInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.BufferViewCreateInfo.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.BufferViewCreateInfo.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.BufferViewCreateInfo.Flags">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.BufferViewCreateInfo.Buffer">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.BufferViewCreateInfo.Format">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.BufferViewCreateInfo.Offset">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.BufferViewCreateInfo.Range">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.CommandBuffer">
            <summary>
            <para>
            Opaque handle to a command buffer object.
            </para>
            <para>
            Command buffers are objects used to record commands which can: be
            subsequently submitted to a device queue for execution. There are two
            levels of command buffers - _primary command buffers_, which can:
            execute secondary command buffers, and which are submitted to queues,
            and _secondary command buffers_, which can: be executed by primary
            command buffers, and which are not directly submitted to queues.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Interop.CommandBuffer.#ctor(System.UIntPtr)">
            <summary>
            
            </summary>
        </member>
        <member name="P:SharpVk.Interop.CommandBuffer.Null">
            <summary>
            A read-only property that returns a null CommandBuffer handle.
            </summary>
        </member>
        <member name="M:SharpVk.Interop.CommandBuffer.ToUInt64">
            <summary>
            Returns the marshalled value of this handle as an unsigned 64-bit
            integer.
            </summary>
        </member>
        <member name="T:SharpVk.Interop.CommandBufferAllocateInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.CommandBufferAllocateInfo.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.CommandBufferAllocateInfo.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.CommandBufferAllocateInfo.CommandPool">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.CommandBufferAllocateInfo.Level">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.CommandBufferAllocateInfo.CommandBufferCount">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.CommandBufferBeginInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.CommandBufferBeginInfo.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.CommandBufferBeginInfo.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.CommandBufferBeginInfo.Flags">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.CommandBufferBeginInfo.InheritanceInfo">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.CommandBufferInheritanceInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.CommandBufferInheritanceInfo.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.CommandBufferInheritanceInfo.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.CommandBufferInheritanceInfo.RenderPass">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.CommandBufferInheritanceInfo.Subpass">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.CommandBufferInheritanceInfo.Framebuffer">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.CommandBufferInheritanceInfo.OcclusionQueryEnable">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.CommandBufferInheritanceInfo.QueryFlags">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.CommandBufferInheritanceInfo.PipelineStatistics">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.CommandPool">
            <summary>
            <para>
            Opaque handle to a command pool object.
            </para>
            <para>
            Command pools are opaque objects that command buffer memory is
            allocated from, and which allow the implementation to amortize the cost
            of resource creation across multiple command buffers. Command pools are
            externally synchronized, meaning that a command pool must: not be used
            concurrently in multiple threads. That includes use via recording
            commands on any command buffers allocated from the pool, as well as
            operations that allocate, free, and reset command buffers or the pool
            itself.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Interop.CommandPool.#ctor(System.UInt64)">
            <summary>
            
            </summary>
        </member>
        <member name="P:SharpVk.Interop.CommandPool.Null">
            <summary>
            A read-only property that returns a null CommandPool handle.
            </summary>
        </member>
        <member name="M:SharpVk.Interop.CommandPool.ToUInt64">
            <summary>
            Returns the marshalled value of this handle as an unsigned 64-bit
            integer.
            </summary>
        </member>
        <member name="T:SharpVk.Interop.CommandPoolCreateInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.CommandPoolCreateInfo.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.CommandPoolCreateInfo.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.CommandPoolCreateInfo.Flags">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.CommandPoolCreateInfo.QueueFamilyIndex">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.CommandProcessCommandsInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.CommandProcessCommandsInfo.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.CommandProcessCommandsInfo.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.CommandProcessCommandsInfo.ObjectTable">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.CommandProcessCommandsInfo.IndirectCommandsLayout">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.CommandProcessCommandsInfo.IndirectCommandsTokenCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.CommandProcessCommandsInfo.IndirectCommandsTokens">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.CommandProcessCommandsInfo.MaxSequencesCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.CommandProcessCommandsInfo.TargetCommandBuffer">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.CommandProcessCommandsInfo.SequencesCountBuffer">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.CommandProcessCommandsInfo.SequencesCountOffset">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.CommandProcessCommandsInfo.SequencesIndexBuffer">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.CommandProcessCommandsInfo.SequencesIndexOffset">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.CommandReserveSpaceForCommandsInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.CommandReserveSpaceForCommandsInfo.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.CommandReserveSpaceForCommandsInfo.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.CommandReserveSpaceForCommandsInfo.ObjectTable">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.CommandReserveSpaceForCommandsInfo.IndirectCommandsLayout">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.CommandReserveSpaceForCommandsInfo.MaxSequencesCount">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.Commands">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.Commands.VulkanDll">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCreateInstance(SharpVk.Interop.InstanceCreateInfo*,SharpVk.Interop.AllocationCallbacks*,SharpVk.Interop.Instance*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkDestroyInstance(SharpVk.Interop.Instance,SharpVk.Interop.AllocationCallbacks*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkEnumeratePhysicalDevices(SharpVk.Interop.Instance,System.UInt32*,SharpVk.Interop.PhysicalDevice*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetPhysicalDeviceFeatures(SharpVk.Interop.PhysicalDevice,SharpVk.PhysicalDeviceFeatures*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetPhysicalDeviceFormatProperties(SharpVk.Interop.PhysicalDevice,SharpVk.Format,SharpVk.FormatProperties*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetPhysicalDeviceImageFormatProperties(SharpVk.Interop.PhysicalDevice,SharpVk.Format,SharpVk.ImageType,SharpVk.ImageTiling,SharpVk.ImageUsageFlags,SharpVk.ImageCreateFlags,SharpVk.ImageFormatProperties*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetPhysicalDeviceProperties(SharpVk.Interop.PhysicalDevice,SharpVk.Interop.PhysicalDeviceProperties*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetPhysicalDeviceQueueFamilyProperties(SharpVk.Interop.PhysicalDevice,System.UInt32*,SharpVk.QueueFamilyProperties*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetPhysicalDeviceMemoryProperties(SharpVk.Interop.PhysicalDevice,SharpVk.Interop.PhysicalDeviceMemoryProperties*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetInstanceProcAddr(SharpVk.Interop.Instance,System.Char*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetDeviceProcAddr(SharpVk.Interop.Device,System.Char*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCreateDevice(SharpVk.Interop.PhysicalDevice,SharpVk.Interop.DeviceCreateInfo*,SharpVk.Interop.AllocationCallbacks*,SharpVk.Interop.Device*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkDestroyDevice(SharpVk.Interop.Device,SharpVk.Interop.AllocationCallbacks*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkEnumerateInstanceExtensionProperties(System.Char*,System.UInt32*,SharpVk.Interop.ExtensionProperties*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkEnumerateDeviceExtensionProperties(SharpVk.Interop.PhysicalDevice,System.Char*,System.UInt32*,SharpVk.Interop.ExtensionProperties*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkEnumerateInstanceLayerProperties(System.UInt32*,SharpVk.Interop.LayerProperties*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkEnumerateDeviceLayerProperties(SharpVk.Interop.PhysicalDevice,System.UInt32*,SharpVk.Interop.LayerProperties*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetDeviceQueue(SharpVk.Interop.Device,System.UInt32,System.UInt32,SharpVk.Interop.Queue*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkQueueSubmit(SharpVk.Interop.Queue,System.UInt32,SharpVk.Interop.SubmitInfo*,SharpVk.Interop.Fence)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkQueueWaitIdle(SharpVk.Interop.Queue)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkDeviceWaitIdle(SharpVk.Interop.Device)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkAllocateMemory(SharpVk.Interop.Device,SharpVk.Interop.MemoryAllocateInfo*,SharpVk.Interop.AllocationCallbacks*,SharpVk.Interop.DeviceMemory*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkFreeMemory(SharpVk.Interop.Device,SharpVk.Interop.DeviceMemory,SharpVk.Interop.AllocationCallbacks*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkMapMemory(SharpVk.Interop.Device,SharpVk.Interop.DeviceMemory,SharpVk.DeviceSize,SharpVk.DeviceSize,SharpVk.MemoryMapFlags,System.Void**)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkUnmapMemory(SharpVk.Interop.Device,SharpVk.Interop.DeviceMemory)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkFlushMappedMemoryRanges(SharpVk.Interop.Device,System.UInt32,SharpVk.Interop.MappedMemoryRange*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkInvalidateMappedMemoryRanges(SharpVk.Interop.Device,System.UInt32,SharpVk.Interop.MappedMemoryRange*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetDeviceMemoryCommitment(SharpVk.Interop.Device,SharpVk.Interop.DeviceMemory,SharpVk.DeviceSize*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkBindBufferMemory(SharpVk.Interop.Device,SharpVk.Interop.Buffer,SharpVk.Interop.DeviceMemory,SharpVk.DeviceSize)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkBindImageMemory(SharpVk.Interop.Device,SharpVk.Interop.Image,SharpVk.Interop.DeviceMemory,SharpVk.DeviceSize)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetBufferMemoryRequirements(SharpVk.Interop.Device,SharpVk.Interop.Buffer,SharpVk.MemoryRequirements*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetImageMemoryRequirements(SharpVk.Interop.Device,SharpVk.Interop.Image,SharpVk.MemoryRequirements*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetImageSparseMemoryRequirements(SharpVk.Interop.Device,SharpVk.Interop.Image,System.UInt32*,SharpVk.SparseImageMemoryRequirements*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetPhysicalDeviceSparseImageFormatProperties(SharpVk.Interop.PhysicalDevice,SharpVk.Format,SharpVk.ImageType,SharpVk.SampleCountFlags,SharpVk.ImageUsageFlags,SharpVk.ImageTiling,System.UInt32*,SharpVk.SparseImageFormatProperties*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkQueueBindSparse(SharpVk.Interop.Queue,System.UInt32,SharpVk.Interop.BindSparseInfo*,SharpVk.Interop.Fence)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCreateFence(SharpVk.Interop.Device,SharpVk.Interop.FenceCreateInfo*,SharpVk.Interop.AllocationCallbacks*,SharpVk.Interop.Fence*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkDestroyFence(SharpVk.Interop.Device,SharpVk.Interop.Fence,SharpVk.Interop.AllocationCallbacks*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkResetFences(SharpVk.Interop.Device,System.UInt32,SharpVk.Interop.Fence*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetFenceStatus(SharpVk.Interop.Device,SharpVk.Interop.Fence)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkWaitForFences(SharpVk.Interop.Device,System.UInt32,SharpVk.Interop.Fence*,SharpVk.Bool32,System.UInt64)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCreateSemaphore(SharpVk.Interop.Device,SharpVk.Interop.SemaphoreCreateInfo*,SharpVk.Interop.AllocationCallbacks*,SharpVk.Interop.Semaphore*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkDestroySemaphore(SharpVk.Interop.Device,SharpVk.Interop.Semaphore,SharpVk.Interop.AllocationCallbacks*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCreateEvent(SharpVk.Interop.Device,SharpVk.Interop.EventCreateInfo*,SharpVk.Interop.AllocationCallbacks*,SharpVk.Interop.Event*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkDestroyEvent(SharpVk.Interop.Device,SharpVk.Interop.Event,SharpVk.Interop.AllocationCallbacks*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetEventStatus(SharpVk.Interop.Device,SharpVk.Interop.Event)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkSetEvent(SharpVk.Interop.Device,SharpVk.Interop.Event)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkResetEvent(SharpVk.Interop.Device,SharpVk.Interop.Event)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCreateQueryPool(SharpVk.Interop.Device,SharpVk.Interop.QueryPoolCreateInfo*,SharpVk.Interop.AllocationCallbacks*,SharpVk.Interop.QueryPool*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkDestroyQueryPool(SharpVk.Interop.Device,SharpVk.Interop.QueryPool,SharpVk.Interop.AllocationCallbacks*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetQueryPoolResults(SharpVk.Interop.Device,SharpVk.Interop.QueryPool,System.UInt32,System.UInt32,SharpVk.Size,System.Void*,SharpVk.DeviceSize,SharpVk.QueryResultFlags)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCreateBuffer(SharpVk.Interop.Device,SharpVk.Interop.BufferCreateInfo*,SharpVk.Interop.AllocationCallbacks*,SharpVk.Interop.Buffer*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkDestroyBuffer(SharpVk.Interop.Device,SharpVk.Interop.Buffer,SharpVk.Interop.AllocationCallbacks*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCreateBufferView(SharpVk.Interop.Device,SharpVk.Interop.BufferViewCreateInfo*,SharpVk.Interop.AllocationCallbacks*,SharpVk.Interop.BufferView*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkDestroyBufferView(SharpVk.Interop.Device,SharpVk.Interop.BufferView,SharpVk.Interop.AllocationCallbacks*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCreateImage(SharpVk.Interop.Device,SharpVk.Interop.ImageCreateInfo*,SharpVk.Interop.AllocationCallbacks*,SharpVk.Interop.Image*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkDestroyImage(SharpVk.Interop.Device,SharpVk.Interop.Image,SharpVk.Interop.AllocationCallbacks*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetImageSubresourceLayout(SharpVk.Interop.Device,SharpVk.Interop.Image,SharpVk.ImageSubresource*,SharpVk.SubresourceLayout*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCreateImageView(SharpVk.Interop.Device,SharpVk.Interop.ImageViewCreateInfo*,SharpVk.Interop.AllocationCallbacks*,SharpVk.Interop.ImageView*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkDestroyImageView(SharpVk.Interop.Device,SharpVk.Interop.ImageView,SharpVk.Interop.AllocationCallbacks*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCreateShaderModule(SharpVk.Interop.Device,SharpVk.Interop.ShaderModuleCreateInfo*,SharpVk.Interop.AllocationCallbacks*,SharpVk.Interop.ShaderModule*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkDestroyShaderModule(SharpVk.Interop.Device,SharpVk.Interop.ShaderModule,SharpVk.Interop.AllocationCallbacks*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCreatePipelineCache(SharpVk.Interop.Device,SharpVk.Interop.PipelineCacheCreateInfo*,SharpVk.Interop.AllocationCallbacks*,SharpVk.Interop.PipelineCache*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkDestroyPipelineCache(SharpVk.Interop.Device,SharpVk.Interop.PipelineCache,SharpVk.Interop.AllocationCallbacks*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetPipelineCacheData(SharpVk.Interop.Device,SharpVk.Interop.PipelineCache,SharpVk.Size*,System.Void*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkMergePipelineCaches(SharpVk.Interop.Device,SharpVk.Interop.PipelineCache,System.UInt32,SharpVk.Interop.PipelineCache*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCreateGraphicsPipelines(SharpVk.Interop.Device,SharpVk.Interop.PipelineCache,System.UInt32,SharpVk.Interop.GraphicsPipelineCreateInfo*,SharpVk.Interop.AllocationCallbacks*,SharpVk.Interop.Pipeline*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCreateComputePipelines(SharpVk.Interop.Device,SharpVk.Interop.PipelineCache,System.UInt32,SharpVk.Interop.ComputePipelineCreateInfo*,SharpVk.Interop.AllocationCallbacks*,SharpVk.Interop.Pipeline*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkDestroyPipeline(SharpVk.Interop.Device,SharpVk.Interop.Pipeline,SharpVk.Interop.AllocationCallbacks*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCreatePipelineLayout(SharpVk.Interop.Device,SharpVk.Interop.PipelineLayoutCreateInfo*,SharpVk.Interop.AllocationCallbacks*,SharpVk.Interop.PipelineLayout*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkDestroyPipelineLayout(SharpVk.Interop.Device,SharpVk.Interop.PipelineLayout,SharpVk.Interop.AllocationCallbacks*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCreateSampler(SharpVk.Interop.Device,SharpVk.Interop.SamplerCreateInfo*,SharpVk.Interop.AllocationCallbacks*,SharpVk.Interop.Sampler*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkDestroySampler(SharpVk.Interop.Device,SharpVk.Interop.Sampler,SharpVk.Interop.AllocationCallbacks*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCreateDescriptorSetLayout(SharpVk.Interop.Device,SharpVk.Interop.DescriptorSetLayoutCreateInfo*,SharpVk.Interop.AllocationCallbacks*,SharpVk.Interop.DescriptorSetLayout*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkDestroyDescriptorSetLayout(SharpVk.Interop.Device,SharpVk.Interop.DescriptorSetLayout,SharpVk.Interop.AllocationCallbacks*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCreateDescriptorPool(SharpVk.Interop.Device,SharpVk.Interop.DescriptorPoolCreateInfo*,SharpVk.Interop.AllocationCallbacks*,SharpVk.Interop.DescriptorPool*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkDestroyDescriptorPool(SharpVk.Interop.Device,SharpVk.Interop.DescriptorPool,SharpVk.Interop.AllocationCallbacks*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkResetDescriptorPool(SharpVk.Interop.Device,SharpVk.Interop.DescriptorPool,SharpVk.DescriptorPoolResetFlags)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkAllocateDescriptorSets(SharpVk.Interop.Device,SharpVk.Interop.DescriptorSetAllocateInfo*,SharpVk.Interop.DescriptorSet*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkFreeDescriptorSets(SharpVk.Interop.Device,SharpVk.Interop.DescriptorPool,System.UInt32,SharpVk.Interop.DescriptorSet*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkUpdateDescriptorSets(SharpVk.Interop.Device,System.UInt32,SharpVk.Interop.WriteDescriptorSet*,System.UInt32,SharpVk.Interop.CopyDescriptorSet*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCreateFramebuffer(SharpVk.Interop.Device,SharpVk.Interop.FramebufferCreateInfo*,SharpVk.Interop.AllocationCallbacks*,SharpVk.Interop.Framebuffer*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkDestroyFramebuffer(SharpVk.Interop.Device,SharpVk.Interop.Framebuffer,SharpVk.Interop.AllocationCallbacks*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCreateRenderPass(SharpVk.Interop.Device,SharpVk.Interop.RenderPassCreateInfo*,SharpVk.Interop.AllocationCallbacks*,SharpVk.Interop.RenderPass*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkDestroyRenderPass(SharpVk.Interop.Device,SharpVk.Interop.RenderPass,SharpVk.Interop.AllocationCallbacks*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetRenderAreaGranularity(SharpVk.Interop.Device,SharpVk.Interop.RenderPass,SharpVk.Extent2D*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCreateCommandPool(SharpVk.Interop.Device,SharpVk.Interop.CommandPoolCreateInfo*,SharpVk.Interop.AllocationCallbacks*,SharpVk.Interop.CommandPool*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkDestroyCommandPool(SharpVk.Interop.Device,SharpVk.Interop.CommandPool,SharpVk.Interop.AllocationCallbacks*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkResetCommandPool(SharpVk.Interop.Device,SharpVk.Interop.CommandPool,SharpVk.CommandPoolResetFlags)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkAllocateCommandBuffers(SharpVk.Interop.Device,SharpVk.Interop.CommandBufferAllocateInfo*,SharpVk.Interop.CommandBuffer*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkFreeCommandBuffers(SharpVk.Interop.Device,SharpVk.Interop.CommandPool,System.UInt32,SharpVk.Interop.CommandBuffer*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkBeginCommandBuffer(SharpVk.Interop.CommandBuffer,SharpVk.Interop.CommandBufferBeginInfo*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkEndCommandBuffer(SharpVk.Interop.CommandBuffer)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkResetCommandBuffer(SharpVk.Interop.CommandBuffer,SharpVk.CommandBufferResetFlags)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdBindPipeline(SharpVk.Interop.CommandBuffer,SharpVk.PipelineBindPoint,SharpVk.Interop.Pipeline)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdSetViewport(SharpVk.Interop.CommandBuffer,System.UInt32,System.UInt32,SharpVk.Viewport*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdSetScissor(SharpVk.Interop.CommandBuffer,System.UInt32,System.UInt32,SharpVk.Rect2D*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdSetLineWidth(SharpVk.Interop.CommandBuffer,System.Single)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdSetDepthBias(SharpVk.Interop.CommandBuffer,System.Single,System.Single,System.Single)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdSetBlendConstants(SharpVk.Interop.CommandBuffer,System.Single)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdSetDepthBounds(SharpVk.Interop.CommandBuffer,System.Single,System.Single)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdSetStencilCompareMask(SharpVk.Interop.CommandBuffer,SharpVk.StencilFaceFlags,System.UInt32)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdSetStencilWriteMask(SharpVk.Interop.CommandBuffer,SharpVk.StencilFaceFlags,System.UInt32)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdSetStencilReference(SharpVk.Interop.CommandBuffer,SharpVk.StencilFaceFlags,System.UInt32)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdBindDescriptorSets(SharpVk.Interop.CommandBuffer,SharpVk.PipelineBindPoint,SharpVk.Interop.PipelineLayout,System.UInt32,System.UInt32,SharpVk.Interop.DescriptorSet*,System.UInt32,System.UInt32*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdBindIndexBuffer(SharpVk.Interop.CommandBuffer,SharpVk.Interop.Buffer,SharpVk.DeviceSize,SharpVk.IndexType)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdBindVertexBuffers(SharpVk.Interop.CommandBuffer,System.UInt32,System.UInt32,SharpVk.Interop.Buffer*,SharpVk.DeviceSize*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdDraw(SharpVk.Interop.CommandBuffer,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdDrawIndexed(SharpVk.Interop.CommandBuffer,System.UInt32,System.UInt32,System.UInt32,System.Int32,System.UInt32)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdDrawIndirect(SharpVk.Interop.CommandBuffer,SharpVk.Interop.Buffer,SharpVk.DeviceSize,System.UInt32,System.UInt32)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdDrawIndexedIndirect(SharpVk.Interop.CommandBuffer,SharpVk.Interop.Buffer,SharpVk.DeviceSize,System.UInt32,System.UInt32)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdDispatch(SharpVk.Interop.CommandBuffer,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdDispatchIndirect(SharpVk.Interop.CommandBuffer,SharpVk.Interop.Buffer,SharpVk.DeviceSize)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdCopyBuffer(SharpVk.Interop.CommandBuffer,SharpVk.Interop.Buffer,SharpVk.Interop.Buffer,System.UInt32,SharpVk.BufferCopy*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdCopyImage(SharpVk.Interop.CommandBuffer,SharpVk.Interop.Image,SharpVk.ImageLayout,SharpVk.Interop.Image,SharpVk.ImageLayout,System.UInt32,SharpVk.ImageCopy*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdBlitImage(SharpVk.Interop.CommandBuffer,SharpVk.Interop.Image,SharpVk.ImageLayout,SharpVk.Interop.Image,SharpVk.ImageLayout,System.UInt32,SharpVk.Interop.ImageBlit*,SharpVk.Filter)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdCopyBufferToImage(SharpVk.Interop.CommandBuffer,SharpVk.Interop.Buffer,SharpVk.Interop.Image,SharpVk.ImageLayout,System.UInt32,SharpVk.BufferImageCopy*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdCopyImageToBuffer(SharpVk.Interop.CommandBuffer,SharpVk.Interop.Image,SharpVk.ImageLayout,SharpVk.Interop.Buffer,System.UInt32,SharpVk.BufferImageCopy*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdUpdateBuffer(SharpVk.Interop.CommandBuffer,SharpVk.Interop.Buffer,SharpVk.DeviceSize,SharpVk.DeviceSize,System.Void*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdFillBuffer(SharpVk.Interop.CommandBuffer,SharpVk.Interop.Buffer,SharpVk.DeviceSize,SharpVk.DeviceSize,System.UInt32)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdClearColorImage(SharpVk.Interop.CommandBuffer,SharpVk.Interop.Image,SharpVk.ImageLayout,SharpVk.ClearColorValue*,System.UInt32,SharpVk.ImageSubresourceRange*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdClearDepthStencilImage(SharpVk.Interop.CommandBuffer,SharpVk.Interop.Image,SharpVk.ImageLayout,SharpVk.ClearDepthStencilValue*,System.UInt32,SharpVk.ImageSubresourceRange*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdClearAttachments(SharpVk.Interop.CommandBuffer,System.UInt32,SharpVk.ClearAttachment*,System.UInt32,SharpVk.ClearRect*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdResolveImage(SharpVk.Interop.CommandBuffer,SharpVk.Interop.Image,SharpVk.ImageLayout,SharpVk.Interop.Image,SharpVk.ImageLayout,System.UInt32,SharpVk.ImageResolve*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdSetEvent(SharpVk.Interop.CommandBuffer,SharpVk.Interop.Event,SharpVk.PipelineStageFlags)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdResetEvent(SharpVk.Interop.CommandBuffer,SharpVk.Interop.Event,SharpVk.PipelineStageFlags)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdWaitEvents(SharpVk.Interop.CommandBuffer,System.UInt32,SharpVk.Interop.Event*,SharpVk.PipelineStageFlags,SharpVk.PipelineStageFlags,System.UInt32,SharpVk.Interop.MemoryBarrier*,System.UInt32,SharpVk.Interop.BufferMemoryBarrier*,System.UInt32,SharpVk.Interop.ImageMemoryBarrier*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdPipelineBarrier(SharpVk.Interop.CommandBuffer,SharpVk.PipelineStageFlags,SharpVk.PipelineStageFlags,SharpVk.DependencyFlags,System.UInt32,SharpVk.Interop.MemoryBarrier*,System.UInt32,SharpVk.Interop.BufferMemoryBarrier*,System.UInt32,SharpVk.Interop.ImageMemoryBarrier*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdBeginQuery(SharpVk.Interop.CommandBuffer,SharpVk.Interop.QueryPool,System.UInt32,SharpVk.QueryControlFlags)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdEndQuery(SharpVk.Interop.CommandBuffer,SharpVk.Interop.QueryPool,System.UInt32)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdResetQueryPool(SharpVk.Interop.CommandBuffer,SharpVk.Interop.QueryPool,System.UInt32,System.UInt32)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdWriteTimestamp(SharpVk.Interop.CommandBuffer,SharpVk.PipelineStageFlags,SharpVk.Interop.QueryPool,System.UInt32)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdCopyQueryPoolResults(SharpVk.Interop.CommandBuffer,SharpVk.Interop.QueryPool,System.UInt32,System.UInt32,SharpVk.Interop.Buffer,SharpVk.DeviceSize,SharpVk.DeviceSize,SharpVk.QueryResultFlags)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdPushConstants(SharpVk.Interop.CommandBuffer,SharpVk.Interop.PipelineLayout,SharpVk.ShaderStageFlags,System.UInt32,System.UInt32,System.Void*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdBeginRenderPass(SharpVk.Interop.CommandBuffer,SharpVk.Interop.RenderPassBeginInfo*,SharpVk.SubpassContents)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdNextSubpass(SharpVk.Interop.CommandBuffer,SharpVk.SubpassContents)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdEndRenderPass(SharpVk.Interop.CommandBuffer)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdExecuteCommands(SharpVk.Interop.CommandBuffer,System.UInt32,SharpVk.Interop.CommandBuffer*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkDestroySurfaceKHR(SharpVk.Interop.Instance,SharpVk.Interop.Surface,SharpVk.Interop.AllocationCallbacks*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetPhysicalDeviceSurfaceSupportKHR(SharpVk.Interop.PhysicalDevice,System.UInt32,SharpVk.Interop.Surface,SharpVk.Bool32*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetPhysicalDeviceSurfaceCapabilitiesKHR(SharpVk.Interop.PhysicalDevice,SharpVk.Interop.Surface,SharpVk.SurfaceCapabilities*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetPhysicalDeviceSurfaceFormatsKHR(SharpVk.Interop.PhysicalDevice,SharpVk.Interop.Surface,System.UInt32*,SharpVk.SurfaceFormat*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetPhysicalDeviceSurfacePresentModesKHR(SharpVk.Interop.PhysicalDevice,SharpVk.Interop.Surface,System.UInt32*,SharpVk.PresentMode*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCreateSwapchainKHR(SharpVk.Interop.Device,SharpVk.Interop.SwapchainCreateInfo*,SharpVk.Interop.AllocationCallbacks*,SharpVk.Interop.Swapchain*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkDestroySwapchainKHR(SharpVk.Interop.Device,SharpVk.Interop.Swapchain,SharpVk.Interop.AllocationCallbacks*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetSwapchainImagesKHR(SharpVk.Interop.Device,SharpVk.Interop.Swapchain,System.UInt32*,SharpVk.Interop.Image*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkAcquireNextImageKHR(SharpVk.Interop.Device,SharpVk.Interop.Swapchain,System.UInt64,SharpVk.Interop.Semaphore,SharpVk.Interop.Fence,System.UInt32*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkQueuePresentKHR(SharpVk.Interop.Queue,SharpVk.Interop.PresentInfo*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetPhysicalDeviceDisplayPropertiesKHR(SharpVk.Interop.PhysicalDevice,System.UInt32*,SharpVk.Interop.DisplayProperties*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetPhysicalDeviceDisplayPlanePropertiesKHR(SharpVk.Interop.PhysicalDevice,System.UInt32*,SharpVk.Interop.DisplayPlaneProperties*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetDisplayPlaneSupportedDisplaysKHR(SharpVk.Interop.PhysicalDevice,System.UInt32,System.UInt32*,SharpVk.Interop.Display*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetDisplayModePropertiesKHR(SharpVk.Interop.PhysicalDevice,SharpVk.Interop.Display,System.UInt32*,SharpVk.Interop.DisplayModeProperties*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCreateDisplayModeKHR(SharpVk.Interop.PhysicalDevice,SharpVk.Interop.Display,SharpVk.Interop.DisplayModeCreateInfo*,SharpVk.Interop.AllocationCallbacks*,SharpVk.Interop.DisplayMode*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetDisplayPlaneCapabilitiesKHR(SharpVk.Interop.PhysicalDevice,SharpVk.Interop.DisplayMode,System.UInt32,SharpVk.DisplayPlaneCapabilities*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCreateDisplayPlaneSurfaceKHR(SharpVk.Interop.Instance,SharpVk.Interop.DisplaySurfaceCreateInfo*,SharpVk.Interop.AllocationCallbacks*,SharpVk.Interop.Surface*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCreateSharedSwapchainsKHR(SharpVk.Interop.Device,System.UInt32,SharpVk.Interop.SwapchainCreateInfo*,SharpVk.Interop.AllocationCallbacks*,SharpVk.Interop.Swapchain*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCreateXlibSurfaceKHR(SharpVk.Interop.Instance,SharpVk.Interop.XlibSurfaceCreateInfo*,SharpVk.Interop.AllocationCallbacks*,SharpVk.Interop.Surface*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetPhysicalDeviceXlibPresentationSupportKHR(SharpVk.Interop.PhysicalDevice,System.UInt32,System.IntPtr*,System.IntPtr)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCreateXcbSurfaceKHR(SharpVk.Interop.Instance,SharpVk.Interop.XcbSurfaceCreateInfo*,SharpVk.Interop.AllocationCallbacks*,SharpVk.Interop.Surface*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetPhysicalDeviceXcbPresentationSupportKHR(SharpVk.Interop.PhysicalDevice,System.UInt32,System.IntPtr*,System.IntPtr)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCreateWaylandSurfaceKHR(SharpVk.Interop.Instance,SharpVk.Interop.WaylandSurfaceCreateInfo*,SharpVk.Interop.AllocationCallbacks*,SharpVk.Interop.Surface*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetPhysicalDeviceWaylandPresentationSupportKHR(SharpVk.Interop.PhysicalDevice,System.UInt32,System.IntPtr)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCreateMirSurfaceKHR(SharpVk.Interop.Instance,SharpVk.Interop.MirSurfaceCreateInfo*,SharpVk.Interop.AllocationCallbacks*,SharpVk.Interop.Surface*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetPhysicalDeviceMirPresentationSupportKHR(SharpVk.Interop.PhysicalDevice,System.UInt32,System.IntPtr*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCreateAndroidSurfaceKHR(SharpVk.Interop.Instance,SharpVk.Interop.AndroidSurfaceCreateInfo*,SharpVk.Interop.AllocationCallbacks*,SharpVk.Interop.Surface*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCreateWin32SurfaceKHR(SharpVk.Interop.Instance,SharpVk.Interop.Win32SurfaceCreateInfo*,SharpVk.Interop.AllocationCallbacks*,SharpVk.Interop.Surface*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetPhysicalDeviceWin32PresentationSupportKHR(SharpVk.Interop.PhysicalDevice,System.UInt32)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCreateDebugReportCallbackEXT(SharpVk.Interop.Instance,SharpVk.Interop.DebugReportCallbackCreateInfo*,SharpVk.Interop.AllocationCallbacks*,SharpVk.Interop.DebugReportCallback*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkDestroyDebugReportCallbackEXT(SharpVk.Interop.Instance,SharpVk.Interop.DebugReportCallback,SharpVk.Interop.AllocationCallbacks*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkDebugReportMessageEXT(SharpVk.Interop.Instance,SharpVk.DebugReportFlags,SharpVk.DebugReportObjectType,System.UInt64,SharpVk.Size,System.Int32,System.Char*,System.Char*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkDebugMarkerSetObjectTagEXT(SharpVk.Interop.Device,SharpVk.Interop.DebugMarkerObjectTagInfo*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkDebugMarkerSetObjectNameEXT(SharpVk.Interop.Device,SharpVk.Interop.DebugMarkerObjectNameInfo*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdDebugMarkerBeginEXT(SharpVk.Interop.CommandBuffer,SharpVk.Interop.DebugMarkerMarkerInfo*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdDebugMarkerEndEXT(SharpVk.Interop.CommandBuffer)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdDebugMarkerInsertEXT(SharpVk.Interop.CommandBuffer,SharpVk.Interop.DebugMarkerMarkerInfo*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdDrawIndirectCountAMD(SharpVk.Interop.CommandBuffer,SharpVk.Interop.Buffer,SharpVk.DeviceSize,SharpVk.Interop.Buffer,SharpVk.DeviceSize,System.UInt32,System.UInt32)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdDrawIndexedIndirectCountAMD(SharpVk.Interop.CommandBuffer,SharpVk.Interop.Buffer,SharpVk.DeviceSize,SharpVk.Interop.Buffer,SharpVk.DeviceSize,System.UInt32,System.UInt32)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetPhysicalDeviceExternalImageFormatPropertiesNV(SharpVk.Interop.PhysicalDevice,SharpVk.Format,SharpVk.ImageType,SharpVk.ImageTiling,SharpVk.ImageUsageFlags,SharpVk.ImageCreateFlags,SharpVk.ExternalMemoryHandleTypeFlags,SharpVk.ExternalImageFormatProperties*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetMemoryWin32HandleNV(SharpVk.Interop.Device,SharpVk.Interop.DeviceMemory,SharpVk.ExternalMemoryHandleTypeFlags,System.IntPtr*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetPhysicalDeviceFeatures2KHR(SharpVk.Interop.PhysicalDevice,SharpVk.Interop.PhysicalDeviceFeatures2*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetPhysicalDeviceProperties2KHR(SharpVk.Interop.PhysicalDevice,SharpVk.Interop.PhysicalDeviceProperties2*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetPhysicalDeviceFormatProperties2KHR(SharpVk.Interop.PhysicalDevice,SharpVk.Format,SharpVk.Interop.FormatProperties2*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetPhysicalDeviceImageFormatProperties2KHR(SharpVk.Interop.PhysicalDevice,SharpVk.Interop.PhysicalDeviceImageFormatInfo2*,SharpVk.Interop.ImageFormatProperties2*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetPhysicalDeviceQueueFamilyProperties2KHR(SharpVk.Interop.PhysicalDevice,System.UInt32*,SharpVk.Interop.QueueFamilyProperties2*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetPhysicalDeviceMemoryProperties2KHR(SharpVk.Interop.PhysicalDevice,SharpVk.Interop.PhysicalDeviceMemoryProperties2*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetPhysicalDeviceSparseImageFormatProperties2KHR(SharpVk.Interop.PhysicalDevice,SharpVk.Interop.PhysicalDeviceSparseImageFormatInfo2*,System.UInt32*,SharpVk.Interop.SparseImageFormatProperties2*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCreateViSurfaceNN(SharpVk.Interop.Instance,SharpVk.Interop.ViSurfaceCreateInfo*,SharpVk.Interop.AllocationCallbacks*,SharpVk.Interop.Surface*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkTrimCommandPoolKHR(SharpVk.Interop.Device,SharpVk.Interop.CommandPool,SharpVk.CommandPoolTrimFlags)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdProcessCommandsNVX(SharpVk.Interop.CommandBuffer,SharpVk.Interop.CommandProcessCommandsInfo*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCmdReserveSpaceForCommandsNVX(SharpVk.Interop.CommandBuffer,SharpVk.Interop.CommandReserveSpaceForCommandsInfo*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCreateIndirectCommandsLayoutNVX(SharpVk.Interop.Device,SharpVk.Interop.IndirectCommandsLayoutCreateInfo*,SharpVk.Interop.AllocationCallbacks*,SharpVk.Interop.IndirectCommandsLayout*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkDestroyIndirectCommandsLayoutNVX(SharpVk.Interop.Device,SharpVk.Interop.IndirectCommandsLayout,SharpVk.Interop.AllocationCallbacks*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkCreateObjectTableNVX(SharpVk.Interop.Device,SharpVk.Interop.ObjectTableCreateInfo*,SharpVk.Interop.AllocationCallbacks*,SharpVk.Interop.ObjectTable*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkDestroyObjectTableNVX(SharpVk.Interop.Device,SharpVk.Interop.ObjectTable,SharpVk.Interop.AllocationCallbacks*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkRegisterObjectsNVX(SharpVk.Interop.Device,SharpVk.Interop.ObjectTable,System.UInt32,SharpVk.ObjectTableEntry**,System.UInt32*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkUnregisterObjectsNVX(SharpVk.Interop.Device,SharpVk.Interop.ObjectTable,System.UInt32,SharpVk.ObjectEntryType*,System.UInt32*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX(SharpVk.Interop.PhysicalDevice,SharpVk.Interop.DeviceGeneratedCommandsFeatures*,SharpVk.Interop.DeviceGeneratedCommandsLimits*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkReleaseDisplayEXT(SharpVk.Interop.PhysicalDevice,SharpVk.Interop.Display)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkAcquireXlibDisplayEXT(SharpVk.Interop.PhysicalDevice,System.IntPtr*,SharpVk.Interop.Display)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetRandROutputDisplayEXT(SharpVk.Interop.PhysicalDevice,System.IntPtr*,System.IntPtr,SharpVk.Interop.Display*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetPhysicalDeviceSurfaceCapabilities2EXT(SharpVk.Interop.PhysicalDevice,SharpVk.Interop.Surface,SharpVk.Interop.SurfaceCapabilities2*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkDisplayPowerControlEXT(SharpVk.Interop.Device,SharpVk.Interop.Display,SharpVk.Interop.DisplayPowerInfo*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkRegisterDeviceEventEXT(SharpVk.Interop.Device,SharpVk.Interop.DeviceEventInfo*,SharpVk.Interop.AllocationCallbacks*,SharpVk.Interop.Fence*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkRegisterDisplayEventEXT(SharpVk.Interop.Device,SharpVk.Interop.Display,SharpVk.Interop.DisplayEventInfo*,SharpVk.Interop.AllocationCallbacks*,SharpVk.Interop.Fence*)">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Commands.vkGetSwapchainCounterEXT(SharpVk.Interop.Device,SharpVk.Interop.Swapchain,SharpVk.SurfaceCounterFlags,System.UInt64*)">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.ComputePipelineCreateInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ComputePipelineCreateInfo.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ComputePipelineCreateInfo.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ComputePipelineCreateInfo.Flags">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ComputePipelineCreateInfo.Stage">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ComputePipelineCreateInfo.Layout">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ComputePipelineCreateInfo.BasePipelineHandle">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ComputePipelineCreateInfo.BasePipelineIndex">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.CopyDescriptorSet">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.CopyDescriptorSet.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.CopyDescriptorSet.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.CopyDescriptorSet.SourceSet">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.CopyDescriptorSet.SourceBinding">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.CopyDescriptorSet.SourceArrayElement">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.CopyDescriptorSet.DestinationSet">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.CopyDescriptorSet.DestinationBinding">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.CopyDescriptorSet.DestinationArrayElement">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.CopyDescriptorSet.DescriptorCount">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.DebugMarkerMarkerInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DebugMarkerMarkerInfo.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DebugMarkerMarkerInfo.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DebugMarkerMarkerInfo.MarkerName">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DebugMarkerMarkerInfo.Color">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.DebugMarkerObjectNameInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DebugMarkerObjectNameInfo.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DebugMarkerObjectNameInfo.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DebugMarkerObjectNameInfo.ObjectType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DebugMarkerObjectNameInfo.Object">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DebugMarkerObjectNameInfo.ObjectName">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.DebugMarkerObjectTagInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DebugMarkerObjectTagInfo.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DebugMarkerObjectTagInfo.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DebugMarkerObjectTagInfo.ObjectType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DebugMarkerObjectTagInfo.Object">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DebugMarkerObjectTagInfo.TagName">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DebugMarkerObjectTagInfo.TagSize">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DebugMarkerObjectTagInfo.Tag">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.DebugReportCallback">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.DebugReportCallback.#ctor(System.UInt64)">
            <summary>
            
            </summary>
        </member>
        <member name="P:SharpVk.Interop.DebugReportCallback.Null">
            <summary>
            A read-only property that returns a null DebugReportCallback
            handle.
            </summary>
        </member>
        <member name="M:SharpVk.Interop.DebugReportCallback.ToUInt64">
            <summary>
            Returns the marshalled value of this handle as an unsigned 64-bit
            integer.
            </summary>
        </member>
        <member name="T:SharpVk.Interop.DebugReportCallbackCreateInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DebugReportCallbackCreateInfo.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DebugReportCallbackCreateInfo.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DebugReportCallbackCreateInfo.Flags">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DebugReportCallbackCreateInfo.PfnCallback">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DebugReportCallbackCreateInfo.UserData">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.DedicatedAllocationBufferCreateInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DedicatedAllocationBufferCreateInfo.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DedicatedAllocationBufferCreateInfo.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DedicatedAllocationBufferCreateInfo.DedicatedAllocation">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.DedicatedAllocationImageCreateInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DedicatedAllocationImageCreateInfo.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DedicatedAllocationImageCreateInfo.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DedicatedAllocationImageCreateInfo.DedicatedAllocation">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.DedicatedAllocationMemoryAllocateInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DedicatedAllocationMemoryAllocateInfo.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DedicatedAllocationMemoryAllocateInfo.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DedicatedAllocationMemoryAllocateInfo.Image">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DedicatedAllocationMemoryAllocateInfo.Buffer">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.AllocationFunctionDelegate">
            <summary>
            <para>
            Application-defined memory allocation function.
            </para>
            <para>
            [[vkAllocationFunction_return_rules]] If pname:pfnAllocation is unable
            to allocate the requested memory, it must: return `NULL`. If the
            allocation was successful, it must: return a valid pointer to memory
            allocation containing at least pname:size bytes, and with the pointer
            value being a multiple of pname:alignment.
            </para>
            <para>
            [NOTE] .Note ==== Correct Vulkan operation cannot: be assumed if the
            application does not follow these rules.
            </para>
            <para>
            For example, pname:pfnAllocation (or pname:pfnReallocation) could cause
            termination of running Vulkan instance(s) on a failed allocation for
            debugging purposes, either directly or indirectly. In these
            circumstances, it cannot: be assumed that any part of any affected
            VkInstance objects are going to operate correctly (even
            flink:vkDestroyInstance), and the application must: ensure it cleans up
            properly via other means (e.g. process termination). ====
            </para>
            <para>
            If pname:pfnAllocation returns `NULL`, and if the implementation is
            unable to continue correct processing of the current command without
            the requested allocation, it must: treat this as a run-time error, and
            generate ename:VK_ERROR_OUT_OF_HOST_MEMORY at the appropriate time for
            the command in which the condition was detected, as described in
            &lt;&lt;fundamentals-errorcodes, Return Codes&gt;&gt;.
            </para>
            <para>
            If the implementation is able to continue correct processing of the
            current command without the requested allocation, then it may: do so,
            and must: not generate ename:VK_ERROR_OUT_OF_HOST_MEMORY as a result of
            this failed allocation.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.DebugReportCallbackDelegate">
            <summary>
            <para>
            Application-defined debug report callback function.
            </para>
            <para>
            The callback returns a basetype:VkBool32 that indicates to the calling
            layer if the Vulkan call should: be aborted or not. Applications
            should: always return ename:VK_FALSE so that they see the same behavior
            with and without validation layers enabled.
            </para>
            <para>
            If the application returns ename:VK_TRUE from its callback and the
            Vulkan call being aborted returns a elink:VkResult, the layer will
            return ename:VK_ERROR_VALIDATION_FAILED_EXT.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.FreeFunctionDelegate">
            <summary>
            <para>
            Application-defined memory free function.
            </para>
            <para>
            pname:pMemory may: be `NULL`, which the callback must: handle safely.
            If pname:pMemory is non-`NULL`, it must: be a pointer previously
            allocated by pname:pfnAllocation or pname:pfnReallocation. The
            application should: free this memory.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.InternalAllocationNotificationDelegate">
            <summary>
            <para>
            Application-defined memory allocation notification function.
            </para>
            <para>
            This is a purely informational callback.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.InternalFreeNotificationDelegate">
            <summary>
            Application-defined memory free notification function.
            </summary>
        </member>
        <member name="T:SharpVk.Interop.ReallocationFunctionDelegate">
            <summary>
            <para>
            Application-defined memory reallocation function.
            </para>
            <para>
            pname:pfnReallocation must: return an allocation with enough space for
            pname:size bytes, and the contents of the original allocation from
            bytes zero to [eq]#min(original size, new size) - 1# must: be preserved
            in the returned allocation. If pname:size is larger than the old size,
            the contents of the additional space are undefined. If satisfying these
            requirements involves creating a new allocation, then the old
            allocation should: be freed.
            </para>
            <para>
            If pname:pOriginal is `NULL`, then pname:pfnReallocation must: behave
            equivalently to a call to tlink:PFN_vkAllocationFunction with the same
            parameter values (without pname:pOriginal).
            </para>
            <para>
            If pname:size is zero, then pname:pfnReallocation must: behave
            equivalently to a call to tlink:PFN_vkFreeFunction with the same
            pname:pUserData parameter value, and pname:pMemory equal to
            pname:pOriginal.
            </para>
            <para>
            If pname:pOriginal is non-`NULL`, the implementation must: ensure that
            pname:alignment is equal to the pname:alignment used to originally
            allocate pname:pOriginal.
            </para>
            <para>
            If this function fails and pname:pOriginal is non-`NULL` the
            application must: not free the old allocation.
            </para>
            <para>
            pname:pfnReallocation must: follow the same
            &lt;&lt;vkAllocationFunction_return_rules, rules for return values as
            tname:PFN_vkAllocationFunction&gt;&gt;.
            </para>
            </summary>
        </member>
        <member name="T:SharpVk.Interop.VoidFunctionDelegate">
            <summary>
            Dummy function pointer type returned by queries.
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCreateInstance">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkDestroyInstance">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkEnumeratePhysicalDevices">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetPhysicalDeviceFeatures">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetPhysicalDeviceFormatProperties">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetPhysicalDeviceImageFormatProperties">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetPhysicalDeviceProperties">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetPhysicalDeviceQueueFamilyProperties">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetPhysicalDeviceMemoryProperties">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetInstanceProcAddr">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetDeviceProcAddr">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCreateDevice">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkDestroyDevice">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkEnumerateInstanceExtensionProperties">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkEnumerateDeviceExtensionProperties">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkEnumerateInstanceLayerProperties">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkEnumerateDeviceLayerProperties">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetDeviceQueue">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkQueueSubmit">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkQueueWaitIdle">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkDeviceWaitIdle">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkAllocateMemory">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkFreeMemory">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkMapMemory">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkUnmapMemory">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkFlushMappedMemoryRanges">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkInvalidateMappedMemoryRanges">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetDeviceMemoryCommitment">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkBindBufferMemory">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkBindImageMemory">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetBufferMemoryRequirements">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetImageMemoryRequirements">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetImageSparseMemoryRequirements">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetPhysicalDeviceSparseImageFormatProperties">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkQueueBindSparse">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCreateFence">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkDestroyFence">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkResetFences">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetFenceStatus">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkWaitForFences">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCreateSemaphore">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkDestroySemaphore">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCreateEvent">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkDestroyEvent">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetEventStatus">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkSetEvent">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkResetEvent">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCreateQueryPool">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkDestroyQueryPool">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetQueryPoolResults">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCreateBuffer">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkDestroyBuffer">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCreateBufferView">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkDestroyBufferView">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCreateImage">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkDestroyImage">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetImageSubresourceLayout">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCreateImageView">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkDestroyImageView">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCreateShaderModule">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkDestroyShaderModule">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCreatePipelineCache">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkDestroyPipelineCache">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetPipelineCacheData">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkMergePipelineCaches">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCreateGraphicsPipelines">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCreateComputePipelines">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkDestroyPipeline">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCreatePipelineLayout">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkDestroyPipelineLayout">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCreateSampler">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkDestroySampler">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCreateDescriptorSetLayout">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkDestroyDescriptorSetLayout">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCreateDescriptorPool">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkDestroyDescriptorPool">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkResetDescriptorPool">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkAllocateDescriptorSets">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkFreeDescriptorSets">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkUpdateDescriptorSets">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCreateFramebuffer">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkDestroyFramebuffer">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCreateRenderPass">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkDestroyRenderPass">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetRenderAreaGranularity">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCreateCommandPool">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkDestroyCommandPool">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkResetCommandPool">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkAllocateCommandBuffers">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkFreeCommandBuffers">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkBeginCommandBuffer">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkEndCommandBuffer">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkResetCommandBuffer">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdBindPipeline">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdSetViewport">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdSetScissor">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdSetLineWidth">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdSetDepthBias">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdSetBlendConstants">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdSetDepthBounds">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdSetStencilCompareMask">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdSetStencilWriteMask">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdSetStencilReference">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdBindDescriptorSets">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdBindIndexBuffer">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdBindVertexBuffers">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdDraw">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdDrawIndexed">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdDrawIndirect">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdDrawIndexedIndirect">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdDispatch">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdDispatchIndirect">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdCopyBuffer">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdCopyImage">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdBlitImage">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdCopyBufferToImage">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdCopyImageToBuffer">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdUpdateBuffer">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdFillBuffer">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdClearColorImage">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdClearDepthStencilImage">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdClearAttachments">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdResolveImage">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdSetEvent">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdResetEvent">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdWaitEvents">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdPipelineBarrier">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdBeginQuery">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdEndQuery">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdResetQueryPool">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdWriteTimestamp">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdCopyQueryPoolResults">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdPushConstants">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdBeginRenderPass">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdNextSubpass">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdEndRenderPass">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdExecuteCommands">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkDestroySurfaceKHR">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetPhysicalDeviceSurfaceSupportKHR">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetPhysicalDeviceSurfaceCapabilitiesKHR">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetPhysicalDeviceSurfaceFormatsKHR">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetPhysicalDeviceSurfacePresentModesKHR">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCreateSwapchainKHR">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkDestroySwapchainKHR">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetSwapchainImagesKHR">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkAcquireNextImageKHR">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkQueuePresentKHR">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetPhysicalDeviceDisplayPropertiesKHR">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetPhysicalDeviceDisplayPlanePropertiesKHR">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetDisplayPlaneSupportedDisplaysKHR">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetDisplayModePropertiesKHR">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCreateDisplayModeKHR">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetDisplayPlaneCapabilitiesKHR">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCreateDisplayPlaneSurfaceKHR">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCreateSharedSwapchainsKHR">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCreateXlibSurfaceKHR">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetPhysicalDeviceXlibPresentationSupportKHR">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCreateXcbSurfaceKHR">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetPhysicalDeviceXcbPresentationSupportKHR">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCreateWaylandSurfaceKHR">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetPhysicalDeviceWaylandPresentationSupportKHR">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCreateMirSurfaceKHR">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetPhysicalDeviceMirPresentationSupportKHR">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCreateAndroidSurfaceKHR">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCreateWin32SurfaceKHR">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetPhysicalDeviceWin32PresentationSupportKHR">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCreateDebugReportCallbackEXT">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkDestroyDebugReportCallbackEXT">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkDebugReportMessageEXT">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkDebugMarkerSetObjectTagEXT">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkDebugMarkerSetObjectNameEXT">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdDebugMarkerBeginEXT">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdDebugMarkerEndEXT">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdDebugMarkerInsertEXT">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdDrawIndirectCountAMD">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdDrawIndexedIndirectCountAMD">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetPhysicalDeviceExternalImageFormatPropertiesNV">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetMemoryWin32HandleNV">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetPhysicalDeviceFeatures2KHR">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetPhysicalDeviceProperties2KHR">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetPhysicalDeviceFormatProperties2KHR">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetPhysicalDeviceImageFormatProperties2KHR">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetPhysicalDeviceQueueFamilyProperties2KHR">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetPhysicalDeviceMemoryProperties2KHR">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetPhysicalDeviceSparseImageFormatProperties2KHR">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCreateViSurfaceNN">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkTrimCommandPoolKHR">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdProcessCommandsNVX">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCmdReserveSpaceForCommandsNVX">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCreateIndirectCommandsLayoutNVX">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkDestroyIndirectCommandsLayoutNVX">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkCreateObjectTableNVX">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkDestroyObjectTableNVX">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkRegisterObjectsNVX">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkUnregisterObjectsNVX">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkReleaseDisplayEXT">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkAcquireXlibDisplayEXT">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetRandROutputDisplayEXT">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetPhysicalDeviceSurfaceCapabilities2EXT">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkDisplayPowerControlEXT">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkRegisterDeviceEventEXT">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkRegisterDisplayEventEXT">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.vkGetSwapchainCounterEXT">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Interop.DescriptorBufferInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DescriptorBufferInfo.Buffer">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DescriptorBufferInfo.Offset">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DescriptorBufferInfo.Range">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.DescriptorImageInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DescriptorImageInfo.Sampler">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DescriptorImageInfo.ImageView">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DescriptorImageInfo.ImageLayout">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.DescriptorPool">
            <summary>
            <para>
            Opaque handle to a descriptor pool object.
            </para>
            <para>
            A _descriptor pool_ maintains a pool of descriptors, from which
            descriptor sets are allocated. Descriptor pools are externally
            synchronized, meaning that the application must: not allocate and/or
            free descriptor sets from the same pool in multiple threads
            simultaneously.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Interop.DescriptorPool.#ctor(System.UInt64)">
            <summary>
            
            </summary>
        </member>
        <member name="P:SharpVk.Interop.DescriptorPool.Null">
            <summary>
            A read-only property that returns a null DescriptorPool handle.
            </summary>
        </member>
        <member name="M:SharpVk.Interop.DescriptorPool.ToUInt64">
            <summary>
            Returns the marshalled value of this handle as an unsigned 64-bit
            integer.
            </summary>
        </member>
        <member name="T:SharpVk.Interop.DescriptorPoolCreateInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DescriptorPoolCreateInfo.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DescriptorPoolCreateInfo.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DescriptorPoolCreateInfo.Flags">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DescriptorPoolCreateInfo.MaxSets">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DescriptorPoolCreateInfo.PoolSizeCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DescriptorPoolCreateInfo.PoolSizes">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.DescriptorSet">
            <summary>
            Opaque handle to a descriptor set object.
            </summary>
        </member>
        <member name="M:SharpVk.Interop.DescriptorSet.#ctor(System.UInt64)">
            <summary>
            
            </summary>
        </member>
        <member name="P:SharpVk.Interop.DescriptorSet.Null">
            <summary>
            A read-only property that returns a null DescriptorSet handle.
            </summary>
        </member>
        <member name="M:SharpVk.Interop.DescriptorSet.ToUInt64">
            <summary>
            Returns the marshalled value of this handle as an unsigned 64-bit
            integer.
            </summary>
        </member>
        <member name="T:SharpVk.Interop.DescriptorSetAllocateInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DescriptorSetAllocateInfo.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DescriptorSetAllocateInfo.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DescriptorSetAllocateInfo.DescriptorPool">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DescriptorSetAllocateInfo.DescriptorSetCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DescriptorSetAllocateInfo.SetLayouts">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.DescriptorSetLayout">
            <summary>
            <para>
            Opaque handle to a descriptor set layout object.
            </para>
            <para>
            A descriptor set layout object is defined by an array of zero or more
            descriptor bindings. Each individual descriptor binding is specified by
            a descriptor type, a count (array size) of the number of descriptors in
            the binding, a set of shader stages that can: access the binding, and
            (if using immutable samplers) an array of sampler descriptors.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Interop.DescriptorSetLayout.#ctor(System.UInt64)">
            <summary>
            
            </summary>
        </member>
        <member name="P:SharpVk.Interop.DescriptorSetLayout.Null">
            <summary>
            A read-only property that returns a null DescriptorSetLayout
            handle.
            </summary>
        </member>
        <member name="M:SharpVk.Interop.DescriptorSetLayout.ToUInt64">
            <summary>
            Returns the marshalled value of this handle as an unsigned 64-bit
            integer.
            </summary>
        </member>
        <member name="T:SharpVk.Interop.DescriptorSetLayoutBinding">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DescriptorSetLayoutBinding.Binding">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DescriptorSetLayoutBinding.DescriptorType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DescriptorSetLayoutBinding.DescriptorCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DescriptorSetLayoutBinding.StageFlags">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DescriptorSetLayoutBinding.ImmutableSamplers">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.DescriptorSetLayoutCreateInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DescriptorSetLayoutCreateInfo.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DescriptorSetLayoutCreateInfo.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DescriptorSetLayoutCreateInfo.Flags">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DescriptorSetLayoutCreateInfo.BindingCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DescriptorSetLayoutCreateInfo.Bindings">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.Device">
            <summary>
            Opaque handle to a device object.
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Device.#ctor(System.UIntPtr)">
            <summary>
            
            </summary>
        </member>
        <member name="P:SharpVk.Interop.Device.Null">
            <summary>
            A read-only property that returns a null Device handle.
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Device.ToUInt64">
            <summary>
            Returns the marshalled value of this handle as an unsigned 64-bit
            integer.
            </summary>
        </member>
        <member name="T:SharpVk.Interop.DeviceCreateInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DeviceCreateInfo.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DeviceCreateInfo.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DeviceCreateInfo.Flags">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DeviceCreateInfo.QueueCreateInfoCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DeviceCreateInfo.QueueCreateInfos">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DeviceCreateInfo.EnabledLayerCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DeviceCreateInfo.EnabledLayerNames">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DeviceCreateInfo.EnabledExtensionCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DeviceCreateInfo.EnabledExtensionNames">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DeviceCreateInfo.EnabledFeatures">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.DeviceEventInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DeviceEventInfo.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DeviceEventInfo.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DeviceEventInfo.DeviceEvent">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.DeviceGeneratedCommandsFeatures">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DeviceGeneratedCommandsFeatures.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DeviceGeneratedCommandsFeatures.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DeviceGeneratedCommandsFeatures.ComputeBindingPointSupport">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.DeviceGeneratedCommandsLimits">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DeviceGeneratedCommandsLimits.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DeviceGeneratedCommandsLimits.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DeviceGeneratedCommandsLimits.MaxIndirectCommandsLayoutTokenCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DeviceGeneratedCommandsLimits.MaxObjectEntryCounts">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DeviceGeneratedCommandsLimits.MinSequenceCountBufferOffsetAlignment">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DeviceGeneratedCommandsLimits.MinSequenceIndexBufferOffsetAlignment">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DeviceGeneratedCommandsLimits.MinCommandsTokenBufferOffsetAlignment">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.DeviceMemory">
            <summary>
            <para>
            Opaque handle to a device memory object.
            </para>
            <para>
            A Vulkan device operates on data in device memory via memory objects
            that are represented in the API by a sname:VkDeviceMemory handle.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Interop.DeviceMemory.#ctor(System.UInt64)">
            <summary>
            
            </summary>
        </member>
        <member name="P:SharpVk.Interop.DeviceMemory.Null">
            <summary>
            A read-only property that returns a null DeviceMemory handle.
            </summary>
        </member>
        <member name="M:SharpVk.Interop.DeviceMemory.ToUInt64">
            <summary>
            Returns the marshalled value of this handle as an unsigned 64-bit
            integer.
            </summary>
        </member>
        <member name="T:SharpVk.Interop.DeviceQueueCreateInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DeviceQueueCreateInfo.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DeviceQueueCreateInfo.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DeviceQueueCreateInfo.Flags">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DeviceQueueCreateInfo.QueueFamilyIndex">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DeviceQueueCreateInfo.QueueCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DeviceQueueCreateInfo.QueuePriorities">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.Display">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Display.#ctor(System.UInt64)">
            <summary>
            
            </summary>
        </member>
        <member name="P:SharpVk.Interop.Display.Null">
            <summary>
            A read-only property that returns a null Display handle.
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Display.ToUInt64">
            <summary>
            Returns the marshalled value of this handle as an unsigned 64-bit
            integer.
            </summary>
        </member>
        <member name="T:SharpVk.Interop.DisplayEventInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DisplayEventInfo.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DisplayEventInfo.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DisplayEventInfo.DisplayEvent">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.DisplayMode">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.DisplayMode.#ctor(System.UInt64)">
            <summary>
            
            </summary>
        </member>
        <member name="P:SharpVk.Interop.DisplayMode.Null">
            <summary>
            A read-only property that returns a null DisplayMode handle.
            </summary>
        </member>
        <member name="M:SharpVk.Interop.DisplayMode.ToUInt64">
            <summary>
            Returns the marshalled value of this handle as an unsigned 64-bit
            integer.
            </summary>
        </member>
        <member name="T:SharpVk.Interop.DisplayModeCreateInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DisplayModeCreateInfo.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DisplayModeCreateInfo.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DisplayModeCreateInfo.Flags">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DisplayModeCreateInfo.Parameters">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.DisplayModeProperties">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DisplayModeProperties.DisplayMode">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DisplayModeProperties.Parameters">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.DisplayPlaneProperties">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DisplayPlaneProperties.CurrentDisplay">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DisplayPlaneProperties.CurrentStackIndex">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.DisplayPowerInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DisplayPowerInfo.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DisplayPowerInfo.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DisplayPowerInfo.PowerState">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.DisplayPresentInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DisplayPresentInfo.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DisplayPresentInfo.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DisplayPresentInfo.SourceRect">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DisplayPresentInfo.DestinationRect">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DisplayPresentInfo.Persistent">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.DisplayProperties">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DisplayProperties.Display">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DisplayProperties.DisplayName">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DisplayProperties.PhysicalDimensions">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DisplayProperties.PhysicalResolution">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DisplayProperties.SupportedTransforms">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DisplayProperties.PlaneReorderPossible">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DisplayProperties.PersistentContent">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.DisplaySurfaceCreateInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DisplaySurfaceCreateInfo.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DisplaySurfaceCreateInfo.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DisplaySurfaceCreateInfo.Flags">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DisplaySurfaceCreateInfo.DisplayMode">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DisplaySurfaceCreateInfo.PlaneIndex">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DisplaySurfaceCreateInfo.PlaneStackIndex">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DisplaySurfaceCreateInfo.Transform">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DisplaySurfaceCreateInfo.GlobalAlpha">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DisplaySurfaceCreateInfo.AlphaMode">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.DisplaySurfaceCreateInfo.ImageExtent">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.Event">
            <summary>
            <para>
            Opaque handle to a event object.
            </para>
            <para>
            Events are a synchronization primitive that can: be used to insert a
            fine-grained dependency between commands submitted to the same queue,
            or between the host and a queue. Events have two states - signaled and
            unsignaled. An application can: signal an event, or unsignal it, on
            either the host or the device. A device can: wait for an event to
            become signaled before executing further operations. No command exists
            to wait for an event to become signaled on the host, but the current
            state of an event can: be queried.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Event.#ctor(System.UInt64)">
            <summary>
            
            </summary>
        </member>
        <member name="P:SharpVk.Interop.Event.Null">
            <summary>
            A read-only property that returns a null Event handle.
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Event.ToUInt64">
            <summary>
            Returns the marshalled value of this handle as an unsigned 64-bit
            integer.
            </summary>
        </member>
        <member name="T:SharpVk.Interop.EventCreateInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.EventCreateInfo.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.EventCreateInfo.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.EventCreateInfo.Flags">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.ExportMemoryAllocateInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ExportMemoryAllocateInfo.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ExportMemoryAllocateInfo.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ExportMemoryAllocateInfo.HandleTypes">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.ExportMemoryWin32HandleInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ExportMemoryWin32HandleInfo.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ExportMemoryWin32HandleInfo.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ExportMemoryWin32HandleInfo.Attributes">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ExportMemoryWin32HandleInfo.DwAccess">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.ExtensionProperties">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ExtensionProperties.ExtensionName">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ExtensionProperties.SpecVersion">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.ExternalMemoryImageCreateInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ExternalMemoryImageCreateInfo.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ExternalMemoryImageCreateInfo.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ExternalMemoryImageCreateInfo.HandleTypes">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.Fence">
            <summary>
            <para>
            Opaque handle to a fence object.
            </para>
            <para>
            Fences are a synchronization primitive that can: be used to insert a
            dependency from a queue to the host. Fences have two states - signaled
            and unsignaled. A fence can: be signaled as part of the execution of a
            &lt;&lt;devsandqueues-submission, queue submission&gt;&gt; command.
            Fences can: be unsignaled on the host with flink:vkResetFences. Fences
            can: be waited on by the host with the flink:vkWaitForFences command,
            and the current state can: be queried with flink:vkGetFenceStatus.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Fence.#ctor(System.UInt64)">
            <summary>
            
            </summary>
        </member>
        <member name="P:SharpVk.Interop.Fence.Null">
            <summary>
            A read-only property that returns a null Fence handle.
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Fence.ToUInt64">
            <summary>
            Returns the marshalled value of this handle as an unsigned 64-bit
            integer.
            </summary>
        </member>
        <member name="T:SharpVk.Interop.FenceCreateInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.FenceCreateInfo.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.FenceCreateInfo.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.FenceCreateInfo.Flags">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.FormatProperties2">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.FormatProperties2.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.FormatProperties2.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.FormatProperties2.FormatProperties">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.Framebuffer">
            <summary>
            <para>
            Opaque handle to a framebuffer object.
            </para>
            <para>
            Render passes operate in conjunction with _framebuffers_. Framebuffers
            represent a collection of specific memory attachments that a render
            pass instance uses.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Framebuffer.#ctor(System.UInt64)">
            <summary>
            
            </summary>
        </member>
        <member name="P:SharpVk.Interop.Framebuffer.Null">
            <summary>
            A read-only property that returns a null Framebuffer handle.
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Framebuffer.ToUInt64">
            <summary>
            Returns the marshalled value of this handle as an unsigned 64-bit
            integer.
            </summary>
        </member>
        <member name="T:SharpVk.Interop.FramebufferCreateInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.FramebufferCreateInfo.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.FramebufferCreateInfo.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.FramebufferCreateInfo.Flags">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.FramebufferCreateInfo.RenderPass">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.FramebufferCreateInfo.AttachmentCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.FramebufferCreateInfo.Attachments">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.FramebufferCreateInfo.Width">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.FramebufferCreateInfo.Height">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.FramebufferCreateInfo.Layers">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.GraphicsPipelineCreateInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.GraphicsPipelineCreateInfo.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.GraphicsPipelineCreateInfo.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.GraphicsPipelineCreateInfo.Flags">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.GraphicsPipelineCreateInfo.StageCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.GraphicsPipelineCreateInfo.Stages">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.GraphicsPipelineCreateInfo.VertexInputState">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.GraphicsPipelineCreateInfo.InputAssemblyState">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.GraphicsPipelineCreateInfo.TessellationState">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.GraphicsPipelineCreateInfo.ViewportState">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.GraphicsPipelineCreateInfo.RasterizationState">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.GraphicsPipelineCreateInfo.MultisampleState">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.GraphicsPipelineCreateInfo.DepthStencilState">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.GraphicsPipelineCreateInfo.ColorBlendState">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.GraphicsPipelineCreateInfo.DynamicState">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.GraphicsPipelineCreateInfo.Layout">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.GraphicsPipelineCreateInfo.RenderPass">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.GraphicsPipelineCreateInfo.Subpass">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.GraphicsPipelineCreateInfo.BasePipelineHandle">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.GraphicsPipelineCreateInfo.BasePipelineIndex">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.Image">
            <summary>
            <para>
            Opaque handle to a image object.
            </para>
            <para>
            Images represent multidimensional - up to 3 - arrays of data which can:
            be used for various purposes (e.g. attachments, textures), by binding
            them to a graphics or compute pipeline via descriptor sets, or by
            directly specifying them as parameters to certain commands.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Image.#ctor(System.UInt64)">
            <summary>
            
            </summary>
        </member>
        <member name="P:SharpVk.Interop.Image.Null">
            <summary>
            A read-only property that returns a null Image handle.
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Image.ToUInt64">
            <summary>
            Returns the marshalled value of this handle as an unsigned 64-bit
            integer.
            </summary>
        </member>
        <member name="T:SharpVk.Interop.ImageBlit">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageBlit.SourceSubresource">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageBlit.SourceOffsets">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageBlit.DestinationSubresource">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageBlit.DestinationOffsets">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.ImageCreateInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageCreateInfo.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageCreateInfo.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageCreateInfo.Flags">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageCreateInfo.ImageType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageCreateInfo.Format">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageCreateInfo.Extent">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageCreateInfo.MipLevels">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageCreateInfo.ArrayLayers">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageCreateInfo.Samples">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageCreateInfo.Tiling">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageCreateInfo.Usage">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageCreateInfo.SharingMode">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageCreateInfo.QueueFamilyIndexCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageCreateInfo.QueueFamilyIndices">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageCreateInfo.InitialLayout">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.ImageFormatProperties2">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageFormatProperties2.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageFormatProperties2.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageFormatProperties2.ImageFormatProperties">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.ImageMemoryBarrier">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageMemoryBarrier.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageMemoryBarrier.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageMemoryBarrier.SourceAccessMask">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageMemoryBarrier.DestinationAccessMask">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageMemoryBarrier.OldLayout">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageMemoryBarrier.NewLayout">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageMemoryBarrier.SourceQueueFamilyIndex">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageMemoryBarrier.DestinationQueueFamilyIndex">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageMemoryBarrier.Image">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageMemoryBarrier.SubresourceRange">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.ImageView">
            <summary>
            <para>
            Opaque handle to a image view object.
            </para>
            <para>
            Image objects are not directly accessed by pipeline shaders for reading
            or writing image data. Instead, _image views_ representing contiguous
            ranges of the image subresources and containing additional metadata are
            used for that purpose. Views must: be created on images of compatible
            types, and must: represent a valid subset of image subresources.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Interop.ImageView.#ctor(System.UInt64)">
            <summary>
            
            </summary>
        </member>
        <member name="P:SharpVk.Interop.ImageView.Null">
            <summary>
            A read-only property that returns a null ImageView handle.
            </summary>
        </member>
        <member name="M:SharpVk.Interop.ImageView.ToUInt64">
            <summary>
            Returns the marshalled value of this handle as an unsigned 64-bit
            integer.
            </summary>
        </member>
        <member name="T:SharpVk.Interop.ImageViewCreateInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageViewCreateInfo.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageViewCreateInfo.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageViewCreateInfo.Flags">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageViewCreateInfo.Image">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageViewCreateInfo.ViewType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageViewCreateInfo.Format">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageViewCreateInfo.Components">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImageViewCreateInfo.SubresourceRange">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.ImportMemoryWin32HandleInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImportMemoryWin32HandleInfo.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImportMemoryWin32HandleInfo.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImportMemoryWin32HandleInfo.HandleType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ImportMemoryWin32HandleInfo.Handle">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.IndirectCommandsLayout">
            <summary>
            Opaque handle to an indirect commands layout object.
            </summary>
        </member>
        <member name="M:SharpVk.Interop.IndirectCommandsLayout.#ctor(System.UInt64)">
            <summary>
            
            </summary>
        </member>
        <member name="P:SharpVk.Interop.IndirectCommandsLayout.Null">
            <summary>
            A read-only property that returns a null IndirectCommandsLayout
            handle.
            </summary>
        </member>
        <member name="M:SharpVk.Interop.IndirectCommandsLayout.ToUInt64">
            <summary>
            Returns the marshalled value of this handle as an unsigned 64-bit
            integer.
            </summary>
        </member>
        <member name="T:SharpVk.Interop.IndirectCommandsLayoutCreateInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.IndirectCommandsLayoutCreateInfo.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.IndirectCommandsLayoutCreateInfo.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.IndirectCommandsLayoutCreateInfo.PipelineBindPoint">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.IndirectCommandsLayoutCreateInfo.Flags">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.IndirectCommandsLayoutCreateInfo.TokenCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.IndirectCommandsLayoutCreateInfo.Tokens">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.IndirectCommandsToken">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.IndirectCommandsToken.TokenType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.IndirectCommandsToken.Buffer">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.IndirectCommandsToken.Offset">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.Instance">
            <summary>
            <para>
            Opaque handle to a instance object.
            </para>
            <para>
            There is no global state in Vulkan and all per-application state is
            stored in a sname:VkInstance object. Creating a sname:VkInstance object
            initializes the Vulkan library and allows the application to pass
            information about itself to the implementation.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Instance.#ctor(System.UIntPtr)">
            <summary>
            
            </summary>
        </member>
        <member name="P:SharpVk.Interop.Instance.Null">
            <summary>
            A read-only property that returns a null Instance handle.
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Instance.ToUInt64">
            <summary>
            Returns the marshalled value of this handle as an unsigned 64-bit
            integer.
            </summary>
        </member>
        <member name="T:SharpVk.Interop.InstanceCreateInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.InstanceCreateInfo.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.InstanceCreateInfo.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.InstanceCreateInfo.Flags">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.InstanceCreateInfo.ApplicationInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.InstanceCreateInfo.EnabledLayerCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.InstanceCreateInfo.EnabledLayerNames">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.InstanceCreateInfo.EnabledExtensionCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.InstanceCreateInfo.EnabledExtensionNames">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.LayerProperties">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.LayerProperties.LayerName">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.LayerProperties.SpecVersion">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.LayerProperties.ImplementationVersion">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.LayerProperties.Description">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.MappedMemoryRange">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.MappedMemoryRange.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.MappedMemoryRange.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.MappedMemoryRange.Memory">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.MappedMemoryRange.Offset">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.MappedMemoryRange.Size">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.MemoryAllocateInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.MemoryAllocateInfo.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.MemoryAllocateInfo.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.MemoryAllocateInfo.AllocationSize">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.MemoryAllocateInfo.MemoryTypeIndex">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.MemoryBarrier">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.MemoryBarrier.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.MemoryBarrier.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.MemoryBarrier.SourceAccessMask">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.MemoryBarrier.DestinationAccessMask">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.MirSurfaceCreateInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.MirSurfaceCreateInfo.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.MirSurfaceCreateInfo.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.MirSurfaceCreateInfo.Flags">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.MirSurfaceCreateInfo.Connection">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.MirSurfaceCreateInfo.MirSurface">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.ObjectTable">
            <summary>
            Opaque handle to an object table.
            </summary>
        </member>
        <member name="M:SharpVk.Interop.ObjectTable.#ctor(System.UInt64)">
            <summary>
            
            </summary>
        </member>
        <member name="P:SharpVk.Interop.ObjectTable.Null">
            <summary>
            A read-only property that returns a null ObjectTable handle.
            </summary>
        </member>
        <member name="M:SharpVk.Interop.ObjectTable.ToUInt64">
            <summary>
            Returns the marshalled value of this handle as an unsigned 64-bit
            integer.
            </summary>
        </member>
        <member name="T:SharpVk.Interop.ObjectTableCreateInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ObjectTableCreateInfo.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ObjectTableCreateInfo.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ObjectTableCreateInfo.ObjectCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ObjectTableCreateInfo.ObjectEntryTypes">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ObjectTableCreateInfo.ObjectEntryCounts">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ObjectTableCreateInfo.ObjectEntryUsageFlags">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ObjectTableCreateInfo.MaxUniformBuffersPerDescriptor">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ObjectTableCreateInfo.MaxStorageBuffersPerDescriptor">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ObjectTableCreateInfo.MaxStorageImagesPerDescriptor">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ObjectTableCreateInfo.MaxSampledImagesPerDescriptor">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ObjectTableCreateInfo.MaxPipelineLayouts">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.ObjectTableDescriptorSetEntry">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ObjectTableDescriptorSetEntry.Type">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ObjectTableDescriptorSetEntry.Flags">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ObjectTableDescriptorSetEntry.PipelineLayout">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ObjectTableDescriptorSetEntry.DescriptorSet">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.ObjectTableIndexBufferEntry">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ObjectTableIndexBufferEntry.Type">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ObjectTableIndexBufferEntry.Flags">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ObjectTableIndexBufferEntry.Buffer">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ObjectTableIndexBufferEntry.IndexType">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.ObjectTablePipelineEntry">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ObjectTablePipelineEntry.Type">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ObjectTablePipelineEntry.Flags">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ObjectTablePipelineEntry.Pipeline">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.ObjectTablePushConstantEntry">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ObjectTablePushConstantEntry.Type">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ObjectTablePushConstantEntry.Flags">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ObjectTablePushConstantEntry.PipelineLayout">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ObjectTablePushConstantEntry.StageFlags">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.ObjectTableVertexBufferEntry">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ObjectTableVertexBufferEntry.Type">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ObjectTableVertexBufferEntry.Flags">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ObjectTableVertexBufferEntry.Buffer">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.PhysicalDevice">
            <summary>
            <para>
            Opaque handle to a physical device object.
            </para>
            <para>
            Vulkan separates the concept of _physical_ and _logical_ devices. A
            physical device usually represents a single device in a system (perhaps
            made up of several individual hardware devices working together), of
            which there are a finite number. A logical device represents an
            application's view of the device.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Interop.PhysicalDevice.#ctor(System.UIntPtr)">
            <summary>
            
            </summary>
        </member>
        <member name="P:SharpVk.Interop.PhysicalDevice.Null">
            <summary>
            A read-only property that returns a null PhysicalDevice handle.
            </summary>
        </member>
        <member name="M:SharpVk.Interop.PhysicalDevice.ToUInt64">
            <summary>
            Returns the marshalled value of this handle as an unsigned 64-bit
            integer.
            </summary>
        </member>
        <member name="T:SharpVk.Interop.PhysicalDeviceFeatures2">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceFeatures2.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceFeatures2.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceFeatures2.Features">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.PhysicalDeviceImageFormatInfo2">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceImageFormatInfo2.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceImageFormatInfo2.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceImageFormatInfo2.Format">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceImageFormatInfo2.Type">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceImageFormatInfo2.Tiling">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceImageFormatInfo2.Usage">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceImageFormatInfo2.Flags">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.PhysicalDeviceLimits">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxImageDimension1D">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxImageDimension2D">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxImageDimension3D">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxImageDimensionCube">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxImageArrayLayers">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxTexelBufferElements">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxUniformBufferRange">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxStorageBufferRange">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxPushConstantsSize">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxMemoryAllocationCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxSamplerAllocationCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.BufferImageGranularity">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.SparseAddressSpaceSize">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxBoundDescriptorSets">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxPerStageDescriptorSamplers">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxPerStageDescriptorUniformBuffers">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxPerStageDescriptorStorageBuffers">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxPerStageDescriptorSampledImages">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxPerStageDescriptorStorageImages">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxPerStageDescriptorInputAttachments">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxPerStageResources">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxDescriptorSetSamplers">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxDescriptorSetUniformBuffers">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxDescriptorSetUniformBuffersDynamic">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxDescriptorSetStorageBuffers">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxDescriptorSetStorageBuffersDynamic">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxDescriptorSetSampledImages">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxDescriptorSetStorageImages">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxDescriptorSetInputAttachments">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxVertexInputAttributes">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxVertexInputBindings">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxVertexInputAttributeOffset">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxVertexInputBindingStride">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxVertexOutputComponents">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxTessellationGenerationLevel">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxTessellationPatchSize">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxTessellationControlPerVertexInputComponents">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxTessellationControlPerVertexOutputComponents">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxTessellationControlPerPatchOutputComponents">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxTessellationControlTotalOutputComponents">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxTessellationEvaluationInputComponents">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxTessellationEvaluationOutputComponents">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxGeometryShaderInvocations">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxGeometryInputComponents">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxGeometryOutputComponents">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxGeometryOutputVertices">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxGeometryTotalOutputComponents">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxFragmentInputComponents">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxFragmentOutputAttachments">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxFragmentDualSourceAttachments">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxFragmentCombinedOutputResources">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxComputeSharedMemorySize">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxComputeWorkGroupCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxComputeWorkGroupInvocations">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxComputeWorkGroupSize">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.SubPixelPrecisionBits">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.SubTexelPrecisionBits">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MipmapPrecisionBits">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxDrawIndexedIndexValue">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxDrawIndirectCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxSamplerLodBias">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxSamplerAnisotropy">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxViewports">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxViewportDimensions">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.ViewportBoundsRange">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.ViewportSubPixelBits">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MinMemoryMapAlignment">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MinTexelBufferOffsetAlignment">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MinUniformBufferOffsetAlignment">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MinStorageBufferOffsetAlignment">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MinTexelOffset">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxTexelOffset">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MinTexelGatherOffset">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxTexelGatherOffset">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MinInterpolationOffset">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxInterpolationOffset">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.SubPixelInterpolationOffsetBits">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxFramebufferWidth">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxFramebufferHeight">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxFramebufferLayers">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.FramebufferColorSampleCounts">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.FramebufferDepthSampleCounts">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.FramebufferStencilSampleCounts">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.FramebufferNoAttachmentsSampleCounts">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxColorAttachments">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.SampledImageColorSampleCounts">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.SampledImageIntegerSampleCounts">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.SampledImageDepthSampleCounts">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.SampledImageStencilSampleCounts">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.StorageImageSampleCounts">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxSampleMaskWords">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.TimestampComputeAndGraphics">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.TimestampPeriod">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxClipDistances">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxCullDistances">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.MaxCombinedClipAndCullDistances">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.DiscreteQueuePriorities">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.PointSizeRange">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.LineWidthRange">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.PointSizeGranularity">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.LineWidthGranularity">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.StrictLines">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.StandardSampleLocations">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.OptimalBufferCopyOffsetAlignment">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.OptimalBufferCopyRowPitchAlignment">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceLimits.NonCoherentAtomSize">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.PhysicalDeviceMemoryProperties">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceMemoryProperties.MemoryTypeCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceMemoryProperties.MemoryTypes">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceMemoryProperties.MemoryHeapCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceMemoryProperties.MemoryHeaps">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.PhysicalDeviceMemoryProperties2">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceMemoryProperties2.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceMemoryProperties2.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceMemoryProperties2.MemoryProperties">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.PhysicalDeviceProperties">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceProperties.ApiVersion">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceProperties.DriverVersion">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceProperties.VendorID">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceProperties.DeviceID">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceProperties.DeviceType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceProperties.DeviceName">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceProperties.PipelineCacheUUID">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceProperties.Limits">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceProperties.SparseProperties">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.PhysicalDeviceProperties2">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceProperties2.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceProperties2.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceProperties2.Properties">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.PhysicalDeviceSparseImageFormatInfo2">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceSparseImageFormatInfo2.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceSparseImageFormatInfo2.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceSparseImageFormatInfo2.Format">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceSparseImageFormatInfo2.Type">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceSparseImageFormatInfo2.Samples">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceSparseImageFormatInfo2.Usage">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PhysicalDeviceSparseImageFormatInfo2.Tiling">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.Pipeline">
            <summary>
            Opaque handle to a pipeline object.
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Pipeline.#ctor(System.UInt64)">
            <summary>
            
            </summary>
        </member>
        <member name="P:SharpVk.Interop.Pipeline.Null">
            <summary>
            A read-only property that returns a null Pipeline handle.
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Pipeline.ToUInt64">
            <summary>
            Returns the marshalled value of this handle as an unsigned 64-bit
            integer.
            </summary>
        </member>
        <member name="T:SharpVk.Interop.PipelineCache">
            <summary>
            <para>
            Opaque handle to a pipeline cache object.
            </para>
            <para>
            Pipeline cache objects allow the result of pipeline construction to be
            reused between pipelines and between runs of an application. Reuse
            between pipelines is achieved by passing the same pipeline cache object
            when creating multiple related pipelines. Reuse across runs of an
            application is achieved by retrieving pipeline cache contents in one
            run of an application, saving the contents, and using them to
            preinitialize a pipeline cache on a subsequent run. The contents of the
            pipeline cache objects are managed by the implementation. Applications
            can: manage the host memory consumed by a pipeline cache object and
            control the amount of data retrieved from a pipeline cache object.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Interop.PipelineCache.#ctor(System.UInt64)">
            <summary>
            
            </summary>
        </member>
        <member name="P:SharpVk.Interop.PipelineCache.Null">
            <summary>
            A read-only property that returns a null PipelineCache handle.
            </summary>
        </member>
        <member name="M:SharpVk.Interop.PipelineCache.ToUInt64">
            <summary>
            Returns the marshalled value of this handle as an unsigned 64-bit
            integer.
            </summary>
        </member>
        <member name="T:SharpVk.Interop.PipelineCacheCreateInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineCacheCreateInfo.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineCacheCreateInfo.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineCacheCreateInfo.Flags">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineCacheCreateInfo.InitialDataSize">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineCacheCreateInfo.InitialData">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.PipelineColorBlendStateCreateInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineColorBlendStateCreateInfo.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineColorBlendStateCreateInfo.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineColorBlendStateCreateInfo.Flags">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineColorBlendStateCreateInfo.LogicOpEnable">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineColorBlendStateCreateInfo.LogicOp">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineColorBlendStateCreateInfo.AttachmentCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineColorBlendStateCreateInfo.Attachments">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineColorBlendStateCreateInfo.BlendConstants">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.PipelineDepthStencilStateCreateInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineDepthStencilStateCreateInfo.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineDepthStencilStateCreateInfo.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineDepthStencilStateCreateInfo.Flags">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineDepthStencilStateCreateInfo.DepthTestEnable">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineDepthStencilStateCreateInfo.DepthWriteEnable">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineDepthStencilStateCreateInfo.DepthCompareOp">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineDepthStencilStateCreateInfo.DepthBoundsTestEnable">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineDepthStencilStateCreateInfo.StencilTestEnable">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineDepthStencilStateCreateInfo.Front">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineDepthStencilStateCreateInfo.Back">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineDepthStencilStateCreateInfo.MinDepthBounds">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineDepthStencilStateCreateInfo.MaxDepthBounds">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.PipelineDynamicStateCreateInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineDynamicStateCreateInfo.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineDynamicStateCreateInfo.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineDynamicStateCreateInfo.Flags">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineDynamicStateCreateInfo.DynamicStateCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineDynamicStateCreateInfo.DynamicStates">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.PipelineInputAssemblyStateCreateInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineInputAssemblyStateCreateInfo.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineInputAssemblyStateCreateInfo.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineInputAssemblyStateCreateInfo.Flags">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineInputAssemblyStateCreateInfo.Topology">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineInputAssemblyStateCreateInfo.PrimitiveRestartEnable">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.PipelineLayout">
            <summary>
            <para>
            Opaque handle to a pipeline layout object.
            </para>
            <para>
            Access to descriptor sets from a pipeline is accomplished through a
            _pipeline layout_. Zero or more descriptor set layouts and zero or more
            push constant ranges are combined to form a pipeline layout object
            which describes the complete set of resources that can: be accessed by
            a pipeline. The pipeline layout represents a sequence of descriptor
            sets with each having a specific layout. This sequence of layouts is
            used to determine the interface between shader stages and shader
            resources. Each pipeline is created using a pipeline layout.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Interop.PipelineLayout.#ctor(System.UInt64)">
            <summary>
            
            </summary>
        </member>
        <member name="P:SharpVk.Interop.PipelineLayout.Null">
            <summary>
            A read-only property that returns a null PipelineLayout handle.
            </summary>
        </member>
        <member name="M:SharpVk.Interop.PipelineLayout.ToUInt64">
            <summary>
            Returns the marshalled value of this handle as an unsigned 64-bit
            integer.
            </summary>
        </member>
        <member name="T:SharpVk.Interop.PipelineLayoutCreateInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineLayoutCreateInfo.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineLayoutCreateInfo.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineLayoutCreateInfo.Flags">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineLayoutCreateInfo.SetLayoutCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineLayoutCreateInfo.SetLayouts">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineLayoutCreateInfo.PushConstantRangeCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineLayoutCreateInfo.PushConstantRanges">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.PipelineMultisampleStateCreateInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineMultisampleStateCreateInfo.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineMultisampleStateCreateInfo.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineMultisampleStateCreateInfo.Flags">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineMultisampleStateCreateInfo.RasterizationSamples">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineMultisampleStateCreateInfo.SampleShadingEnable">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineMultisampleStateCreateInfo.MinSampleShading">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineMultisampleStateCreateInfo.SampleMask">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineMultisampleStateCreateInfo.AlphaToCoverageEnable">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineMultisampleStateCreateInfo.AlphaToOneEnable">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.PipelineRasterizationStateCreateInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineRasterizationStateCreateInfo.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineRasterizationStateCreateInfo.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineRasterizationStateCreateInfo.Flags">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineRasterizationStateCreateInfo.DepthClampEnable">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineRasterizationStateCreateInfo.RasterizerDiscardEnable">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineRasterizationStateCreateInfo.PolygonMode">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineRasterizationStateCreateInfo.CullMode">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineRasterizationStateCreateInfo.FrontFace">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineRasterizationStateCreateInfo.DepthBiasEnable">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineRasterizationStateCreateInfo.DepthBiasConstantFactor">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineRasterizationStateCreateInfo.DepthBiasClamp">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineRasterizationStateCreateInfo.DepthBiasSlopeFactor">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineRasterizationStateCreateInfo.LineWidth">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.PipelineRasterizationStateRasterizationOrder">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineRasterizationStateRasterizationOrder.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineRasterizationStateRasterizationOrder.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineRasterizationStateRasterizationOrder.RasterizationOrder">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.PipelineShaderStageCreateInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineShaderStageCreateInfo.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineShaderStageCreateInfo.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineShaderStageCreateInfo.Flags">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineShaderStageCreateInfo.Stage">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineShaderStageCreateInfo.Module">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineShaderStageCreateInfo.Name">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineShaderStageCreateInfo.SpecializationInfo">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.PipelineTessellationStateCreateInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineTessellationStateCreateInfo.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineTessellationStateCreateInfo.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineTessellationStateCreateInfo.Flags">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineTessellationStateCreateInfo.PatchControlPoints">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.PipelineVertexInputStateCreateInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineVertexInputStateCreateInfo.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineVertexInputStateCreateInfo.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineVertexInputStateCreateInfo.Flags">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineVertexInputStateCreateInfo.VertexBindingDescriptionCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineVertexInputStateCreateInfo.VertexBindingDescriptions">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineVertexInputStateCreateInfo.VertexAttributeDescriptionCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineVertexInputStateCreateInfo.VertexAttributeDescriptions">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.PipelineViewportStateCreateInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineViewportStateCreateInfo.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineViewportStateCreateInfo.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineViewportStateCreateInfo.Flags">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineViewportStateCreateInfo.ViewportCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineViewportStateCreateInfo.Viewports">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineViewportStateCreateInfo.ScissorCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PipelineViewportStateCreateInfo.Scissors">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.PresentInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PresentInfo.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PresentInfo.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PresentInfo.WaitSemaphoreCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PresentInfo.WaitSemaphores">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PresentInfo.SwapchainCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PresentInfo.Swapchains">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PresentInfo.ImageIndices">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.PresentInfo.Results">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.QueryPool">
            <summary>
            <para>
            Opaque handle to a query pool object.
            </para>
            <para>
            Queries are managed using _query pool_ objects. Each query pool is a
            collection of a specific number of queries of a particular type.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Interop.QueryPool.#ctor(System.UInt64)">
            <summary>
            
            </summary>
        </member>
        <member name="P:SharpVk.Interop.QueryPool.Null">
            <summary>
            A read-only property that returns a null QueryPool handle.
            </summary>
        </member>
        <member name="M:SharpVk.Interop.QueryPool.ToUInt64">
            <summary>
            Returns the marshalled value of this handle as an unsigned 64-bit
            integer.
            </summary>
        </member>
        <member name="T:SharpVk.Interop.QueryPoolCreateInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.QueryPoolCreateInfo.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.QueryPoolCreateInfo.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.QueryPoolCreateInfo.Flags">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.QueryPoolCreateInfo.QueryType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.QueryPoolCreateInfo.QueryCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.QueryPoolCreateInfo.PipelineStatistics">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.Queue">
            <summary>
            <para>
            Opaque handle to a queue object.
            </para>
            <para>
            Creating a logical device also creates the queues associated with that
            device. The queues to create are described by a set of
            slink:VkDeviceQueueCreateInfo structures that are passed to
            flink:vkCreateDevice in pname:pQueueCreateInfos.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Queue.#ctor(System.UIntPtr)">
            <summary>
            
            </summary>
        </member>
        <member name="P:SharpVk.Interop.Queue.Null">
            <summary>
            A read-only property that returns a null Queue handle.
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Queue.ToUInt64">
            <summary>
            Returns the marshalled value of this handle as an unsigned 64-bit
            integer.
            </summary>
        </member>
        <member name="T:SharpVk.Interop.QueueFamilyProperties2">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.QueueFamilyProperties2.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.QueueFamilyProperties2.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.QueueFamilyProperties2.QueueFamilyProperties">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.RenderPass">
            <summary>
            <para>
            Opaque handle to a render pass object.
            </para>
            <para>
            A _render pass_ represents a collection of attachments, subpasses, and
            dependencies between the subpasses, and describes how the attachments
            are used over the course of the subpasses. The use of a render pass in
            a command buffer is a _render pass instance_.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Interop.RenderPass.#ctor(System.UInt64)">
            <summary>
            
            </summary>
        </member>
        <member name="P:SharpVk.Interop.RenderPass.Null">
            <summary>
            A read-only property that returns a null RenderPass handle.
            </summary>
        </member>
        <member name="M:SharpVk.Interop.RenderPass.ToUInt64">
            <summary>
            Returns the marshalled value of this handle as an unsigned 64-bit
            integer.
            </summary>
        </member>
        <member name="T:SharpVk.Interop.RenderPassBeginInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.RenderPassBeginInfo.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.RenderPassBeginInfo.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.RenderPassBeginInfo.RenderPass">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.RenderPassBeginInfo.Framebuffer">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.RenderPassBeginInfo.RenderArea">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.RenderPassBeginInfo.ClearValueCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.RenderPassBeginInfo.ClearValues">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.RenderPassCreateInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.RenderPassCreateInfo.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.RenderPassCreateInfo.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.RenderPassCreateInfo.Flags">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.RenderPassCreateInfo.AttachmentCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.RenderPassCreateInfo.Attachments">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.RenderPassCreateInfo.SubpassCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.RenderPassCreateInfo.Subpasses">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.RenderPassCreateInfo.DependencyCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.RenderPassCreateInfo.Dependencies">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.Sampler">
            <summary>
            <para>
            Opaque handle to a sampler object.
            </para>
            <para>
            sname:VkSampler objects represent the state of an image sampler which
            is used by the implementation to read image data and apply filtering
            and other transformations for the shader.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Sampler.#ctor(System.UInt64)">
            <summary>
            
            </summary>
        </member>
        <member name="P:SharpVk.Interop.Sampler.Null">
            <summary>
            A read-only property that returns a null Sampler handle.
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Sampler.ToUInt64">
            <summary>
            Returns the marshalled value of this handle as an unsigned 64-bit
            integer.
            </summary>
        </member>
        <member name="T:SharpVk.Interop.SamplerCreateInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SamplerCreateInfo.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SamplerCreateInfo.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SamplerCreateInfo.Flags">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SamplerCreateInfo.MagFilter">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SamplerCreateInfo.MinFilter">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SamplerCreateInfo.MipmapMode">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SamplerCreateInfo.AddressModeU">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SamplerCreateInfo.AddressModeV">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SamplerCreateInfo.AddressModeW">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SamplerCreateInfo.MipLodBias">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SamplerCreateInfo.AnisotropyEnable">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SamplerCreateInfo.MaxAnisotropy">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SamplerCreateInfo.CompareEnable">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SamplerCreateInfo.CompareOp">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SamplerCreateInfo.MinLod">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SamplerCreateInfo.MaxLod">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SamplerCreateInfo.BorderColor">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SamplerCreateInfo.UnnormalizedCoordinates">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.Semaphore">
            <summary>
            <para>
            Opaque handle to a semaphore object.
            </para>
            <para>
            Semaphores are a synchronization primitive that can: be used to insert
            a dependency between batches submitted to queues. Semaphores have two
            states - signaled and unsignaled. The state of a semaphore can: be
            signaled after execution of a batch of commands is completed. A batch
            can: wait for a semaphore to become signaled before it begins
            execution, and the semaphore is also unsignaled before the batch begins
            execution.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Semaphore.#ctor(System.UInt64)">
            <summary>
            
            </summary>
        </member>
        <member name="P:SharpVk.Interop.Semaphore.Null">
            <summary>
            A read-only property that returns a null Semaphore handle.
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Semaphore.ToUInt64">
            <summary>
            Returns the marshalled value of this handle as an unsigned 64-bit
            integer.
            </summary>
        </member>
        <member name="T:SharpVk.Interop.SemaphoreCreateInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SemaphoreCreateInfo.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SemaphoreCreateInfo.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SemaphoreCreateInfo.Flags">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.ShaderModule">
            <summary>
            <para>
            Opaque handle to a shader module object.
            </para>
            <para>
            _Shader modules_ contain _shader code_ and one or more entry points.
            Shaders are selected from a shader module by specifying an entry point
            as part of &lt;&lt;pipelines,pipeline&gt;&gt; creation. The stages of a
            pipeline can: use shaders that come from different modules. The shader
            code defining a shader module must: be in the SPIR-V format, as
            described by the &lt;&lt;spirvenv,Vulkan Environment for SPIR-V&gt;&gt;
            appendix.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Interop.ShaderModule.#ctor(System.UInt64)">
            <summary>
            
            </summary>
        </member>
        <member name="P:SharpVk.Interop.ShaderModule.Null">
            <summary>
            A read-only property that returns a null ShaderModule handle.
            </summary>
        </member>
        <member name="M:SharpVk.Interop.ShaderModule.ToUInt64">
            <summary>
            Returns the marshalled value of this handle as an unsigned 64-bit
            integer.
            </summary>
        </member>
        <member name="T:SharpVk.Interop.ShaderModuleCreateInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ShaderModuleCreateInfo.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ShaderModuleCreateInfo.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ShaderModuleCreateInfo.Flags">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ShaderModuleCreateInfo.CodeSize">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ShaderModuleCreateInfo.Code">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.SparseBufferMemoryBindInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SparseBufferMemoryBindInfo.Buffer">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SparseBufferMemoryBindInfo.BindCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SparseBufferMemoryBindInfo.Binds">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.SparseImageFormatProperties2">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SparseImageFormatProperties2.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SparseImageFormatProperties2.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SparseImageFormatProperties2.Properties">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.SparseImageMemoryBind">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SparseImageMemoryBind.Subresource">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SparseImageMemoryBind.Offset">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SparseImageMemoryBind.Extent">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SparseImageMemoryBind.Memory">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SparseImageMemoryBind.MemoryOffset">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SparseImageMemoryBind.Flags">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.SparseImageMemoryBindInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SparseImageMemoryBindInfo.Image">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SparseImageMemoryBindInfo.BindCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SparseImageMemoryBindInfo.Binds">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.SparseImageOpaqueMemoryBindInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SparseImageOpaqueMemoryBindInfo.Image">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SparseImageOpaqueMemoryBindInfo.BindCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SparseImageOpaqueMemoryBindInfo.Binds">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.SparseMemoryBind">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SparseMemoryBind.ResourceOffset">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SparseMemoryBind.Size">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SparseMemoryBind.Memory">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SparseMemoryBind.MemoryOffset">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SparseMemoryBind.Flags">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.SpecializationInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SpecializationInfo.MapEntryCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SpecializationInfo.MapEntries">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SpecializationInfo.DataSize">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SpecializationInfo.Data">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.SubmitInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SubmitInfo.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SubmitInfo.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SubmitInfo.WaitSemaphoreCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SubmitInfo.WaitSemaphores">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SubmitInfo.WaitDestinationStageMask">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SubmitInfo.CommandBufferCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SubmitInfo.CommandBuffers">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SubmitInfo.SignalSemaphoreCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SubmitInfo.SignalSemaphores">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.SubpassDescription">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SubpassDescription.Flags">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SubpassDescription.PipelineBindPoint">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SubpassDescription.InputAttachmentCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SubpassDescription.InputAttachments">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SubpassDescription.ColorAttachmentCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SubpassDescription.ColorAttachments">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SubpassDescription.ResolveAttachments">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SubpassDescription.DepthStencilAttachment">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SubpassDescription.PreserveAttachmentCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SubpassDescription.PreserveAttachments">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.Surface">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Surface.#ctor(System.UInt64)">
            <summary>
            
            </summary>
        </member>
        <member name="P:SharpVk.Interop.Surface.Null">
            <summary>
            A read-only property that returns a null Surface handle.
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Surface.ToUInt64">
            <summary>
            Returns the marshalled value of this handle as an unsigned 64-bit
            integer.
            </summary>
        </member>
        <member name="T:SharpVk.Interop.SurfaceCapabilities2">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SurfaceCapabilities2.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SurfaceCapabilities2.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SurfaceCapabilities2.MinImageCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SurfaceCapabilities2.MaxImageCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SurfaceCapabilities2.CurrentExtent">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SurfaceCapabilities2.MinImageExtent">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SurfaceCapabilities2.MaxImageExtent">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SurfaceCapabilities2.MaxImageArrayLayers">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SurfaceCapabilities2.SupportedTransforms">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SurfaceCapabilities2.CurrentTransform">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SurfaceCapabilities2.SupportedCompositeAlpha">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SurfaceCapabilities2.SupportedUsageFlags">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SurfaceCapabilities2.SupportedSurfaceCounters">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.Swapchain">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Swapchain.#ctor(System.UInt64)">
            <summary>
            
            </summary>
        </member>
        <member name="P:SharpVk.Interop.Swapchain.Null">
            <summary>
            A read-only property that returns a null Swapchain handle.
            </summary>
        </member>
        <member name="M:SharpVk.Interop.Swapchain.ToUInt64">
            <summary>
            Returns the marshalled value of this handle as an unsigned 64-bit
            integer.
            </summary>
        </member>
        <member name="T:SharpVk.Interop.SwapchainCounterCreateInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SwapchainCounterCreateInfo.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SwapchainCounterCreateInfo.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SwapchainCounterCreateInfo.SurfaceCounters">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.SwapchainCreateInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SwapchainCreateInfo.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SwapchainCreateInfo.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SwapchainCreateInfo.Flags">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SwapchainCreateInfo.Surface">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SwapchainCreateInfo.MinImageCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SwapchainCreateInfo.ImageFormat">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SwapchainCreateInfo.ImageColorSpace">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SwapchainCreateInfo.ImageExtent">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SwapchainCreateInfo.ImageArrayLayers">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SwapchainCreateInfo.ImageUsage">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SwapchainCreateInfo.ImageSharingMode">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SwapchainCreateInfo.QueueFamilyIndexCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SwapchainCreateInfo.QueueFamilyIndices">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SwapchainCreateInfo.PreTransform">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SwapchainCreateInfo.CompositeAlpha">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SwapchainCreateInfo.PresentMode">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SwapchainCreateInfo.Clipped">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.SwapchainCreateInfo.OldSwapchain">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.ValidationFlags">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ValidationFlags.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ValidationFlags.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ValidationFlags.DisabledValidationCheckCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ValidationFlags.DisabledValidationChecks">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.ViSurfaceCreateInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ViSurfaceCreateInfo.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ViSurfaceCreateInfo.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ViSurfaceCreateInfo.Flags">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.ViSurfaceCreateInfo.Window">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.WaylandSurfaceCreateInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.WaylandSurfaceCreateInfo.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.WaylandSurfaceCreateInfo.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.WaylandSurfaceCreateInfo.Flags">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.WaylandSurfaceCreateInfo.Display">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.WaylandSurfaceCreateInfo.Surface">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.Win32KeyedMutexAcquireReleaseInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.Win32KeyedMutexAcquireReleaseInfo.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.Win32KeyedMutexAcquireReleaseInfo.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.Win32KeyedMutexAcquireReleaseInfo.AcquireCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.Win32KeyedMutexAcquireReleaseInfo.AcquireSyncs">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.Win32KeyedMutexAcquireReleaseInfo.AcquireKeys">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.Win32KeyedMutexAcquireReleaseInfo.AcquireTimeoutMilliseconds">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.Win32KeyedMutexAcquireReleaseInfo.ReleaseCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.Win32KeyedMutexAcquireReleaseInfo.ReleaseSyncs">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.Win32KeyedMutexAcquireReleaseInfo.ReleaseKeys">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.Win32SurfaceCreateInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.Win32SurfaceCreateInfo.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.Win32SurfaceCreateInfo.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.Win32SurfaceCreateInfo.Flags">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.Win32SurfaceCreateInfo.Hinstance">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.Win32SurfaceCreateInfo.Hwnd">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.WriteDescriptorSet">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.WriteDescriptorSet.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.WriteDescriptorSet.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.WriteDescriptorSet.DestinationSet">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.WriteDescriptorSet.DestinationBinding">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.WriteDescriptorSet.DestinationArrayElement">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.WriteDescriptorSet.DescriptorCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.WriteDescriptorSet.DescriptorType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.WriteDescriptorSet.ImageInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.WriteDescriptorSet.BufferInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.WriteDescriptorSet.TexelBufferView">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.XcbSurfaceCreateInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.XcbSurfaceCreateInfo.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.XcbSurfaceCreateInfo.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.XcbSurfaceCreateInfo.Flags">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.XcbSurfaceCreateInfo.Connection">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.XcbSurfaceCreateInfo.Window">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Interop.XlibSurfaceCreateInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.XlibSurfaceCreateInfo.SType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.XlibSurfaceCreateInfo.Next">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.XlibSurfaceCreateInfo.Flags">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.XlibSurfaceCreateInfo.Dpy">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Interop.XlibSurfaceCreateInfo.Window">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.LayerProperties">
            <summary>
            Structure specifying layer properties.
            </summary>
        </member>
        <member name="P:SharpVk.LayerProperties.LayerName">
            <summary>
            pname:layerName is a null-terminated UTF-8 string specifying the
            name of the layer. Use this name in the pname:ppEnabledLayerNames
            array passed in the slink:VkInstanceCreateInfo structure to enable
            this layer for an instance.
            </summary>
        </member>
        <member name="P:SharpVk.LayerProperties.SpecVersion">
            <summary>
            pname:specVersion is the Vulkan version the layer was written to,
            encoded as described in the &lt;&lt;fundamentals-versionnum,API
            Version Numbers and Semantics&gt;&gt; section.
            </summary>
        </member>
        <member name="P:SharpVk.LayerProperties.ImplementationVersion">
            <summary>
            pname:implementationVersion is the version of this layer. It is an
            integer, increasing with backward compatible changes.
            </summary>
        </member>
        <member name="P:SharpVk.LayerProperties.Description">
            <summary>
            pname:description is a null-terminated UTF-8 string providing
            additional details that can: be used by the application to identify
            the layer.
            </summary>
        </member>
        <member name="T:SharpVk.LogicOp">
            <summary>
            <para>
            Framebuffer logical operations.
            </para>
            <para>
            &lt;&lt;&lt;
            </para>
            <para>
            The logical operations supported by Vulkan are summarized in the
            following table in which
            </para>
            <para>
            * [eq]#{lnot}# is bitwise invert, * [eq]#{land}# is bitwise and, *
            [eq]#{lor}# is bitwise or, * [eq]#{oplus}# is bitwise exclusive or, *
            [eq]#s# is the fragment's [eq]#R~s0~, G~s0~, B~s0~# or [eq]#A~s0~#
            component value for the fragment output corresponding to the color
            attachment being updated, and * [eq]#d# is the color attachment's
            [eq]#R, G, B# or [eq]#A# component value:
            </para>
            <para>
            .Logical Operations [width="75%",options="header",align="center"] |====
            |Mode | Operation |ename:VK_LOGIC_OP_CLEAR | [eq]#0#
            |ename:VK_LOGIC_OP_AND | [eq]#s {land} d#
            |ename:VK_LOGIC_OP_AND_REVERSE | [eq]#s {land} {lnot} d#
            |ename:VK_LOGIC_OP_COPY | [eq]#s# |ename:VK_LOGIC_OP_AND_INVERTED |
            [eq]#{lnot} s {land} d# |ename:VK_LOGIC_OP_NO_OP | [eq]#d#
            |ename:VK_LOGIC_OP_XOR | [eq]#s {oplus} d# |ename:VK_LOGIC_OP_OR |
            [eq]#s {lor} d# |ename:VK_LOGIC_OP_NOR | [eq]#{lnot} (s {lor} d)#
            |ename:VK_LOGIC_OP_EQUIVALENT | [eq]#{lnot} (s {oplus} d)#
            |ename:VK_LOGIC_OP_INVERT | [eq]#{lnot} d#
            |ename:VK_LOGIC_OP_OR_REVERSE | [eq]#s {lor} {lnot} d#
            |ename:VK_LOGIC_OP_COPY_INVERTED | [eq]#{lnot} s#
            |ename:VK_LOGIC_OP_OR_INVERTED | [eq]#{lnot} s {lor} d#
            |ename:VK_LOGIC_OP_NAND | [eq]#{lnot} (s {land} d)#
            |ename:VK_LOGIC_OP_SET | all 1s |====
            </para>
            <para>
            The result of the logical operation is then written to the color
            attachment as controlled by the component write mask, described in
            &lt;&lt;framebuffer-blendoperations,Blend Operations&gt;&gt;.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.LogicOp.Clear">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.LogicOp.And">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.LogicOp.AndReverse">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.LogicOp.Copy">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.LogicOp.AndInverted">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.LogicOp.NoOp">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.LogicOp.Xor">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.LogicOp.Or">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.LogicOp.Nor">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.LogicOp.Equivalent">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.LogicOp.Invert">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.LogicOp.OrReverse">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.LogicOp.CopyInverted">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.LogicOp.OrInverted">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.LogicOp.Nand">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.LogicOp.Set">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.MappedMemoryRange">
            <summary>
            Structure specifying a mapped memory range.
            </summary>
        </member>
        <member name="P:SharpVk.MappedMemoryRange.Memory">
            <summary>
            pname:memory is the memory object to which this range belongs.
            </summary>
        </member>
        <member name="P:SharpVk.MappedMemoryRange.Offset">
            <summary>
            pname:offset is the zero-based byte offset from the beginning of
            the memory object.
            </summary>
        </member>
        <member name="P:SharpVk.MappedMemoryRange.Size">
            <summary>
            pname:size is either the size of range, or ename:VK_WHOLE_SIZE to
            affect the range from pname:offset to the end of the current
            mapping of the allocation.
            </summary>
        </member>
        <member name="T:SharpVk.MemoryAllocateInfo">
            <summary>
            Structure containing parameters of a memory allocation.
            </summary>
        </member>
        <member name="P:SharpVk.MemoryAllocateInfo.AllocationSize">
            <summary>
            pname:allocationSize is the size of the allocation in bytes
            </summary>
        </member>
        <member name="P:SharpVk.MemoryAllocateInfo.MemoryTypeIndex">
            <summary>
            pname:memoryTypeIndex is the memory type index, which selects the
            properties of the memory to be allocated, as well as the heap the
            memory will come from.
            </summary>
        </member>
        <member name="T:SharpVk.MemoryBarrier">
            <summary>
            <para>
            Structure specifying a global memory barrier.
            </para>
            <para>
            The first &lt;&lt;synchronization-dependencies-access-scopes, access
            scope&gt;&gt; is limited to access types in the
            &lt;&lt;synchronization-access-masks, source access mask&gt;&gt;
            specified by pname:srcAccessMask.
            </para>
            <para>
            The second &lt;&lt;synchronization-dependencies-access-scopes, access
            scope&gt;&gt; is limited to access types in the
            &lt;&lt;synchronization-access-masks, destination access mask&gt;&gt;
            specified by pname:dstAccessMask.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.MemoryBarrier.SourceAccessMask">
            <summary>
            pname:srcAccessMask defines a &lt;&lt;synchronization-access-masks,
            source access mask&gt;&gt;.
            </summary>
        </member>
        <member name="P:SharpVk.MemoryBarrier.DestinationAccessMask">
            <summary>
            pname:dstAccessMask defines a &lt;&lt;synchronization-access-masks,
            destination access mask&gt;&gt;.
            </summary>
        </member>
        <member name="T:SharpVk.MemoryHeap">
            <summary>
            Structure specifying a memory heap.
            </summary>
        </member>
        <member name="M:SharpVk.MemoryHeap.#ctor(SharpVk.DeviceSize,SharpVk.MemoryHeapFlags)">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.MemoryHeap.Size">
            <summary>
            pname:size is the total memory size in bytes in the heap.
            </summary>
        </member>
        <member name="F:SharpVk.MemoryHeap.Flags">
            <summary>
            pname:flags is a bitmask of attribute flags for the heap. The bits
            specified in pname:flags are: + --
            </summary>
        </member>
        <member name="M:SharpVk.MemoryHeap.ToString">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.MemoryHeapFlags">
            <summary>
            Bitmask specifying attribute flags for a heap.
            </summary>
        </member>
        <member name="F:SharpVk.MemoryHeapFlags.None">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.MemoryHeapFlags.DeviceLocal">
            <summary>
            If set, heap represents device memory
            </summary>
        </member>
        <member name="T:SharpVk.MemoryMapFlags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.MemoryMapFlags.None">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.MemoryPropertyFlags">
            <summary>
            Bitmask specifying properties for a memory type.
            </summary>
        </member>
        <member name="F:SharpVk.MemoryPropertyFlags.None">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.MemoryPropertyFlags.DeviceLocal">
            <summary>
            If otherwise stated, then allocate memory on device
            </summary>
        </member>
        <member name="F:SharpVk.MemoryPropertyFlags.HostVisible">
            <summary>
            Memory is mappable by host
            </summary>
        </member>
        <member name="F:SharpVk.MemoryPropertyFlags.HostCoherent">
            <summary>
            Memory will have i/o coherency. If not set, application may need to
            use vkFlushMappedMemoryRanges and vkInvalidateMappedMemoryRanges to
            flush/invalidate host cache
            </summary>
        </member>
        <member name="F:SharpVk.MemoryPropertyFlags.HostCached">
            <summary>
            Memory will be cached by the host
            </summary>
        </member>
        <member name="F:SharpVk.MemoryPropertyFlags.LazilyAllocated">
            <summary>
            Memory may be allocated by the driver when it is required
            </summary>
        </member>
        <member name="T:SharpVk.MemoryRequirements">
            <summary>
            Structure specifying memory requirements.
            </summary>
        </member>
        <member name="M:SharpVk.MemoryRequirements.#ctor(SharpVk.DeviceSize,SharpVk.DeviceSize,System.UInt32)">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.MemoryRequirements.Size">
            <summary>
            pname:size is the size, in bytes, of the memory allocation
            required: for the resource.
            </summary>
        </member>
        <member name="F:SharpVk.MemoryRequirements.Alignment">
            <summary>
            pname:alignment is the alignment, in bytes, of the offset within
            the allocation required: for the resource.
            </summary>
        </member>
        <member name="F:SharpVk.MemoryRequirements.MemoryTypeBits">
            <summary>
            pname:memoryTypeBits is a bitmask and contains one bit set for
            every supported memory type for the resource. Bit `i` is set if and
            only if the memory type `i` in the
            sname:VkPhysicalDeviceMemoryProperties structure for the physical
            device is supported for the resource.
            </summary>
        </member>
        <member name="M:SharpVk.MemoryRequirements.ToString">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.MemoryType">
            <summary>
            Structure specifying memory type.
            </summary>
        </member>
        <member name="M:SharpVk.MemoryType.#ctor(SharpVk.MemoryPropertyFlags,System.UInt32)">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.MemoryType.PropertyFlags">
            <summary>
            pname:propertyFlags is a bitmask of properties for this memory
            type. The bits specified in pname:propertyFlags are: + --
            </summary>
        </member>
        <member name="F:SharpVk.MemoryType.HeapIndex">
            <summary>
            pname:heapIndex describes which memory heap this memory type
            corresponds to, and must: be less than pname:memoryHeapCount from
            the sname:VkPhysicalDeviceMemoryProperties structure.
            </summary>
        </member>
        <member name="M:SharpVk.MemoryType.ToString">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.MemUtil">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpVk.MemUtil.SizeOf``1">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="T:SharpVk.MemUtil.SizeOfCache`1">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:SharpVk.MemUtil.WriteToPtr``1(System.IntPtr,``0[],System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <param name="dest"></param>
            <param name="value"></param>
            <param name="startIndex"></param>
            <param name="count"></param>
        </member>
        <member name="T:SharpVk.MirSurfaceCreateFlags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.MirSurfaceCreateFlags.None">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.MirSurfaceCreateInfo">
            <summary>
            Structure specifying parameters of a newly created Mir surface object.
            </summary>
        </member>
        <member name="P:SharpVk.MirSurfaceCreateInfo.Flags">
            <summary>
            pname:flags is reserved for future use.
            </summary>
        </member>
        <member name="P:SharpVk.MirSurfaceCreateInfo.Connection">
            <summary>
            pname:connection and pname:surface are pointers to the
            code:MirConnection and code:MirSurface for the window to associate
            the surface with.
            </summary>
        </member>
        <member name="P:SharpVk.MirSurfaceCreateInfo.MirSurface">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.ObjectEntryType">
            <summary>
            <para>
            Enum specifying object table entry type.
            </para>
            <para>
            * ename:VK_OBJECT_ENTRY_DESCRIPTOR_SET_NVX indicates a
            sname:VkDescriptorSet resource entry that is registered via
            sname:VkObjectTableDescriptorSetEntryNVX. *
            ename:VK_OBJECT_ENTRY_PIPELINE_NVX indicates a sname:VkPipeline
            resource entry that is registered via
            sname:VkObjectTablePipelineEntryNVX. *
            ename:VK_OBJECT_ENTRY_INDEX_BUFFER_NVX indicates a sname:VkBuffer
            resource entry that is registered via
            sname:VkObjectTableIndexBufferEntryNVX. *
            ename:VK_OBJECT_ENTRY_VERTEX_BUFFER_NVX indicates a sname:VkBuffer
            resource entry that is registered via
            sname:VkObjectTableVertexBufferEntryNVX. *
            ename:VK_OBJECT_ENTRY_PUSH_CONSTANT_NVX indicates the resource entry is
            registered via sname:VkObjectTablePushConstantEntryNVX.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.ObjectEntryType.DescriptorSet">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.ObjectEntryType.Pipeline">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.ObjectEntryType.IndexBuffer">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.ObjectEntryType.VertexBuffer">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.ObjectEntryType.PushConstant">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.ObjectEntryUsageFlags">
            <summary>
            Bitmask specifying allowed usage of an object entry.
            </summary>
        </member>
        <member name="F:SharpVk.ObjectEntryUsageFlags.None">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.ObjectEntryUsageFlags.Graphics">
            <summary>
            ename:VK_OBJECT_ENTRY_USAGE_GRAPHICS_BIT_NVX indicates that the
            resource is bound to ename:VK_PIPELINE_BIND_POINT_GRAPHICS
            </summary>
        </member>
        <member name="F:SharpVk.ObjectEntryUsageFlags.Compute">
            <summary>
            ename:VK_OBJECT_ENTRY_USAGE_COMPUTE_BIT_NVX indicates that the
            resource is bound to ename:VK_PIPELINE_BIND_POINT_COMPUTE
            </summary>
        </member>
        <member name="T:SharpVk.ObjectTable">
            <summary>
            Opaque handle to an object table.
            </summary>
        </member>
        <member name="M:SharpVk.ObjectTable.Destroy">
            <summary>
            Destroy a object table.
            </summary>
        </member>
        <member name="M:SharpVk.ObjectTable.RegisterObjects(SharpVk.ArrayProxy{SharpVk.ObjectTableEntry},SharpVk.ArrayProxy{System.UInt32})">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.ObjectTable.UnregisterObjects(SharpVk.ArrayProxy{SharpVk.ObjectEntryType},SharpVk.ArrayProxy{System.UInt32})">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.ObjectTable.RawHandle">
            <summary>
            The interop handle for this ObjectTable.
            </summary>
        </member>
        <member name="M:SharpVk.ObjectTable.Dispose">
            <summary>
            Releases the unmanaged resources associated with this instance and
            destroys the underlying Vulkan handle.
            </summary>
        </member>
        <member name="T:SharpVk.ObjectTableCreateInfo">
            <summary>
            Structure specifying the parameters of a newly created object table.
            </summary>
        </member>
        <member name="P:SharpVk.ObjectTableCreateInfo.ObjectEntryTypes">
            <summary>
            pname:pObjectEntryTypes is an array of elink:VkObjectEntryTypeNVX
            providing the entry type of a given configuration.
            </summary>
        </member>
        <member name="P:SharpVk.ObjectTableCreateInfo.ObjectEntryCounts">
            <summary>
            pname:pObjectEntryCounts is an array of counts how many objects can
            be registered in the table.
            </summary>
        </member>
        <member name="P:SharpVk.ObjectTableCreateInfo.ObjectEntryUsageFlags">
            <summary>
            pname:pObjectEntryUsageFlags is an array of bitmasks describing the
            binding usage of the entry. See elink:VkObjectEntryUsageFlagBitsNVX
            below for a description of the supported bits.
            </summary>
        </member>
        <member name="P:SharpVk.ObjectTableCreateInfo.MaxUniformBuffersPerDescriptor">
            <summary>
            pname:maxUniformBuffersPerDescriptor is the maximum number of
            ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or
            ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC used by any single
            registered sname:VkDescriptorSet in this table.
            </summary>
        </member>
        <member name="P:SharpVk.ObjectTableCreateInfo.MaxStorageBuffersPerDescriptor">
            <summary>
            pname:maxStorageBuffersPerDescriptor is the maximum number of
            ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or
            ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC used by any single
            registered sname:VkDescriptorSet in this table.
            </summary>
        </member>
        <member name="P:SharpVk.ObjectTableCreateInfo.MaxStorageImagesPerDescriptor">
            <summary>
            pname:maxStorageImagesPerDescriptor is the maximum number of
            ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE or
            ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER used by any single
            registered sname:VkDescriptorSet in this table.
            </summary>
        </member>
        <member name="P:SharpVk.ObjectTableCreateInfo.MaxSampledImagesPerDescriptor">
            <summary>
            pname:maxSampledImagesPerDescriptor is the maximum number of
            ename:VK_DESCRIPTOR_TYPE_SAMPLER, ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,
            ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER or
            ename:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT used by any single
            registered sname:VkDescriptorSet in this table.
            </summary>
        </member>
        <member name="P:SharpVk.ObjectTableCreateInfo.MaxPipelineLayouts">
            <summary>
            pname:maxPipelineLayouts is the maximum number of unique
            sname:VkPipelineLayout used by any registered sname:VkDescriptorSet
            or sname:VkPipeline in this table.
            </summary>
        </member>
        <member name="T:SharpVk.ObjectTableDescriptorSetEntry">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.ObjectTableDescriptorSetEntry.Type">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.ObjectTableDescriptorSetEntry.Flags">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.ObjectTableDescriptorSetEntry.PipelineLayout">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.ObjectTableDescriptorSetEntry.DescriptorSet">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.ObjectTableEntry">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.ObjectTableEntry.#ctor(SharpVk.ObjectEntryType,SharpVk.ObjectEntryUsageFlags)">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.ObjectTableEntry.Type">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.ObjectTableEntry.Flags">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.ObjectTableEntry.ToString">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.ObjectTableIndexBufferEntry">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.ObjectTableIndexBufferEntry.Type">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.ObjectTableIndexBufferEntry.Flags">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.ObjectTableIndexBufferEntry.Buffer">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.ObjectTableIndexBufferEntry.IndexType">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.ObjectTablePipelineEntry">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.ObjectTablePipelineEntry.Type">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.ObjectTablePipelineEntry.Flags">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.ObjectTablePipelineEntry.Pipeline">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.ObjectTablePushConstantEntry">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.ObjectTablePushConstantEntry.Type">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.ObjectTablePushConstantEntry.Flags">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.ObjectTablePushConstantEntry.PipelineLayout">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.ObjectTablePushConstantEntry.StageFlags">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.ObjectTableVertexBufferEntry">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.ObjectTableVertexBufferEntry.Type">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.ObjectTableVertexBufferEntry.Flags">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.ObjectTableVertexBufferEntry.Buffer">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Offset2D">
            <summary>
            Structure specifying a two-dimensional offset.
            </summary>
        </member>
        <member name="M:SharpVk.Offset2D.#ctor(System.Int32,System.Int32)">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Offset2D.X">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Offset2D.Y">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Offset2D.ToString">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Offset3D">
            <summary>
            Structure specifying a three-dimensional offset.
            </summary>
        </member>
        <member name="M:SharpVk.Offset3D.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Offset3D.X">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Offset3D.Y">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Offset3D.Z">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Offset3D.ToString">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.PhysicalDevice">
            <summary>
            <para>
            Opaque handle to a physical device object.
            </para>
            <para>
            Vulkan separates the concept of _physical_ and _logical_ devices. A
            physical device usually represents a single device in a system (perhaps
            made up of several individual hardware devices working together), of
            which there are a finite number. A logical device represents an
            application's view of the device.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.PhysicalDevice.GetFeatures">
            <summary>
            Reports capabilities of a physical device.
            </summary>
        </member>
        <member name="M:SharpVk.PhysicalDevice.GetFormatProperties(SharpVk.Format)">
            <summary>
            Lists physical device's format capabilities.
            </summary>
        </member>
        <member name="M:SharpVk.PhysicalDevice.GetImageFormatProperties(SharpVk.Format,SharpVk.ImageType,SharpVk.ImageTiling,SharpVk.ImageUsageFlags,SharpVk.ImageCreateFlags)">
            <summary>
            Lists physical device's image format capabilities.
            </summary>
        </member>
        <member name="M:SharpVk.PhysicalDevice.GetProperties">
            <summary>
            Returns properties of a physical device.
            </summary>
        </member>
        <member name="M:SharpVk.PhysicalDevice.GetQueueFamilyProperties">
            <summary>
            Reports properties of the queues of the specified physical device.
            </summary>
        </member>
        <member name="M:SharpVk.PhysicalDevice.GetMemoryProperties">
            <summary>
            Reports memory information for the specified physical device.
            </summary>
        </member>
        <member name="M:SharpVk.PhysicalDevice.CreateDevice(SharpVk.DeviceCreateInfo)">
            <summary>
            Create a new device instance.
            </summary>
        </member>
        <member name="M:SharpVk.PhysicalDevice.EnumerateDeviceExtensionProperties(System.String)">
            <summary>
            Returns properties of available physical device extensions.
            </summary>
        </member>
        <member name="M:SharpVk.PhysicalDevice.EnumerateDeviceLayerProperties">
            <summary>
            Returns properties of available physical device layers.
            </summary>
        </member>
        <member name="M:SharpVk.PhysicalDevice.GetSparseImageFormatProperties(SharpVk.Format,SharpVk.ImageType,SharpVk.SampleCountFlags,SharpVk.ImageUsageFlags,SharpVk.ImageTiling)">
            <summary>
            Retrieve properties of an image format applied to sparse images.
            </summary>
        </member>
        <member name="M:SharpVk.PhysicalDevice.GetSurfaceSupport(System.UInt32,SharpVk.Surface)">
            <summary>
            Query if presentation is supported.
            </summary>
        </member>
        <member name="M:SharpVk.PhysicalDevice.GetSurfaceCapabilities(SharpVk.Surface)">
            <summary>
            Query surface capabilities.
            </summary>
        </member>
        <member name="M:SharpVk.PhysicalDevice.GetSurfaceFormats(SharpVk.Surface)">
            <summary>
            Query color formats supported by surface.
            </summary>
        </member>
        <member name="M:SharpVk.PhysicalDevice.GetSurfacePresentModes(SharpVk.Surface)">
            <summary>
            Query supported presentation modes.
            </summary>
        </member>
        <member name="M:SharpVk.PhysicalDevice.GetDisplayProperties">
            <summary>
            Query information about the available displays.
            </summary>
        </member>
        <member name="M:SharpVk.PhysicalDevice.GetDisplayPlaneProperties">
            <summary>
            Query the plane properties.
            </summary>
        </member>
        <member name="M:SharpVk.PhysicalDevice.GetDisplayPlaneSupportedDisplays(System.UInt32)">
            <summary>
            Query the list of displays a plane supports.
            </summary>
        </member>
        <member name="M:SharpVk.PhysicalDevice.GetDisplayModeProperties(SharpVk.Display)">
            <summary>
            Query the set of mode properties supported by the display.
            </summary>
        </member>
        <member name="M:SharpVk.PhysicalDevice.CreateDisplayMode(SharpVk.Display,SharpVk.DisplayModeCreateInfo)">
            <summary>
            Create a display mode.
            </summary>
        </member>
        <member name="M:SharpVk.PhysicalDevice.GetXlibPresentationSupport(System.UInt32,System.IntPtr,System.IntPtr)">
            <summary>
            Query physical device for presentation to X11 server using Xlib.
            </summary>
        </member>
        <member name="M:SharpVk.PhysicalDevice.GetXcbPresentationSupport(System.UInt32,System.IntPtr,System.IntPtr)">
            <summary>
            Query physical device for presentation to X11 server using XCB.
            </summary>
        </member>
        <member name="M:SharpVk.PhysicalDevice.GetWaylandPresentationSupport(System.UInt32,System.IntPtr)">
            <summary>
            Query physical device for presentation to Wayland.
            </summary>
        </member>
        <member name="M:SharpVk.PhysicalDevice.GetMirPresentationSupport(System.UInt32,System.IntPtr)">
            <summary>
            Query physical device for presentation to Mir.
            </summary>
        </member>
        <member name="M:SharpVk.PhysicalDevice.GetWin32PresentationSupport(System.UInt32)">
            <summary>
            Query queue family support for presentation on a Win32 display.
            </summary>
        </member>
        <member name="M:SharpVk.PhysicalDevice.GetExternalImageFormatProperties(SharpVk.Format,SharpVk.ImageType,SharpVk.ImageTiling,SharpVk.ImageUsageFlags,SharpVk.ImageCreateFlags,SharpVk.ExternalMemoryHandleTypeFlags)">
            <summary>
            Determine image capabilities compatible with external memory handle
            types.
            </summary>
        </member>
        <member name="M:SharpVk.PhysicalDevice.GetFeatures2">
            <summary>
            Reports capabilities of a physical device.
            </summary>
        </member>
        <member name="M:SharpVk.PhysicalDevice.GetProperties2">
            <summary>
            Returns properties of a physical device.
            </summary>
        </member>
        <member name="M:SharpVk.PhysicalDevice.GetFormatProperties2(SharpVk.Format)">
            <summary>
            Lists physical device's format capabilities.
            </summary>
        </member>
        <member name="M:SharpVk.PhysicalDevice.GetImageFormatProperties2(SharpVk.PhysicalDeviceImageFormatInfo2)">
            <summary>
            Lists physical device's image format capabilities.
            </summary>
        </member>
        <member name="M:SharpVk.PhysicalDevice.GetQueueFamilyProperties2">
            <summary>
            Reports properties of the queues of the specified physical device.
            </summary>
        </member>
        <member name="M:SharpVk.PhysicalDevice.GetMemoryProperties2">
            <summary>
            Reports memory information for the specified physical device.
            </summary>
        </member>
        <member name="M:SharpVk.PhysicalDevice.GetSparseImageFormatProperties2(SharpVk.PhysicalDeviceSparseImageFormatInfo2)">
            <summary>
            Retrieve properties of an image format applied to sparse images.
            </summary>
        </member>
        <member name="M:SharpVk.PhysicalDevice.GetGeneratedCommandsProperties(SharpVk.DeviceGeneratedCommandsFeatures)">
            <summary>
            Returns device-generated commands related properties of a physical
            device.
            </summary>
        </member>
        <member name="M:SharpVk.PhysicalDevice.ReleaseDisplay(SharpVk.Display)">
            <summary>
            Release access to an acquired VkDisplayKHR.
            </summary>
        </member>
        <member name="M:SharpVk.PhysicalDevice.AcquireXlibDisplay(System.IntPtr,SharpVk.Display)">
            <summary>
            Acquire access to a VkDisplayKHR using Xlib.
            </summary>
        </member>
        <member name="M:SharpVk.PhysicalDevice.GetRandROutputDisplay(System.IntPtr,System.IntPtr)">
            <summary>
            Query the VkDisplayKHR corresponding to an X11 RandR Output.
            </summary>
        </member>
        <member name="M:SharpVk.PhysicalDevice.GetSurfaceCapabilities2(SharpVk.Surface)">
            <summary>
            Query surface capabilities.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDevice.RawHandle">
            <summary>
            The interop handle for this PhysicalDevice.
            </summary>
        </member>
        <member name="T:SharpVk.PhysicalDeviceFeatures">
            <summary>
            <para>
            Structure describing the fine-grained features that can be supported by
            an implementation.
            </para>
            <para>
            The members of the sname:VkPhysicalDeviceFeatures structure describe
            the following features:
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.PhysicalDeviceFeatures.#ctor(SharpVk.Bool32,SharpVk.Bool32,SharpVk.Bool32,SharpVk.Bool32,SharpVk.Bool32,SharpVk.Bool32,SharpVk.Bool32,SharpVk.Bool32,SharpVk.Bool32,SharpVk.Bool32,SharpVk.Bool32,SharpVk.Bool32,SharpVk.Bool32,SharpVk.Bool32,SharpVk.Bool32,SharpVk.Bool32,SharpVk.Bool32,SharpVk.Bool32,SharpVk.Bool32,SharpVk.Bool32,SharpVk.Bool32,SharpVk.Bool32,SharpVk.Bool32,SharpVk.Bool32,SharpVk.Bool32,SharpVk.Bool32,SharpVk.Bool32,SharpVk.Bool32,SharpVk.Bool32,SharpVk.Bool32,SharpVk.Bool32,SharpVk.Bool32,SharpVk.Bool32,SharpVk.Bool32,SharpVk.Bool32,SharpVk.Bool32,SharpVk.Bool32,SharpVk.Bool32,SharpVk.Bool32,SharpVk.Bool32,SharpVk.Bool32,SharpVk.Bool32,SharpVk.Bool32,SharpVk.Bool32,SharpVk.Bool32,SharpVk.Bool32,SharpVk.Bool32,SharpVk.Bool32,SharpVk.Bool32,SharpVk.Bool32,SharpVk.Bool32,SharpVk.Bool32,SharpVk.Bool32,SharpVk.Bool32,SharpVk.Bool32)">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.RobustBufferAccess">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.FullDrawIndexUInt32">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.ImageCubeArray">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.IndependentBlend">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.GeometryShader">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.TessellationShader">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.SampleRateShading">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.DualSourceBlend">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.LogicOp">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.MultiDrawIndirect">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.DrawIndirectFirstInstance">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.DepthClamp">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.DepthBiasClamp">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.FillModeNonSolid">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.DepthBounds">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.WideLines">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.LargePoints">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.AlphaToOne">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.MultiViewport">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.SamplerAnisotropy">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.TextureCompressionETC2">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.TextureCompressionASTC_LDR">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.TextureCompressionBC">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.OcclusionQueryPrecise">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.PipelineStatisticsQuery">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.VertexPipelineStoresAndAtomics">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.FragmentStoresAndAtomics">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.ShaderTessellationAndGeometryPointSize">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.ShaderImageGatherExtended">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.ShaderStorageImageExtendedFormats">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.ShaderStorageImageMultisample">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.ShaderStorageImageReadWithoutFormat">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.ShaderStorageImageWriteWithoutFormat">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.ShaderUniformBufferArrayDynamicIndexing">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.ShaderSampledImageArrayDynamicIndexing">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.ShaderStorageBufferArrayDynamicIndexing">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.ShaderStorageImageArrayDynamicIndexing">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.ShaderClipDistance">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.ShaderCullDistance">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.ShaderFloat64">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.ShaderInt64">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.ShaderInt16">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.ShaderResourceResidency">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.ShaderResourceMinLod">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.SparseBinding">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.SparseResidencyBuffer">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.SparseResidencyImage2D">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.SparseResidencyImage3D">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.SparseResidency2Samples">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.SparseResidency4Samples">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.SparseResidency8Samples">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.SparseResidency16Samples">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.SparseResidencyAliased">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.VariableMultisampleRate">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceFeatures.InheritedQueries">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.PhysicalDeviceFeatures.ToString">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.PhysicalDeviceFeatures2">
            <summary>
            <para>
            Structure describing the fine-grained features that can be supported by
            an implementation.
            </para>
            <para>
            The pname:pNext chain of this structure is used to extend the structure
            with features defined by extensions. This structure can: be used in
            flink:vkGetPhysicalDeviceFeatures2KHR or can: be in the pname:pNext
            chain of a slink:VkDeviceCreateInfo structure, in which case it
            controls which features are enabled in the device in lieu of
            pname:pEnabledFeatures.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceFeatures2.Features">
            <summary>
            pname:features is a structure of type
            slink:VkPhysicalDeviceFeatures describing the fine-grained features
            of the Vulkan 1.0 API.
            </summary>
        </member>
        <member name="T:SharpVk.PhysicalDeviceImageFormatInfo2">
            <summary>
            <para>
            Structure specifying image creation parameters.
            </para>
            <para>
            The members of sname:VkPhysicalDeviceImageFormatInfo2KHR correspond to
            the arguments to flink:vkGetPhysicalDeviceImageFormatProperties, with
            pname:sType and pname:pNext added for extensibility.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceImageFormatInfo2.Format">
            <summary>
            pname:format is the image format, corresponding to
            slink:VkImageCreateInfo::pname:format.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceImageFormatInfo2.Type">
            <summary>
            pname:type is the image type, corresponding to
            slink:VkImageCreateInfo::pname:imageType.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceImageFormatInfo2.Tiling">
            <summary>
            pname:tiling is the image tiling, corresponding to
            slink:VkImageCreateInfo::pname:tiling.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceImageFormatInfo2.Usage">
            <summary>
            pname:usage is the intended usage of the image, corresponding to
            slink:VkImageCreateInfo::pname:usage.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceImageFormatInfo2.Flags">
            <summary>
            pname:flags is a bitmask describing additional parameters of the
            image, corresponding to slink:VkImageCreateInfo::pname:flags.
            </summary>
        </member>
        <member name="T:SharpVk.PhysicalDeviceLimits">
            <summary>
            Structure reporting implementation-dependent physical device limits.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxImageDimension1D">
            <summary>
            pname:maxImageDimension1D is the maximum dimension (pname:width) of
            an image created with an pname:imageType of ename:VK_IMAGE_TYPE_1D.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxImageDimension2D">
            <summary>
            pname:maxImageDimension2D is the maximum dimension (pname:width or
            pname:height) of an image created with an pname:imageType of
            ename:VK_IMAGE_TYPE_2D and without
            ename:VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT set in pname:flags.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxImageDimension3D">
            <summary>
            pname:maxImageDimension3D is the maximum dimension (pname:width,
            pname:height, or pname:depth) of an image created with an
            pname:imageType of ename:VK_IMAGE_TYPE_3D.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxImageDimensionCube">
            <summary>
            pname:maxImageDimensionCube is the maximum dimension (pname:width
            or pname:height) of an image created with an pname:imageType of
            ename:VK_IMAGE_TYPE_2D and with
            ename:VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT set in pname:flags.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxImageArrayLayers">
            <summary>
            pname:maxImageArrayLayers is the maximum number of layers
            (pname:arrayLayers) for an image.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxTexelBufferElements">
            <summary>
            pname:maxTexelBufferElements is the maximum number of addressable
            texels for a buffer view created on a buffer which was created with
            the ename:VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT or
            ename:VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT set in the
            pname:usage member of the sname:VkBufferCreateInfo structure.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxUniformBufferRange">
            <summary>
            pname:maxUniformBufferRange is the maximum value that can: be
            specified in the pname:range member of any
            slink:VkDescriptorBufferInfo structures passed to a call to
            flink:vkUpdateDescriptorSets for descriptors of type
            ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or
            ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxStorageBufferRange">
            <summary>
            pname:maxStorageBufferRange is the maximum value that can: be
            specified in the pname:range member of any
            slink:VkDescriptorBufferInfo structures passed to a call to
            flink:vkUpdateDescriptorSets for descriptors of type
            ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or
            ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxPushConstantsSize">
            <summary>
            pname:maxPushConstantsSize is the maximum size, in bytes, of the
            pool of push constant memory. For each of the push constant ranges
            indicated by the pname:pPushConstantRanges member of the
            sname:VkPipelineLayoutCreateInfo structure, pname:offset +
            pname:size must: be less than or equal to this limit.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxMemoryAllocationCount">
            <summary>
            pname:maxMemoryAllocationCount is the maximum number of device
            memory allocations, as created by flink:vkAllocateMemory, which
            can: simultaneously exist.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxSamplerAllocationCount">
            <summary>
            pname:maxSamplerAllocationCount is the maximum number of sampler
            objects, as created by flink:vkCreateSampler, which can:
            simultaneously exist on a device.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.BufferImageGranularity">
            <summary>
            pname:bufferImageGranularity is the granularity, in bytes, at which
            buffer or linear image resources, and optimal image resources can:
            be bound to adjacent offsets in the same sname:VkDeviceMemory
            object without aliasing. See
            &lt;&lt;resources-bufferimagegranularity,Buffer-Image Granularity&gt;&gt;
            for more details.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.SparseAddressSpaceSize">
            <summary>
            pname:sparseAddressSpaceSize is the total amount of address space
            available, in bytes, for sparse memory resources. This is an upper
            bound on the sum of the size of all sparse resources, regardless of
            whether any memory is bound to them.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxBoundDescriptorSets">
            <summary>
            pname:maxBoundDescriptorSets is the maximum number of descriptor
            sets that can: be simultaneously used by a pipeline. All
            code:DescriptorSet decorations in shader modules must: have a value
            less than pname:maxBoundDescriptorSets. See
            &lt;&lt;descriptorsets-sets&gt;&gt;.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxPerStageDescriptorSamplers">
            <summary>
            pname:maxPerStageDescriptorSamplers is the maximum number of
            samplers that can: be accessible to a single shader stage in a
            pipeline layout. Descriptors with a type of
            ename:VK_DESCRIPTOR_TYPE_SAMPLER or
            ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER count against this
            limit. A descriptor is accessible to a shader stage when the
            pname:stageFlags member of the sname:VkDescriptorSetLayoutBinding
            structure has the bit for that shader stage set. See
            &lt;&lt;descriptorsets-sampler&gt;&gt; and
            &lt;&lt;descriptorsets-combinedimagesampler&gt;&gt;.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxPerStageDescriptorUniformBuffers">
            <summary>
            pname:maxPerStageDescriptorUniformBuffers is the maximum number of
            uniform buffers that can: be accessible to a single shader stage in
            a pipeline layout. Descriptors with a type of
            ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or
            ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC count against this
            limit. A descriptor is accessible to a shader stage when the
            pname:stageFlags member of the sname:VkDescriptorSetLayoutBinding
            structure has the bit for that shader stage set. See
            &lt;&lt;descriptorsets-uniformbuffer&gt;&gt; and
            &lt;&lt;descriptorsets-uniformbufferdynamic&gt;&gt;.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxPerStageDescriptorStorageBuffers">
            <summary>
            pname:maxPerStageDescriptorStorageBuffers is the maximum number of
            storage buffers that can: be accessible to a single shader stage in
            a pipeline layout. Descriptors with a type of
            ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or
            ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC count against this
            limit. A descriptor is accessible to a pipeline shader stage when
            the pname:stageFlags member of the
            sname:VkDescriptorSetLayoutBinding structure has the bit for that
            shader stage set. See &lt;&lt;descriptorsets-storagebuffer&gt;&gt;
            and &lt;&lt;descriptorsets-storagebufferdynamic&gt;&gt;.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxPerStageDescriptorSampledImages">
            <summary>
            pname:maxPerStageDescriptorSampledImages is the maximum number of
            sampled images that can: be accessible to a single shader stage in
            a pipeline layout. Descriptors with a type of
            ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
            or ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER count against this
            limit. A descriptor is accessible to a pipeline shader stage when
            the pname:stageFlags member of the
            sname:VkDescriptorSetLayoutBinding structure has the bit for that
            shader stage set. See
            &lt;&lt;descriptorsets-combinedimagesampler&gt;&gt;, &lt;&lt;descriptorsets-sampledimage&gt;&gt;,
            and &lt;&lt;descriptorsets-uniformtexelbuffer&gt;&gt;.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxPerStageDescriptorStorageImages">
            <summary>
            pname:maxPerStageDescriptorStorageImages is the maximum number of
            storage images that can: be accessible to a single shader stage in
            a pipeline layout. Descriptors with a type of
            ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, or
            ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER count against this
            limit. A descriptor is accessible to a pipeline shader stage when
            the pname:stageFlags member of the
            sname:VkDescriptorSetLayoutBinding structure has the bit for that
            shader stage set. See &lt;&lt;descriptorsets-storageimage&gt;&gt;,
            and &lt;&lt;descriptorsets-storagetexelbuffer&gt;&gt;.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxPerStageDescriptorInputAttachments">
            <summary>
            pname:maxPerStageDescriptorInputAttachments is the maximum number
            of input attachments that can: be accessible to a single shader
            stage in a pipeline layout. Descriptors with a type of
            ename:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT count against this limit.
            A descriptor is accessible to a pipeline shader stage when the
            pname:stageFlags member of the sname:VkDescriptorSetLayoutBinding
            structure has the bit for that shader stage set. These are only
            supported for the fragment stage. See
            &lt;&lt;descriptorsets-inputattachment&gt;&gt;.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxPerStageResources">
            <summary>
            pname:maxPerStageResources is the maximum number of resources that
            can: be accessible to a single shader stage in a pipeline layout.
            Descriptors with a type of
            ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
            ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE,
            ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER, ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER,
            ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
            ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC,
            ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC, or
            ename:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT count against this limit.
            For the fragment shader stage the framebuffer color attachments
            also count against this limit.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxDescriptorSetSamplers">
            <summary>
            pname:maxDescriptorSetSamplers is the maximum number of samplers
            that can: be included in descriptor bindings in a pipeline layout
            across all pipeline shader stages and descriptor set numbers.
            Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_SAMPLER or
            ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER count against this
            limit. See &lt;&lt;descriptorsets-sampler&gt;&gt; and
            &lt;&lt;descriptorsets-combinedimagesampler&gt;&gt;.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxDescriptorSetUniformBuffers">
            <summary>
            pname:maxDescriptorSetUniformBuffers is the maximum number of
            uniform buffers that can: be included in descriptor bindings in a
            pipeline layout across all pipeline shader stages and descriptor
            set numbers. Descriptors with a type of
            ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or
            ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC count against this
            limit. See &lt;&lt;descriptorsets-uniformbuffer&gt;&gt; and
            &lt;&lt;descriptorsets-uniformbufferdynamic&gt;&gt;.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxDescriptorSetUniformBuffersDynamic">
            <summary>
            pname:maxDescriptorSetUniformBuffersDynamic is the maximum number
            of dynamic uniform buffers that can: be included in descriptor
            bindings in a pipeline layout across all pipeline shader stages and
            descriptor set numbers. Descriptors with a type of
            ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC count against this
            limit. See &lt;&lt;descriptorsets-uniformbufferdynamic&gt;&gt;.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxDescriptorSetStorageBuffers">
            <summary>
            pname:maxDescriptorSetStorageBuffers is the maximum number of
            storage buffers that can: be included in descriptor bindings in a
            pipeline layout across all pipeline shader stages and descriptor
            set numbers. Descriptors with a type of
            ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or
            ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC count against this
            limit. See &lt;&lt;descriptorsets-storagebuffer&gt;&gt; and
            &lt;&lt;descriptorsets-storagebufferdynamic&gt;&gt;.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxDescriptorSetStorageBuffersDynamic">
            <summary>
            pname:maxDescriptorSetStorageBuffersDynamic is the maximum number
            of dynamic storage buffers that can: be included in descriptor
            bindings in a pipeline layout across all pipeline shader stages and
            descriptor set numbers. Descriptors with a type of
            ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC count against this
            limit. See &lt;&lt;descriptorsets-storagebufferdynamic&gt;&gt;.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxDescriptorSetSampledImages">
            <summary>
            pname:maxDescriptorSetSampledImages is the maximum number of
            sampled images that can: be included in descriptor bindings in a
            pipeline layout across all pipeline shader stages and descriptor
            set numbers. Descriptors with a type of
            ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
            or ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER count against this
            limit. See &lt;&lt;descriptorsets-combinedimagesampler&gt;&gt;,
            &lt;&lt;descriptorsets-sampledimage&gt;&gt;, and
            &lt;&lt;descriptorsets-uniformtexelbuffer&gt;&gt;.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxDescriptorSetStorageImages">
            <summary>
            pname:maxDescriptorSetStorageImages is the maximum number of
            storage images that can: be included in descriptor bindings in a
            pipeline layout across all pipeline shader stages and descriptor
            set numbers. Descriptors with a type of
            ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, or
            ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER count against this
            limit. See &lt;&lt;descriptorsets-storageimage&gt;&gt;, and
            &lt;&lt;descriptorsets-storagetexelbuffer&gt;&gt;.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxDescriptorSetInputAttachments">
            <summary>
            pname:maxDescriptorSetInputAttachments is the maximum number of
            input attachments that can: be included in descriptor bindings in a
            pipeline layout across all pipeline shader stages and descriptor
            set numbers. Descriptors with a type of
            ename:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT count against this limit.
            See &lt;&lt;descriptorsets-inputattachment&gt;&gt;.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxVertexInputAttributes">
            <summary>
            pname:maxVertexInputAttributes is the maximum number of vertex
            input attributes that can: be specified for a graphics pipeline.
            These are described in the array of
            sname:VkVertexInputAttributeDescription structures that are
            provided at graphics pipeline creation time via the
            pname:pVertexAttributeDescriptions member of the
            sname:VkPipelineVertexInputStateCreateInfo structure. See
            &lt;&lt;fxvertex-attrib&gt;&gt; and &lt;&lt;fxvertex-input&gt;&gt;.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxVertexInputBindings">
            <summary>
            pname:maxVertexInputBindings is the maximum number of vertex
            buffers that can: be specified for providing vertex attributes to a
            graphics pipeline. These are described in the array of
            sname:VkVertexInputBindingDescription structures that are provided
            at graphics pipeline creation time via the
            pname:pVertexBindingDescriptions member of the
            sname:VkPipelineVertexInputStateCreateInfo structure. The
            pname:binding member of sname:VkVertexInputBindingDescription must:
            be less than this limit. See &lt;&lt;fxvertex-input&gt;&gt;.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxVertexInputAttributeOffset">
            <summary>
            pname:maxVertexInputAttributeOffset is the maximum vertex input
            attribute offset that can: be added to the vertex input binding
            stride. The pname:offset member of the
            sname:VkVertexInputAttributeDescription structure must: be less
            than or equal to this limit. See &lt;&lt;fxvertex-input&gt;&gt;.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxVertexInputBindingStride">
            <summary>
            pname:maxVertexInputBindingStride is the maximum vertex input
            binding stride that can: be specified in a vertex input binding.
            The pname:stride member of the
            sname:VkVertexInputBindingDescription structure must: be less than
            or equal to this limit. See &lt;&lt;fxvertex-input&gt;&gt;.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxVertexOutputComponents">
            <summary>
            pname:maxVertexOutputComponents is the maximum number of components
            of output variables which can: be output by a vertex shader. See
            &lt;&lt;shaders-vertex&gt;&gt;.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxTessellationGenerationLevel">
            <summary>
            pname:maxTessellationGenerationLevel is the maximum tessellation
            generation level supported by the fixed-function tessellation
            primitive generator. See &lt;&lt;tessellation&gt;&gt;.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxTessellationPatchSize">
            <summary>
            pname:maxTessellationPatchSize is the maximum patch size, in
            vertices, of patches that can: be processed by the tessellation
            control shader and tessellation primitive generator. The
            pname:patchControlPoints member of the
            sname:VkPipelineTessellationStateCreateInfo structure specified at
            pipeline creation time and the value provided in the
            code:OutputVertices execution mode of shader modules must: be less
            than or equal to this limit. See &lt;&lt;tessellation&gt;&gt;.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxTessellationControlPerVertexInputComponents">
            <summary>
            pname:maxTessellationControlPerVertexInputComponents is the maximum
            number of components of input variables which can: be provided as
            per-vertex inputs to the tessellation control shader stage.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxTessellationControlPerVertexOutputComponents">
            <summary>
            pname:maxTessellationControlPerVertexOutputComponents is the
            maximum number of components of per-vertex output variables which
            can: be output from the tessellation control shader stage.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxTessellationControlPerPatchOutputComponents">
            <summary>
            pname:maxTessellationControlPerPatchOutputComponents is the maximum
            number of components of per-patch output variables which can: be
            output from the tessellation control shader stage.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxTessellationControlTotalOutputComponents">
            <summary>
            pname:maxTessellationControlTotalOutputComponents is the maximum
            total number of components of per-vertex and per-patch output
            variables which can: be output from the tessellation control shader
            stage.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxTessellationEvaluationInputComponents">
            <summary>
            pname:maxTessellationEvaluationInputComponents is the maximum
            number of components of input variables which can: be provided as
            per-vertex inputs to the tessellation evaluation shader stage.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxTessellationEvaluationOutputComponents">
            <summary>
            pname:maxTessellationEvaluationOutputComponents is the maximum
            number of components of per-vertex output variables which can: be
            output from the tessellation evaluation shader stage.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxGeometryShaderInvocations">
            <summary>
            pname:maxGeometryShaderInvocations is the maximum invocation count
            supported for instanced geometry shaders. The value provided in the
            code:Invocations execution mode of shader modules must: be less
            than or equal to this limit. See &lt;&lt;geometry&gt;&gt;.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxGeometryInputComponents">
            <summary>
            pname:maxGeometryInputComponents is the maximum number of
            components of input variables which can: be provided as inputs to
            the geometry shader stage.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxGeometryOutputComponents">
            <summary>
            pname:maxGeometryOutputComponents is the maximum number of
            components of output variables which can: be output from the
            geometry shader stage.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxGeometryOutputVertices">
            <summary>
            pname:maxGeometryOutputVertices is the maximum number of vertices
            which can: be emitted by any geometry shader.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxGeometryTotalOutputComponents">
            <summary>
            pname:maxGeometryTotalOutputComponents is the maximum total number
            of components of output, across all emitted vertices, which can: be
            output from the geometry shader stage.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxFragmentInputComponents">
            <summary>
            pname:maxFragmentInputComponents is the maximum number of
            components of input variables which can: be provided as inputs to
            the fragment shader stage.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxFragmentOutputAttachments">
            <summary>
            pname:maxFragmentOutputAttachments is the maximum number of output
            attachments which can: be written to by the fragment shader stage.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxFragmentDualSourceAttachments">
            <summary>
            pname:maxFragmentDualSrcAttachments is the maximum number of output
            attachments which can: be written to by the fragment shader stage
            when blending is enabled and one of the dual source blend modes is
            in use. See &lt;&lt;framebuffer-dsb&gt;&gt; and
            &lt;&lt;features-features-dualSrcBlend,dualSrcBlend&gt;&gt;.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxFragmentCombinedOutputResources">
            <summary>
            pname:maxFragmentCombinedOutputResources is the total number of
            storage buffers, storage images, and output buffers which can: be
            used in the fragment shader stage.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxComputeSharedMemorySize">
            <summary>
            pname:maxComputeSharedMemorySize is the maximum total storage size,
            in bytes, of all variables declared with the code:WorkgroupLocal
            storage class in shader modules (or with the code:shared storage
            qualifier in GLSL) in the compute shader stage.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxComputeWorkGroupCount">
            <summary>
            pname:maxComputeWorkGroupCount[3] is the maximum number of local
            workgroups that can: be dispatched by a single dispatch command.
            These three values represent the maximum number of local workgroups
            for the X, Y, and Z dimensions, respectively. The pname:x, pname:y,
            and pname:z parameters to the flink:vkCmdDispatch command, or
            members of the slink:VkDispatchIndirectCommand structure must: be
            less than or equal to the corresponding limit. See
            &lt;&lt;dispatch&gt;&gt;.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxComputeWorkGroupInvocations">
            <summary>
            pname:maxComputeWorkGroupInvocations is the maximum total number of
            compute shader invocations in a single local workgroup. The product
            of the X, Y, and Z sizes as specified by the code:LocalSize
            execution mode in shader modules and by the object decorated by the
            code:WorkgroupSize decoration must: be less than or equal to this
            limit.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxComputeWorkGroupSize">
            <summary>
            pname:maxComputeWorkGroupSize[3] is the maximum size of a local
            compute workgroup, per dimension. These three values represent the
            maximum local workgroup size in the X, Y, and Z dimensions,
            respectively. The pname:x, pname:y, and pname:z sizes specified by
            the code:LocalSize execution mode and by the object decorated by
            the code:WorkgroupSize decoration in shader modules must: be less
            than or equal to the corresponding limit.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.SubPixelPrecisionBits">
            <summary>
            pname:subPixelPrecisionBits is the number of bits of subpixel
            precision in framebuffer coordinates [eq]#x~f~# and [eq]#y~f~#. See
            &lt;&lt;primsrast&gt;&gt;.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.SubTexelPrecisionBits">
            <summary>
            pname:subTexelPrecisionBits is the number of bits of precision in
            the division along an axis of an image used for minification and
            magnification filters. [eq]#2^pname:subTexelPrecisionBits^# is the
            actual number of divisions along each axis of the image
            represented. The filtering hardware will snap to these locations
            when computing the filtered results.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MipmapPrecisionBits">
            <summary>
            pname:mipmapPrecisionBits is the number of bits of division that
            the LOD calculation for mipmap fetching get snapped to when
            determining the contribution from each mip level to the mip
            filtered results. [eq]#2^pname:mipmapPrecisionBits^# is the actual
            number of divisions. + -- [NOTE] .Note ==== For example, if this
            value is 2 bits then when linearly filtering between two levels,
            each level could: contribute: 0%, 33%, 66%, or 100% (this is just
            an example and the amount of contribution should: be covered by
            different equations in the spec). ==== -- +
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxDrawIndexedIndexValue">
            <summary>
            pname:maxDrawIndexedIndexValue is the maximum index value that can:
            be used for indexed draw calls when using 32-bit indices. This
            excludes the primitive restart index value of 0xFFFFFFFF. See
            &lt;&lt;features-features-fullDrawIndexUint32,fullDrawIndexUint32&gt;&gt;.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxDrawIndirectCount">
            <summary>
            pname:maxDrawIndirectCount is the maximum draw count that is
            supported for indirect draw calls. See
            &lt;&lt;features-features-multiDrawIndirect,multiDrawIndirect&gt;&gt;.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxSamplerLodBias">
            <summary>
            pname:maxSamplerLodBias is the maximum absolute sampler level of
            detail bias. The sum of the pname:mipLodBias member of the
            sname:VkSamplerCreateInfo structure and the code:Bias operand of
            image sampling operations in shader modules (or 0 if no code:Bias
            operand is provided to an image sampling operation) are clamped to
            the range
            [eq]#[-pname:maxSamplerLodBias,+pname:maxSamplerLodBias]#. See
            &lt;&lt;samplers-mipLodBias&gt;&gt;.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxSamplerAnisotropy">
            <summary>
            pname:maxSamplerAnisotropy is the maximum degree of sampler
            anisotropy. The maximum degree of anisotropic filtering used for an
            image sampling operation is the minimum of the pname:maxAnisotropy
            member of the sname:VkSamplerCreateInfo structure and this limit.
            See &lt;&lt;samplers-maxAnisotropy&gt;&gt;.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxViewports">
            <summary>
            pname:maxViewports is the maximum number of active viewports. The
            pname:viewportCount member of the
            sname:VkPipelineViewportStateCreateInfo structure that is provided
            at pipeline creation must: be less than or equal to this limit.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxViewportDimensions">
            <summary>
            pname:maxViewportDimensions[2] are the maximum viewport dimensions
            in the X (width) and Y (height) dimensions, respectively. The
            maximum viewport dimensions must: be greater than or equal to the
            largest image which can: be created and used as a framebuffer
            attachment. See &lt;&lt;vertexpostproc-viewport,Controlling the
            Viewport&gt;&gt;.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.ViewportBoundsRange">
            <summary>
            pname:viewportBoundsRange[2] is the [eq]#[minimum, maximum]# range
            that the corners of a viewport must: be contained in. This range
            must: be at least [eq]#[-2 {times} pname:size, 2 {times} pname:size
            - 1]#, where [eq]#pname:size = max(pname:maxViewportDimensions[0],
            pname:maxViewportDimensions[1])#. See
            &lt;&lt;vertexpostproc-viewport,Controlling the Viewport&gt;&gt;. +
            -- [NOTE] .Note ==== The intent of the pname:viewportBoundsRange
            limit is to allow a maximum sized viewport to be arbitrarily
            shifted relative to the output target as long as at least some
            portion intersects. This would give a bounds limit of
            [eq]#[-pname:size + 1, 2 {times} pname:size - 1]# which would allow
            all possible non-empty-set intersections of the output target and
            the viewport. Since these numbers are typically powers of two,
            picking the signed number range using the smallest possible number
            of bits ends up with the specified range. ==== --
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.ViewportSubPixelBits">
            <summary>
            pname:viewportSubPixelBits is the number of bits of subpixel
            precision for viewport bounds. The subpixel precision that
            floating-point viewport bounds are interpreted at is given by this
            limit.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MinMemoryMapAlignment">
            <summary>
            pname:minMemoryMapAlignment is the minimum required: alignment, in
            bytes, of host visible memory allocations within the host address
            space. When mapping a memory allocation with flink:vkMapMemory,
            subtracting pname:offset bytes from the returned pointer will
            always produce an integer multiple of this limit. See
            &lt;&lt;memory-device-hostaccess&gt;&gt;.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MinTexelBufferOffsetAlignment">
            <summary>
            pname:minTexelBufferOffsetAlignment is the minimum required:
            alignment, in bytes, for the pname:offset member of the
            sname:VkBufferViewCreateInfo structure for texel buffers. When a
            buffer view is created for a buffer which was created with
            ename:VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT or
            ename:VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT set in the
            pname:usage member of the sname:VkBufferCreateInfo structure, the
            pname:offset must: be an integer multiple of this limit.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MinUniformBufferOffsetAlignment">
            <summary>
            pname:minUniformBufferOffsetAlignment is the minimum required:
            alignment, in bytes, for the pname:offset member of the
            sname:VkDescriptorBufferInfo structure for uniform buffers. When a
            descriptor of type ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or
            ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC is updated, the
            pname:offset must: be an integer multiple of this limit. Similarly,
            dynamic offsets for uniform buffers must: be multiples of this
            limit.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MinStorageBufferOffsetAlignment">
            <summary>
            pname:minStorageBufferOffsetAlignment is the minimum required:
            alignment, in bytes, for the pname:offset member of the
            sname:VkDescriptorBufferInfo structure for storage buffers. When a
            descriptor of type ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or
            ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC is updated, the
            pname:offset must: be an integer multiple of this limit. Similarly,
            dynamic offsets for storage buffers must: be multiples of this
            limit.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MinTexelOffset">
            <summary>
            pname:minTexelOffset is the minimum offset value for the
            code:ConstOffset image operand of any of the code:OpImageSample* or
            code:OpImageFetch* image instructions.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxTexelOffset">
            <summary>
            pname:maxTexelOffset is the maximum offset value for the
            code:ConstOffset image operand of any of the code:OpImageSample* or
            code:OpImageFetch* image instructions.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MinTexelGatherOffset">
            <summary>
            pname:minTexelGatherOffset is the minimum offset value for the
            code:Offset or code:ConstOffsets image operands of any of the
            code:OpImage*code:Gather image instructions.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxTexelGatherOffset">
            <summary>
            pname:maxTexelGatherOffset is the maximum offset value for the
            code:Offset or code:ConstOffsets image operands of any of the
            code:OpImage*code:Gather image instructions.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MinInterpolationOffset">
            <summary>
            pname:minInterpolationOffset is the minimum negative offset value
            for the code:offset operand of the code:InterpolateAtOffset
            extended instruction.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxInterpolationOffset">
            <summary>
            pname:maxInterpolationOffset is the maximum positive offset value
            for the code:offset operand of the code:InterpolateAtOffset
            extended instruction.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.SubPixelInterpolationOffsetBits">
            <summary>
            pname:subPixelInterpolationOffsetBits is the number of subpixel
            fractional bits that the code:x and code:y offsets to the
            code:InterpolateAtOffset extended instruction may: be rounded to as
            fixed-point values.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxFramebufferWidth">
            <summary>
            pname:maxFramebufferWidth is the maximum width for a framebuffer.
            The pname:width member of the sname:VkFramebufferCreateInfo
            structure must: be less than or equal to this limit.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxFramebufferHeight">
            <summary>
            pname:maxFramebufferHeight is the maximum height for a framebuffer.
            The pname:height member of the sname:VkFramebufferCreateInfo
            structure must: be less than or equal to this limit.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxFramebufferLayers">
            <summary>
            pname:maxFramebufferLayers is the maximum layer count for a layered
            framebuffer. The pname:layers member of the
            sname:VkFramebufferCreateInfo structure must: be less than or equal
            to this limit.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.FramebufferColorSampleCounts">
            <summary>
            pname:framebufferColorSampleCounts is a bitmask^1^ of
            elink:VkSampleCountFlagBits bits indicating the color sample counts
            that are supported for all framebuffer color attachments.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.FramebufferDepthSampleCounts">
            <summary>
            pname:framebufferDepthSampleCounts is a bitmask^1^ of
            elink:VkSampleCountFlagBits bits indicating the supported depth
            sample counts for all framebuffer depth/stencil attachments, when
            the format includes a depth component.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.FramebufferStencilSampleCounts">
            <summary>
            pname:framebufferStencilSampleCounts is a bitmask^1^ of
            elink:VkSampleCountFlagBits bits indicating the supported stencil
            sample counts for all framebuffer depth/stencil attachments, when
            the format includes a stencil component.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.FramebufferNoAttachmentsSampleCounts">
            <summary>
            pname:framebufferNoAttachmentsSampleCounts is a bitmask^1^ of
            elink:VkSampleCountFlagBits bits indicating the supported sample
            counts for a framebuffer with no attachments.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxColorAttachments">
            <summary>
            pname:maxColorAttachments is the maximum number of color
            attachments that can: be used by a subpass in a render pass. The
            pname:colorAttachmentCount member of the sname:VkSubpassDescription
            structure must: be less than or equal to this limit.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.SampledImageColorSampleCounts">
            <summary>
            pname:sampledImageColorSampleCounts is a bitmask^1^ of
            elink:VkSampleCountFlagBits bits indicating the sample counts
            supported for all 2D images created with
            ename:VK_IMAGE_TILING_OPTIMAL, pname:usage containing
            ename:VK_IMAGE_USAGE_SAMPLED_BIT, and a non-integer color format.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.SampledImageIntegerSampleCounts">
            <summary>
            pname:sampledImageIntegerSampleCounts is a bitmask^1^ of
            elink:VkSampleCountFlagBits bits indicating the sample counts
            supported for all 2D images created with
            ename:VK_IMAGE_TILING_OPTIMAL, pname:usage containing
            ename:VK_IMAGE_USAGE_SAMPLED_BIT, and an integer color format.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.SampledImageDepthSampleCounts">
            <summary>
            pname:sampledImageDepthSampleCounts is a bitmask^1^ of
            elink:VkSampleCountFlagBits bits indicating the sample counts
            supported for all 2D images created with
            ename:VK_IMAGE_TILING_OPTIMAL, pname:usage containing
            ename:VK_IMAGE_USAGE_SAMPLED_BIT, and a depth format.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.SampledImageStencilSampleCounts">
            <summary>
            pname:sampledImageStencilSampleCounts is a bitmask^1^ of
            elink:VkSampleCountFlagBits bits indicating the sample supported
            for all 2D images created with ename:VK_IMAGE_TILING_OPTIMAL,
            pname:usage containing ename:VK_IMAGE_USAGE_SAMPLED_BIT, and a
            stencil format.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.StorageImageSampleCounts">
            <summary>
            pname:storageImageSampleCounts is a bitmask^1^ of
            elink:VkSampleCountFlagBits bits indicating the sample counts
            supported for all 2D images created with
            ename:VK_IMAGE_TILING_OPTIMAL, and pname:usage containing
            ename:VK_IMAGE_USAGE_STORAGE_BIT.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxSampleMaskWords">
            <summary>
            pname:maxSampleMaskWords is the maximum number of array elements of
            a variable decorated with the code:SampleMask built-in decoration.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.TimestampComputeAndGraphics">
            <summary>
            pname:timestampComputeAndGraphics indicates support for timestamps
            on all graphics and compute queues. If this limit is set to
            ename:VK_TRUE, all queues that advertise the
            ename:VK_QUEUE_GRAPHICS_BIT or ename:VK_QUEUE_COMPUTE_BIT in the
            sname:VkQueueFamilyProperties::pname:queueFlags support
            sname:VkQueueFamilyProperties::pname:timestampValidBits of at least
            36. See &lt;&lt;queries-timestamps, Timestamp Queries&gt;&gt;.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.TimestampPeriod">
            <summary>
            pname:timestampPeriod is the number of nanoseconds required: for a
            timestamp query to be incremented by 1. See
            &lt;&lt;queries-timestamps, Timestamp Queries&gt;&gt;.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxClipDistances">
            <summary>
            pname:maxClipDistances is the maximum number of clip distances that
            can: be used in a single shader stage. The size of any array
            declared with the code:ClipDistance built-in decoration in a shader
            module must: be less than or equal to this limit.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxCullDistances">
            <summary>
            pname:maxCullDistances is the maximum number of cull distances that
            can: be used in a single shader stage. The size of any array
            declared with the code:CullDistance built-in decoration in a shader
            module must: be less than or equal to this limit.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.MaxCombinedClipAndCullDistances">
            <summary>
            pname:maxCombinedClipAndCullDistances is the maximum combined
            number of clip and cull distances that can: be used in a single
            shader stage. The sum of the sizes of any pair of arrays declared
            with the code:ClipDistance and code:CullDistance built-in
            decoration used by a single shader stage in a shader module must:
            be less than or equal to this limit.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.DiscreteQueuePriorities">
            <summary>
            pname:discreteQueuePriorities is the number of discrete priorities
            that can: be assigned to a queue based on the value of each member
            of sname:VkDeviceQueueCreateInfo::pname:pQueuePriorities. This
            must: be at least 2, and levels must: be spread evenly over the
            range, with at least one level at 1.0, and another at 0.0. See
            &lt;&lt;devsandqueues-priority&gt;&gt;.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.PointSizeRange">
            <summary>
            pname:pointSizeRange[2] is the range
            [eq]#[pname:minimum,pname:maximum]# of supported sizes for points.
            Values written to variables decorated with the code:PointSize
            built-in decoration are clamped to this range.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.LineWidthRange">
            <summary>
            pname:lineWidthRange[2] is the range
            [eq]#[pname:minimum,pname:maximum]# of supported widths for lines.
            Values specified by the pname:lineWidth member of the
            sname:VkPipelineRasterizationStateCreateInfo or the pname:lineWidth
            parameter to fname:vkCmdSetLineWidth are clamped to this range.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.PointSizeGranularity">
            <summary>
            pname:pointSizeGranularity is the granularity of supported point
            sizes. Not all point sizes in the range defined by
            pname:pointSizeRange are supported. This limit specifies the
            granularity (or increment) between successive supported point
            sizes.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.LineWidthGranularity">
            <summary>
            pname:lineWidthGranularity is the granularity of supported line
            widths. Not all line widths in the range defined by
            pname:lineWidthRange are supported. This limit specifies the
            granularity (or increment) between successive supported line
            widths.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.StrictLines">
            <summary>
            pname:strictLines indicates whether lines are rasterized according
            to the preferred method of rasterization. If set to ename:VK_FALSE,
            lines may: be rasterized under a relaxed set of rules. If set to
            ename:VK_TRUE, lines are rasterized as per the strict definition.
            See &lt;&lt;primsrast-lines-basic,Basic Line Segment
            Rasterization&gt;&gt;.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.StandardSampleLocations">
            <summary>
            pname:standardSampleLocations indicates whether rasterization uses
            the standard sample locations as documented in
            &lt;&lt;primsrast-multisampling,Multisampling&gt;&gt;. If set to
            ename:VK_TRUE, the implementation uses the documented sample
            locations. If set to ename:VK_FALSE, the implementation may: use
            different sample locations.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.OptimalBufferCopyOffsetAlignment">
            <summary>
            pname:optimalBufferCopyOffsetAlignment is the optimal buffer offset
            alignment in bytes for fname:vkCmdCopyBufferToImage and
            fname:vkCmdCopyImageToBuffer. The per texel alignment requirements
            are still enforced, this is just an additional alignment
            recommendation for optimal performance and power.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.OptimalBufferCopyRowPitchAlignment">
            <summary>
            pname:optimalBufferCopyRowPitchAlignment is the optimal buffer row
            pitch alignment in bytes for fname:vkCmdCopyBufferToImage and
            fname:vkCmdCopyImageToBuffer. Row pitch is the number of bytes
            between texels with the same X coordinate in adjacent rows (Y
            coordinates differ by one). The per texel alignment requirements
            are still enforced, this is just an additional alignment
            recommendation for optimal performance and power.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceLimits.NonCoherentAtomSize">
            <summary>
            pname:nonCoherentAtomSize is the size and alignment in bytes that
            bounds concurrent access to &lt;&lt;memory-device-hostaccess,
            host-mapped device memory&gt;&gt;.
            </summary>
        </member>
        <member name="T:SharpVk.PhysicalDeviceMemoryProperties">
            <summary>
            <para>
            Structure specifying physical device memory properties.
            </para>
            <para>
            The sname:VkPhysicalDeviceMemoryProperties structure describes a number
            of _memory heaps_ as well as a number of _memory types_ that can: be
            used to access memory allocated in those heaps. Each heap describes a
            memory resource of a particular size, and each memory type describes a
            set of memory properties (e.g. host cached vs uncached) that can: be
            used with a given memory heap. Allocations using a particular memory
            type will consume resources from the heap indicated by that memory
            type's heap index. More than one memory type may: share each heap, and
            the heaps and memory types provide a mechanism to advertise an accurate
            size of the physical memory resources while allowing the memory to be
            used with a variety of different properties.
            </para>
            <para>
            The number of memory heaps is given by pname:memoryHeapCount and is
            less than or equal to ename:VK_MAX_MEMORY_HEAPS. Each heap is described
            by an element of the pname:memoryHeaps array, as a sname:VkMemoryHeap
            structure. The number of memory types available across all memory heaps
            is given by pname:memoryTypeCount and is less than or equal to
            ename:VK_MAX_MEMORY_TYPES. Each memory type is described by an element
            of the pname:memoryTypes array, as a sname:VkMemoryType structure.
            </para>
            <para>
            At least one heap must: include ename:VK_MEMORY_HEAP_DEVICE_LOCAL_BIT
            in slink:VkMemoryHeap::pname:flags. If there are multiple heaps that
            all have similar performance characteristics, they may: all include
            ename:VK_MEMORY_HEAP_DEVICE_LOCAL_BIT. In a unified memory architecture
            (UMA) system, there is often only a single memory heap which is
            considered to be equally "`local`" to the host and to the device, and
            such an implementation must: advertise the heap as device-local.
            </para>
            <para>
            Each memory type returned by flink:vkGetPhysicalDeviceMemoryProperties
            must: have its pname:propertyFlags set to one of the following values:
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceMemoryProperties.MemoryTypes">
            <summary>
            pname:memoryTypes is an array of slink:VkMemoryType structures
            describing the _memory types_ that can: be used to access memory
            allocated from the heaps specified by pname:memoryHeaps.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceMemoryProperties.MemoryHeaps">
            <summary>
            pname:memoryHeaps is an array of slink:VkMemoryHeap structures
            describing the _memory heaps_ from which memory can: be allocated.
            </summary>
        </member>
        <member name="T:SharpVk.PhysicalDeviceMemoryProperties2">
            <summary>
            Structure specifying physical device memory properties.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceMemoryProperties2.MemoryProperties">
            <summary>
            pname:memoryProperties is a structure of type
            slink:VkPhysicalDeviceMemoryProperties which is populated with the
            same values as in flink:vkGetPhysicalDeviceMemoryProperties.
            </summary>
        </member>
        <member name="T:SharpVk.PhysicalDeviceProperties">
            <summary>
            <para>
            Structure specifying physical device properties.
            </para>
            <para>
            The pname:vendorID and pname:deviceID fields are provided to allow
            applications to adapt to device characteristics that are not adequately
            exposed by other Vulkan queries. These may: include performance
            profiles, hardware errata, or other characteristics. In PCI-based
            implementations, the low sixteen bits of pname:vendorID and
            pname:deviceID must: contain (respectively) the PCI vendor and device
            IDs associated with the hardware device, and the remaining bits must:
            be set to zero. In non-PCI implementations, the choice of what values
            to return may: be dictated by operating system or platform policies. It
            is otherwise at the discretion of the implementer, subject to the
            following constraints and guidelines:
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceProperties.ApiVersion">
            <summary>
            pname:apiVersion is the version of Vulkan supported by the device,
            encoded as described in the &lt;&lt;fundamentals-versionnum,API
            Version Numbers and Semantics&gt;&gt; section.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceProperties.DriverVersion">
            <summary>
            pname:driverVersion is the vendor-specified version of the driver.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceProperties.VendorID">
            <summary>
            pname:vendorID is a unique identifier for the _vendor_ (see below)
            of the physical device.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceProperties.DeviceID">
            <summary>
            pname:deviceID is a unique identifier for the physical device among
            devices available from the vendor.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceProperties.DeviceType">
            <summary>
            pname:deviceType is a elink:VkPhysicalDeviceType specifying the
            type of device.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceProperties.DeviceName">
            <summary>
            pname:deviceName is a null-terminated UTF-8 string containing the
            name of the device.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceProperties.PipelineCacheUUID">
            <summary>
            pname:pipelineCacheUUID is an array of size ename:VK_UUID_SIZE,
            containing 8-bit values that represent a universally unique
            identifier for the device.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceProperties.Limits">
            <summary>
            pname:limits is the slink:VkPhysicalDeviceLimits structure which
            specifies device-specific limits of the physical device. See
            &lt;&lt;features-limits,Limits&gt;&gt; for details.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceProperties.SparseProperties">
            <summary>
            pname:sparseProperties is the
            slink:VkPhysicalDeviceSparseProperties structure which specifies
            various sparse related properties of the physical device. See
            &lt;&lt;sparsememory-physicalprops,Sparse Properties&gt;&gt; for
            details.
            </summary>
        </member>
        <member name="T:SharpVk.PhysicalDeviceProperties2">
            <summary>
            <para>
            Structure specifying physical device properties.
            </para>
            <para>
            The pname:pNext chain of this structure is used to extend the structure
            with properties defined by extensions.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceProperties2.Properties">
            <summary>
            pname:properties is a structure of type
            slink:VkPhysicalDeviceProperties describing the properties of the
            physical device. This structure is written with the same values as
            if it were written by flink:vkGetPhysicalDeviceProperties.
            </summary>
        </member>
        <member name="T:SharpVk.PhysicalDeviceSparseImageFormatInfo2">
            <summary>
            Structure specifying sparse image format inputs.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceSparseImageFormatInfo2.Format">
            <summary>
            pname:format is the image format.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceSparseImageFormatInfo2.Type">
            <summary>
            pname:type is the dimensionality of image.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceSparseImageFormatInfo2.Samples">
            <summary>
            pname:samples is the number of samples per pixel as defined in
            elink:VkSampleCountFlagBits.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceSparseImageFormatInfo2.Usage">
            <summary>
            pname:usage is a bitmask describing the intended usage of the
            image.
            </summary>
        </member>
        <member name="P:SharpVk.PhysicalDeviceSparseImageFormatInfo2.Tiling">
            <summary>
            pname:tiling is the tiling arrangement of the data elements in
            memory.
            </summary>
        </member>
        <member name="T:SharpVk.PhysicalDeviceSparseProperties">
            <summary>
            Structure specifying physical device sparse memory properties.
            </summary>
        </member>
        <member name="M:SharpVk.PhysicalDeviceSparseProperties.#ctor(SharpVk.Bool32,SharpVk.Bool32,SharpVk.Bool32,SharpVk.Bool32,SharpVk.Bool32)">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceSparseProperties.ResidencyStandard2DBlockShape">
            <summary>
            pname:residencyStandard2DBlockShape is ename:VK_TRUE if the
            physical device will access all single-sample 2D sparse resources
            using the standard sparse image block shapes (based on image
            format), as described in the
            &lt;&lt;sparsememory-sparseblockshapessingle,Standard Sparse Image
            Block Shapes (Single Sample)&gt;&gt; table. If this property is not
            supported the value returned in the pname:imageGranularity member
            of the sname:VkSparseImageFormatProperties structure for
            single-sample 2D images is not required: to match the standard
            sparse image block dimensions listed in the table.
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceSparseProperties.ResidencyStandard2DMultisampleBlockShape">
            <summary>
            pname:residencyStandard2DMultisampleBlockShape is ename:VK_TRUE if
            the physical device will access all multisample 2D sparse resources
            using the standard sparse image block shapes (based on image
            format), as described in the
            &lt;&lt;sparsememory-sparseblockshapesmsaa,Standard Sparse Image
            Block Shapes (MSAA)&gt;&gt; table. If this property is not
            supported, the value returned in the pname:imageGranularity member
            of the sname:VkSparseImageFormatProperties structure for
            multisample 2D images is not required: to match the standard sparse
            image block dimensions listed in the table.
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceSparseProperties.ResidencyStandard3DBlockShape">
            <summary>
            pname:residencyStandard3DBlockShape is ename:VK_TRUE if the
            physical device will access all 3D sparse resources using the
            standard sparse image block shapes (based on image format), as
            described in the
            &lt;&lt;sparsememory-sparseblockshapessingle,Standard Sparse Image
            Block Shapes (Single Sample)&gt;&gt; table. If this property is not
            supported, the value returned in the pname:imageGranularity member
            of the sname:VkSparseImageFormatProperties structure for 3D images
            is not required: to match the standard sparse image block
            dimensions listed in the table.
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceSparseProperties.ResidencyAlignedMipSize">
            <summary>
            pname:residencyAlignedMipSize is ename:VK_TRUE if images with mip
            level dimensions that are not integer multiples of the
            corresponding dimensions of the sparse image block may: be placed
            in the mip tail. If this property is not reported, only mip levels
            with dimensions smaller than the pname:imageGranularity member of
            the sname:VkSparseImageFormatProperties structure will be placed in
            the mip tail. If this property is reported the implementation is
            allowed to return ename:VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT
            in the pname:flags member of sname:VkSparseImageFormatProperties,
            indicating that mip level dimensions that are not integer multiples
            of the corresponding dimensions of the sparse image block will be
            placed in the mip tail.
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceSparseProperties.ResidencyNonResidentStrict">
            <summary>
            pname:residencyNonResidentStrict specifies whether the physical
            device can: consistently access non-resident regions of a resource.
            If this property is ename:VK_TRUE, access to non-resident regions
            of resources will be guaranteed to return values as if the resource
            were populated with 0; writes to non-resident regions will be
            discarded.
            </summary>
        </member>
        <member name="M:SharpVk.PhysicalDeviceSparseProperties.ToString">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.PhysicalDeviceType">
            <summary>
            <para>
            Supported physical device types.
            </para>
            <para>
            The physical device type is advertised for informational purposes only,
            and does not directly affect the operation of the system. However, the
            device type may: correlate with other advertised properties or
            capabilities of the system, such as how many memory heaps there are.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceType.Other">
            <summary>
            ename:VK_PHYSICAL_DEVICE_TYPE_OTHER The device does not match any
            other available types.
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceType.IntegratedGpu">
            <summary>
            ename:VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU The device is
            typically one embedded in or tightly coupled with the host.
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceType.DiscreteGpu">
            <summary>
            ename:VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU The device is typically
            a separate processor connected to the host via an interlink.
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceType.VirtualGpu">
            <summary>
            ename:VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU The device is typically a
            virtual node in a virtualization environment.
            </summary>
        </member>
        <member name="F:SharpVk.PhysicalDeviceType.Cpu">
            <summary>
            ename:VK_PHYSICAL_DEVICE_TYPE_CPU The device is typically running
            on the same processors as the host.
            </summary>
        </member>
        <member name="T:SharpVk.Pipeline">
            <summary>
            Opaque handle to a pipeline object.
            </summary>
        </member>
        <member name="M:SharpVk.Pipeline.Destroy">
            <summary>
            Destroy a pipeline object.
            </summary>
        </member>
        <member name="P:SharpVk.Pipeline.RawHandle">
            <summary>
            The interop handle for this Pipeline.
            </summary>
        </member>
        <member name="M:SharpVk.Pipeline.Dispose">
            <summary>
            Releases the unmanaged resources associated with this instance and
            destroys the underlying Vulkan handle.
            </summary>
        </member>
        <member name="T:SharpVk.PipelineBindPoint">
            <summary>
            <para>
            Specify the bind point of a pipeline object to a command buffer.
            </para>
            <para>
            Once bound, a pipeline binding affects subsequent graphics or compute
            commands in the command buffer until a different pipeline is bound to
            the bind point. The pipeline bound to
            ename:VK_PIPELINE_BIND_POINT_COMPUTE controls the behavior of
            flink:vkCmdDispatch and flink:vkCmdDispatchIndirect. The pipeline bound
            to ename:VK_PIPELINE_BIND_POINT_GRAPHICS controls the behavior of
            flink:vkCmdDraw, flink:vkCmdDrawIndexed, flink:vkCmdDrawIndirect, and
            flink:vkCmdDrawIndexedIndirect. No other commands are affected by the
            pipeline state.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PipelineBindPoint.Graphics">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PipelineBindPoint.Compute">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.PipelineCache">
            <summary>
            <para>
            Opaque handle to a pipeline cache object.
            </para>
            <para>
            Pipeline cache objects allow the result of pipeline construction to be
            reused between pipelines and between runs of an application. Reuse
            between pipelines is achieved by passing the same pipeline cache object
            when creating multiple related pipelines. Reuse across runs of an
            application is achieved by retrieving pipeline cache contents in one
            run of an application, saving the contents, and using them to
            preinitialize a pipeline cache on a subsequent run. The contents of the
            pipeline cache objects are managed by the implementation. Applications
            can: manage the host memory consumed by a pipeline cache object and
            control the amount of data retrieved from a pipeline cache object.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.PipelineCache.Destroy">
            <summary>
            Destroy a pipeline cache object.
            </summary>
        </member>
        <member name="M:SharpVk.PipelineCache.GetData">
            <summary>
            Get the data store from a pipeline cache.
            </summary>
        </member>
        <member name="M:SharpVk.PipelineCache.MergePipelineCaches(SharpVk.ArrayProxy{SharpVk.PipelineCache})">
            <summary>
            Combine the data stores of pipeline caches.
            </summary>
        </member>
        <member name="P:SharpVk.PipelineCache.RawHandle">
            <summary>
            The interop handle for this PipelineCache.
            </summary>
        </member>
        <member name="M:SharpVk.PipelineCache.Dispose">
            <summary>
            Releases the unmanaged resources associated with this instance and
            destroys the underlying Vulkan handle.
            </summary>
        </member>
        <member name="T:SharpVk.PipelineCacheCreateFlags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PipelineCacheCreateFlags.None">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.PipelineCacheCreateInfo">
            <summary>
            Structure specifying parameters of a newly created pipeline cache.
            </summary>
        </member>
        <member name="P:SharpVk.PipelineCacheCreateInfo.Flags">
            <summary>
            pname:flags is reserved for future use.
            </summary>
        </member>
        <member name="P:SharpVk.PipelineCacheCreateInfo.InitialData">
            <summary>
            pname:pInitialData is a pointer to previously retrieved pipeline
            cache data. If the pipeline cache data is incompatible (as defined
            below) with the device, the pipeline cache will be initially empty.
            If pname:initialDataSize is zero, pname:pInitialData is ignored.
            </summary>
        </member>
        <member name="T:SharpVk.PipelineCacheHeaderVersion">
            <summary>
            <para>
            Encode pipeline cache version.
            </para>
            <para>
            A consumer of the pipeline cache should: use the cache version to
            interpret the remainder of the cache header.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PipelineCacheHeaderVersion.One">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.PipelineColorBlendAttachmentState">
            <summary>
            Structure specifying a pipeline color blend attachment state.
            </summary>
        </member>
        <member name="M:SharpVk.PipelineColorBlendAttachmentState.#ctor(SharpVk.Bool32,SharpVk.BlendFactor,SharpVk.BlendFactor,SharpVk.BlendOp,SharpVk.BlendFactor,SharpVk.BlendFactor,SharpVk.BlendOp,SharpVk.ColorComponentFlags)">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.PipelineColorBlendAttachmentState.BlendEnable">
            <summary>
            pname:blendEnable controls whether blending is enabled for the
            corresponding color attachment. If blending is not enabled, the
            source fragment's color for that attachment is passed through
            unmodified.
            </summary>
        </member>
        <member name="F:SharpVk.PipelineColorBlendAttachmentState.SourceColorBlendFactor">
            <summary>
            pname:srcColorBlendFactor selects which blend factor is used to
            determine the source factors [eq]#(S~r~,S~g~,S~b~)#.
            </summary>
        </member>
        <member name="F:SharpVk.PipelineColorBlendAttachmentState.DestinationColorBlendFactor">
            <summary>
            pname:dstColorBlendFactor selects which blend factor is used to
            determine the destination factors [eq]#(D~r~,D~g~,D~b~)#.
            </summary>
        </member>
        <member name="F:SharpVk.PipelineColorBlendAttachmentState.ColorBlendOp">
            <summary>
            pname:colorBlendOp selects which blend operation is used to
            calculate the RGB values to write to the color attachment.
            </summary>
        </member>
        <member name="F:SharpVk.PipelineColorBlendAttachmentState.SourceAlphaBlendFactor">
            <summary>
            pname:srcAlphaBlendFactor selects which blend factor is used to
            determine the source factor [eq]#S~a~#.
            </summary>
        </member>
        <member name="F:SharpVk.PipelineColorBlendAttachmentState.DestinationAlphaBlendFactor">
            <summary>
            pname:dstAlphaBlendFactor selects which blend factor is used to
            determine the destination factor [eq]#D~a~#.
            </summary>
        </member>
        <member name="F:SharpVk.PipelineColorBlendAttachmentState.AlphaBlendOp">
            <summary>
            pname:alphaBlendOp selects which blend operation is use to
            calculate the alpha values to write to the color attachment.
            </summary>
        </member>
        <member name="F:SharpVk.PipelineColorBlendAttachmentState.ColorWriteMask">
            <summary>
            pname:colorWriteMask is a bitmask selecting which of the R, G, B,
            and/or A components are enabled for writing, as described later in
            this chapter.
            </summary>
        </member>
        <member name="M:SharpVk.PipelineColorBlendAttachmentState.ToString">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.PipelineColorBlendStateCreateFlags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PipelineColorBlendStateCreateFlags.None">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.PipelineColorBlendStateCreateInfo">
            <summary>
            <para>
            Structure specifying parameters of a newly created pipeline color blend
            state.
            </para>
            <para>
            Each element of the pname:pAttachments array is a
            slink:VkPipelineColorBlendAttachmentState structure specifying
            per-target blending state for each individual color attachment. If the
            &lt;&lt;features-features-independentBlend,independent blending&gt;&gt;
            feature is not enabled on the device, all
            slink:VkPipelineColorBlendAttachmentState elements in the
            pname:pAttachments array must: be identical.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PipelineColorBlendStateCreateInfo.Flags">
            <summary>
            pname:flags is reserved for future use.
            </summary>
        </member>
        <member name="P:SharpVk.PipelineColorBlendStateCreateInfo.LogicOpEnable">
            <summary>
            pname:logicOpEnable controls whether to apply
            &lt;&lt;framebuffer-logicop, Logical Operations&gt;&gt;.
            </summary>
        </member>
        <member name="P:SharpVk.PipelineColorBlendStateCreateInfo.LogicOp">
            <summary>
            pname:logicOp selects which logical operation to apply.
            </summary>
        </member>
        <member name="P:SharpVk.PipelineColorBlendStateCreateInfo.Attachments">
            <summary>
            pname:pAttachments: is a pointer to array of per target attachment
            states.
            </summary>
        </member>
        <member name="P:SharpVk.PipelineColorBlendStateCreateInfo.BlendConstants">
            <summary>
            pname:blendConstants is an array of four values used as the R, G,
            B, and A components of the blend constant that are used in
            blending, depending on the &lt;&lt;framebuffer-blendfactors,blend
            factor&gt;&gt;.
            </summary>
        </member>
        <member name="T:SharpVk.PipelineCreateFlags">
            <summary>
            <para>
            Bitmask controlling how a pipeline is generated.
            </para>
            <para>
            It is valid to set both ename:VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT
            and ename:VK_PIPELINE_CREATE_DERIVATIVE_BIT. This allows a pipeline to
            be both a parent and possibly a child in a pipeline hierarchy. See
            &lt;&lt;pipelines-pipeline-derivatives,Pipeline Derivatives&gt;&gt; for
            more information.
            </para>
            <para>
            pname:pDynamicState points to a structure of type
            sname:VkPipelineDynamicStateCreateInfo.
            </para>
            <para>
            ifdef::VK_NV_glsl_shader[] If any shader stage fails to compile,
            ifdef::VK_EXT_debug_report[] the compile log will be reported back to
            the application, and endif::VK_EXT_debug_report[]
            ename:VK_ERROR_INVALID_SHADER_NV will be generated.
            endif::VK_NV_glsl_shader[]
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PipelineCreateFlags.None">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PipelineCreateFlags.DisableOptimization">
            <summary>
            ename:VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT specifies that
            the created pipeline will not be optimized. Using this flag may:
            reduce the time taken to create the pipeline.
            </summary>
        </member>
        <member name="F:SharpVk.PipelineCreateFlags.AllowDerivatives">
            <summary>
            ename:VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT specifies that the
            pipeline to be created is allowed to be the parent of a pipeline
            that will be created in a subsequent call to
            flink:vkCreateGraphicsPipelines.
            </summary>
        </member>
        <member name="F:SharpVk.PipelineCreateFlags.Derivative">
            <summary>
            ename:VK_PIPELINE_CREATE_DERIVATIVE_BIT specifies that the pipeline
            to be created will be a child of a previously created parent
            pipeline.
            </summary>
        </member>
        <member name="T:SharpVk.PipelineDepthStencilStateCreateFlags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PipelineDepthStencilStateCreateFlags.None">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.PipelineDepthStencilStateCreateInfo">
            <summary>
            Structure specifying parameters of a newly created pipeline depth
            stencil state.
            </summary>
        </member>
        <member name="P:SharpVk.PipelineDepthStencilStateCreateInfo.Flags">
            <summary>
            pname:flags is reserved for future use.
            </summary>
        </member>
        <member name="P:SharpVk.PipelineDepthStencilStateCreateInfo.DepthTestEnable">
            <summary>
            pname:depthTestEnable controls whether &lt;&lt;fragops-depth,depth
            testing&gt;&gt; is enabled.
            </summary>
        </member>
        <member name="P:SharpVk.PipelineDepthStencilStateCreateInfo.DepthWriteEnable">
            <summary>
            pname:depthWriteEnable controls whether
            &lt;&lt;fragops-depth-write,depth writes&gt;&gt; are enabled.
            </summary>
        </member>
        <member name="P:SharpVk.PipelineDepthStencilStateCreateInfo.DepthCompareOp">
            <summary>
            pname:depthCompareOp is the comparison operator used in the
            &lt;&lt;fragops-depth,depth test&gt;&gt;.
            </summary>
        </member>
        <member name="P:SharpVk.PipelineDepthStencilStateCreateInfo.DepthBoundsTestEnable">
            <summary>
            pname:depthBoundsTestEnable controls whether
            &lt;&lt;fragops-dbt,depth bounds testing&gt;&gt; is enabled.
            </summary>
        </member>
        <member name="P:SharpVk.PipelineDepthStencilStateCreateInfo.StencilTestEnable">
            <summary>
            pname:stencilTestEnable controls whether
            &lt;&lt;fragops-stencil,stencil testing&gt;&gt; is enabled.
            </summary>
        </member>
        <member name="P:SharpVk.PipelineDepthStencilStateCreateInfo.Front">
            <summary>
            pname:front and pname:back control the parameters of the
            &lt;&lt;fragops-stencil,stencil test&gt;&gt;.
            </summary>
        </member>
        <member name="P:SharpVk.PipelineDepthStencilStateCreateInfo.Back">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.PipelineDepthStencilStateCreateInfo.MinDepthBounds">
            <summary>
            pname:minDepthBounds and pname:maxDepthBounds define the range of
            values used in the &lt;&lt;fragops-dbt,depth bounds test&gt;&gt;.
            </summary>
        </member>
        <member name="P:SharpVk.PipelineDepthStencilStateCreateInfo.MaxDepthBounds">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.PipelineDynamicStateCreateFlags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PipelineDynamicStateCreateFlags.None">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.PipelineDynamicStateCreateInfo">
            <summary>
            Structure specifying parameters of a newly created pipeline dynamic
            state.
            </summary>
        </member>
        <member name="P:SharpVk.PipelineDynamicStateCreateInfo.Flags">
            <summary>
            pname:flags is reserved for future use.
            </summary>
        </member>
        <member name="P:SharpVk.PipelineDynamicStateCreateInfo.DynamicStates">
            <summary>
            pname:pDynamicStates is an array of elink:VkDynamicState enums
            which indicate which pieces of pipeline state will use the values
            from dynamic state commands rather than from the pipeline state
            creation info.
            </summary>
        </member>
        <member name="T:SharpVk.PipelineInputAssemblyStateCreateFlags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PipelineInputAssemblyStateCreateFlags.None">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.PipelineInputAssemblyStateCreateInfo">
            <summary>
            <para>
            Structure specifying parameters of a newly created pipeline input
            assembly state.
            </para>
            <para>
            Restarting the assembly of primitives discards the most recent index
            values if those elements formed an incomplete primitive, and restarts
            the primitive assembly using the subsequent indices, but only
            assembling the immediately following element through the end of the
            originally specified elements. The primitive restart index value
            comparison is performed before adding the pname:vertexOffset value to
            the index value.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PipelineInputAssemblyStateCreateInfo.Flags">
            <summary>
            pname:flags is reserved for future use.
            </summary>
        </member>
        <member name="P:SharpVk.PipelineInputAssemblyStateCreateInfo.Topology">
            <summary>
            pname:topology is a elink:VkPrimitiveTopology defining the
            primitive topology, as described below.
            </summary>
        </member>
        <member name="P:SharpVk.PipelineInputAssemblyStateCreateInfo.PrimitiveRestartEnable">
            <summary>
            pname:primitiveRestartEnable controls whether a special vertex
            index value is treated as restarting the assembly of primitives.
            This enable only applies to indexed draws (flink:vkCmdDrawIndexed
            and flink:vkCmdDrawIndexedIndirect), and the special index value is
            either 0xFFFFFFFF when the pname:indexType parameter of
            fname:vkCmdBindIndexBuffer is equal to ename:VK_INDEX_TYPE_UINT32,
            or 0xFFFF when pname:indexType is equal to
            ename:VK_INDEX_TYPE_UINT16. Primitive restart is not allowed for
            "`list`" topologies.
            </summary>
        </member>
        <member name="T:SharpVk.PipelineLayout">
            <summary>
            <para>
            Opaque handle to a pipeline layout object.
            </para>
            <para>
            Access to descriptor sets from a pipeline is accomplished through a
            _pipeline layout_. Zero or more descriptor set layouts and zero or more
            push constant ranges are combined to form a pipeline layout object
            which describes the complete set of resources that can: be accessed by
            a pipeline. The pipeline layout represents a sequence of descriptor
            sets with each having a specific layout. This sequence of layouts is
            used to determine the interface between shader stages and shader
            resources. Each pipeline is created using a pipeline layout.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.PipelineLayout.Destroy">
            <summary>
            Destroy a pipeline layout object.
            </summary>
        </member>
        <member name="P:SharpVk.PipelineLayout.RawHandle">
            <summary>
            The interop handle for this PipelineLayout.
            </summary>
        </member>
        <member name="M:SharpVk.PipelineLayout.Dispose">
            <summary>
            Releases the unmanaged resources associated with this instance and
            destroys the underlying Vulkan handle.
            </summary>
        </member>
        <member name="T:SharpVk.PipelineLayoutCreateFlags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PipelineLayoutCreateFlags.None">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.PipelineLayoutCreateInfo">
            <summary>
            Structure specifying the parameters of a newly created pipeline layout
            object.
            </summary>
        </member>
        <member name="P:SharpVk.PipelineLayoutCreateInfo.Flags">
            <summary>
            pname:flags is reserved for future use.
            </summary>
        </member>
        <member name="P:SharpVk.PipelineLayoutCreateInfo.SetLayouts">
            <summary>
            pname:pSetLayouts is a pointer to an array of
            sname:VkDescriptorSetLayout objects.
            </summary>
        </member>
        <member name="P:SharpVk.PipelineLayoutCreateInfo.PushConstantRanges">
            <summary>
            pname:pPushConstantRanges is a pointer to an array of
            sname:VkPushConstantRange structures defining a set of push
            constant ranges for use in a single pipeline layout. In addition to
            descriptor set layouts, a pipeline layout also describes how many
            push constants can: be accessed by each stage of the pipeline. +
            [NOTE] .Note ==== Push constants represent a high speed path to
            modify constant data in pipelines that is expected to outperform
            memory-backed resource updates. ====
            </summary>
        </member>
        <member name="T:SharpVk.PipelineMultisampleStateCreateFlags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PipelineMultisampleStateCreateFlags.None">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.PipelineMultisampleStateCreateInfo">
            <summary>
            Structure specifying parameters of a newly created pipeline multisample
            state.
            </summary>
        </member>
        <member name="P:SharpVk.PipelineMultisampleStateCreateInfo.Flags">
            <summary>
            pname:flags is reserved for future use.
            </summary>
        </member>
        <member name="P:SharpVk.PipelineMultisampleStateCreateInfo.RasterizationSamples">
            <summary>
            pname:rasterizationSamples is a elink:VkSampleCountFlagBits
            specifying the number of samples per pixel used in rasterization.
            </summary>
        </member>
        <member name="P:SharpVk.PipelineMultisampleStateCreateInfo.SampleShadingEnable">
            <summary>
            pname:sampleShadingEnable specifies that fragment shading executes
            per-sample if ename:VK_TRUE, or per-fragment if ename:VK_FALSE, as
            described in &lt;&lt;primsrast-sampleshading,Sample
            Shading&gt;&gt;.
            </summary>
        </member>
        <member name="P:SharpVk.PipelineMultisampleStateCreateInfo.MinSampleShading">
            <summary>
            pname:minSampleShading is the minimum fraction of sample shading,
            as described in &lt;&lt;primsrast-sampleshading,Sample
            Shading&gt;&gt;.
            </summary>
        </member>
        <member name="P:SharpVk.PipelineMultisampleStateCreateInfo.SampleMask">
            <summary>
            pname:pSampleMask is a bitmask of static coverage information that
            is ANDed with the coverage information generated during
            rasterization, as described in &lt;&lt;fragops-samplemask,Sample
            Mask&gt;&gt;.
            </summary>
        </member>
        <member name="P:SharpVk.PipelineMultisampleStateCreateInfo.AlphaToCoverageEnable">
            <summary>
            pname:alphaToCoverageEnable controls whether a temporary coverage
            value is generated based on the alpha component of the fragment's
            first color output as specified in the
            &lt;&lt;fragops-covg,Multisample Coverage&gt;&gt; section.
            </summary>
        </member>
        <member name="P:SharpVk.PipelineMultisampleStateCreateInfo.AlphaToOneEnable">
            <summary>
            pname:alphaToOneEnable controls whether the alpha component of the
            fragment's first color output is replaced with one as described in
            &lt;&lt;fragops-covg,Multisample Coverage&gt;&gt;.
            </summary>
        </member>
        <member name="T:SharpVk.PipelineRasterizationStateCreateFlags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PipelineRasterizationStateCreateFlags.None">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.PipelineRasterizationStateCreateInfo">
            <summary>
            <para>
            Structure specifying parameters of a newly created pipeline
            rasterization state.
            </para>
            <para>
            ifdef::VK_AMD_rasterization_order[] The application can: also chain a
            sname:VkPipelineRasterizationStateRasterizationOrderAMD structure to
            the sname:VkPipelineRasterizationStateCreateInfo structure through its
            pname:pNext member. This structure enables selecting the rasterization
            order to use when rendering with the corresponding graphics pipeline as
            described in &lt;&lt;primrast-order, Rasterization Order&gt;&gt;.
            endif::VK_AMD_rasterization_order[]
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.PipelineRasterizationStateCreateInfo.Flags">
            <summary>
            pname:flags is reserved for future use.
            </summary>
        </member>
        <member name="P:SharpVk.PipelineRasterizationStateCreateInfo.DepthClampEnable">
            <summary>
            pname:depthClampEnable controls whether to clamp the fragment's
            depth values instead of clipping primitives to the z planes of the
            frustum, as described in &lt;&lt;vertexpostproc-clipping,Primitive
            Clipping&gt;&gt;.
            </summary>
        </member>
        <member name="P:SharpVk.PipelineRasterizationStateCreateInfo.RasterizerDiscardEnable">
            <summary>
            pname:rasterizerDiscardEnable controls whether primitives are
            discarded immediately before the rasterization stage.
            </summary>
        </member>
        <member name="P:SharpVk.PipelineRasterizationStateCreateInfo.PolygonMode">
            <summary>
            pname:polygonMode is the triangle rendering mode. See
            elink:VkPolygonMode.
            </summary>
        </member>
        <member name="P:SharpVk.PipelineRasterizationStateCreateInfo.CullMode">
            <summary>
            pname:cullMode is the triangle facing direction used for primitive
            culling. See elink:VkCullModeFlagBits.
            </summary>
        </member>
        <member name="P:SharpVk.PipelineRasterizationStateCreateInfo.FrontFace">
            <summary>
            pname:frontFace is the front-facing triangle orientation to be used
            for culling. See elink:VkFrontFace.
            </summary>
        </member>
        <member name="P:SharpVk.PipelineRasterizationStateCreateInfo.DepthBiasEnable">
            <summary>
            pname:depthBiasEnable controls whether to bias fragment depth
            values.
            </summary>
        </member>
        <member name="P:SharpVk.PipelineRasterizationStateCreateInfo.DepthBiasConstantFactor">
            <summary>
            pname:depthBiasConstantFactor is a scalar factor controlling the
            constant depth value added to each fragment.
            </summary>
        </member>
        <member name="P:SharpVk.PipelineRasterizationStateCreateInfo.DepthBiasClamp">
            <summary>
            pname:depthBiasClamp is the maximum (or minimum) depth bias of a
            fragment.
            </summary>
        </member>
        <member name="P:SharpVk.PipelineRasterizationStateCreateInfo.DepthBiasSlopeFactor">
            <summary>
            pname:depthBiasSlopeFactor is a scalar factor applied to a
            fragment's slope in depth bias calculations.
            </summary>
        </member>
        <member name="P:SharpVk.PipelineRasterizationStateCreateInfo.LineWidth">
            <summary>
            pname:lineWidth is the width of rasterized line segments.
            </summary>
        </member>
        <member name="T:SharpVk.PipelineRasterizationStateRasterizationOrder">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.PipelineRasterizationStateRasterizationOrder.RasterizationOrder">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.PipelineShaderStageCreateFlags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PipelineShaderStageCreateFlags.None">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.PipelineShaderStageCreateInfo">
            <summary>
            Structure specifying parameters of a newly created pipeline shader
            stage.
            </summary>
        </member>
        <member name="P:SharpVk.PipelineShaderStageCreateInfo.Flags">
            <summary>
            pname:flags is reserved for future use.
            </summary>
        </member>
        <member name="P:SharpVk.PipelineShaderStageCreateInfo.Stage">
            <summary>
            pname:stage names a single pipeline stage. Bits which can: be set
            include: + --
            </summary>
        </member>
        <member name="P:SharpVk.PipelineShaderStageCreateInfo.Module">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.PipelineShaderStageCreateInfo.Name">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.PipelineShaderStageCreateInfo.SpecializationInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.PipelineStageFlags">
            <summary>
            <para>
            Bitmask specifying pipeline stages.
            </para>
            <para>
            Several of the synchronization commands include pipeline stage
            parameters, restricting the
            &lt;&lt;synchronization-dependencies-scopes, synchronization
            scopes&gt;&gt; for that command to just those stages. This allows fine
            grained control over the exact execution dependencies and accesses
            performed by action commands. Implementations should: use these
            pipeline stages to avoid unnecessary stalls or cache flushing.
            </para>
            <para>
            ** ename:VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT **
            ename:VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT **
            ename:VK_PIPELINE_STAGE_VERTEX_INPUT_BIT **
            ename:VK_PIPELINE_STAGE_VERTEX_SHADER_BIT **
            ename:VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT **
            ename:VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT **
            ename:VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT **
            ename:VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT **
            ename:VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT **
            ename:VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT **
            ename:VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT **
            ename:VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT
            </para>
            <para>
            * ename:VK_PIPELINE_STAGE_ALL_COMMANDS_BIT: Equivalent to the logical
            or of every other pipeline stage flag that is supported on the queue it
            is used with.
            </para>
            <para>
            [NOTE] .Note ==== An execution dependency with only
            ename:VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT in the destination stage
            mask will only prevent that stage from executing in subsequently
            submitted commands. As this stage doesn't perform any actual execution,
            this is not observable - in effect, it does not delay processing of
            subsequent commands. Similarly an execution dependency with only
            ename:VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT in the source stage mask will
            effectively not wait for any prior commands to complete.
            </para>
            <para>
            When defining a memory dependency, using only
            ename:VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT or
            ename:VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT would never make any accesses
            available and/or visible because these stages do not access memory.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PipelineStageFlags.None">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PipelineStageFlags.TopOfPipe">
            <summary>
            ename:VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT: Stage of the pipeline
            where any commands are initially received by the queue.
            ifdef::VK_NVX_device_generated_commands[]
            </summary>
        </member>
        <member name="F:SharpVk.PipelineStageFlags.DrawIndirect">
            <summary>
            ename:VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT: Stage of the pipeline
            where Draw/DispatchIndirect data structures are consumed.
            ifdef::VK_NVX_device_generated_commands[] This stage also includes
            reading commands written by flink:vkCmdProcessCommandsNVX.
            endif::VK_NVX_device_generated_commands[]
            </summary>
        </member>
        <member name="F:SharpVk.PipelineStageFlags.VertexInput">
            <summary>
            ename:VK_PIPELINE_STAGE_VERTEX_INPUT_BIT: Stage of the pipeline
            where vertex and index buffers are consumed.
            </summary>
        </member>
        <member name="F:SharpVk.PipelineStageFlags.VertexShader">
            <summary>
            ename:VK_PIPELINE_STAGE_VERTEX_SHADER_BIT: Vertex shader stage.
            </summary>
        </member>
        <member name="F:SharpVk.PipelineStageFlags.TessellationControlShader">
            <summary>
            ename:VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT:
            Tessellation control shader stage.
            </summary>
        </member>
        <member name="F:SharpVk.PipelineStageFlags.TessellationEvaluationShader">
            <summary>
            ename:VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT:
            Tessellation evaluation shader stage.
            </summary>
        </member>
        <member name="F:SharpVk.PipelineStageFlags.GeometryShader">
            <summary>
            ename:VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT: Geometry shader stage.
            </summary>
        </member>
        <member name="F:SharpVk.PipelineStageFlags.FragmentShader">
            <summary>
            ename:VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT: Fragment shader stage.
            </summary>
        </member>
        <member name="F:SharpVk.PipelineStageFlags.EarlyFragmentTests">
            <summary>
            ename:VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT: Stage of the
            pipeline where early fragment tests (depth and stencil tests before
            fragment shading) are performed. This stage also includes
            &lt;&lt;renderpass-load-store-ops, subpass load operations&gt;&gt;
            for framebuffer attachments with a depth/stencil format.
            </summary>
        </member>
        <member name="F:SharpVk.PipelineStageFlags.LateFragmentTests">
            <summary>
            ename:VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT: Stage of the
            pipeline where late fragment tests (depth and stencil tests after
            fragment shading) are performed. This stage also includes
            &lt;&lt;renderpass-load-store-ops, subpass store operations&gt;&gt;
            for framebuffer attachments with a depth/stencil format.
            </summary>
        </member>
        <member name="F:SharpVk.PipelineStageFlags.ColorAttachmentOutput">
            <summary>
            ename:VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT: Stage of the
            pipeline after blending where the final color values are output
            from the pipeline. This stage also includes
            &lt;&lt;renderpass-load-store-ops, subpass load and store
            operations&gt;&gt; and multisample resolve operations for
            framebuffer attachments with a color format.
            </summary>
        </member>
        <member name="F:SharpVk.PipelineStageFlags.ComputeShader">
            <summary>
            ename:VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT: Execution of a compute
            shader.
            </summary>
        </member>
        <member name="F:SharpVk.PipelineStageFlags.Transfer">
            <summary>
            ename:VK_PIPELINE_STAGE_TRANSFER_BIT: Execution of copy commands.
            This includes the operations resulting from all &lt;&lt;copies,copy
            commands&gt;&gt;, &lt;&lt;clears,clear commands&gt;&gt; (with the
            exception of flink:vkCmdClearAttachments), and
            flink:vkCmdCopyQueryPoolResults.
            </summary>
        </member>
        <member name="F:SharpVk.PipelineStageFlags.BottomOfPipe">
            <summary>
            ename:VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT: Final stage in the
            pipeline where operations generated by all commands complete
            execution.
            </summary>
        </member>
        <member name="F:SharpVk.PipelineStageFlags.Host">
            <summary>
            ename:VK_PIPELINE_STAGE_HOST_BIT: A pseudo-stage indicating
            execution on the host of reads/writes of device memory. This stage
            is not invoked by any commands recorded in a command buffer.
            </summary>
        </member>
        <member name="F:SharpVk.PipelineStageFlags.AllGraphics">
            <summary>
            ename:VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT: Execution of all graphics
            pipeline stages. Equivalent to the logical or of:
            </summary>
        </member>
        <member name="F:SharpVk.PipelineStageFlags.AllCommands">
            <summary>
            All stages supported on the queue
            </summary>
        </member>
        <member name="F:SharpVk.PipelineStageFlags.CommandProcess">
            <summary>
            ename:VK_PIPELINE_STAGE_COMMAND_PROCESS_BIT_NVX: Stage of the
            pipeline where device-side generation of commands via
            flink:vkCmdProcessCommandsNVX is handled.
            endif::VK_NVX_device_generated_commands[]
            </summary>
        </member>
        <member name="T:SharpVk.PipelineTessellationStateCreateFlags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PipelineTessellationStateCreateFlags.None">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.PipelineTessellationStateCreateInfo">
            <summary>
            Structure specifying parameters of a newly created pipeline
            tessellation state.
            </summary>
        </member>
        <member name="P:SharpVk.PipelineTessellationStateCreateInfo.Flags">
            <summary>
            pname:flags is reserved for future use.
            </summary>
        </member>
        <member name="P:SharpVk.PipelineTessellationStateCreateInfo.PatchControlPoints">
            <summary>
            pname:patchControlPoints number of control points per patch.
            </summary>
        </member>
        <member name="T:SharpVk.PipelineVertexInputStateCreateFlags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PipelineVertexInputStateCreateFlags.None">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.PipelineVertexInputStateCreateInfo">
            <summary>
            Structure specifying parameters of a newly created pipeline vertex
            input state.
            </summary>
        </member>
        <member name="P:SharpVk.PipelineVertexInputStateCreateInfo.Flags">
            <summary>
            pname:flags is reserved for future use.
            </summary>
        </member>
        <member name="P:SharpVk.PipelineVertexInputStateCreateInfo.VertexBindingDescriptions">
            <summary>
            pname:pVertexBindingDescriptions is a pointer to an array of
            sname:VkVertexInputBindingDescription structures.
            </summary>
        </member>
        <member name="P:SharpVk.PipelineVertexInputStateCreateInfo.VertexAttributeDescriptions">
            <summary>
            pname:pVertexAttributeDescriptions is a pointer to an array of
            sname:VkVertexInputAttributeDescription structures.
            </summary>
        </member>
        <member name="T:SharpVk.PipelineViewportStateCreateFlags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PipelineViewportStateCreateFlags.None">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.PipelineViewportStateCreateInfo">
            <summary>
            Structure specifying parameters of a newly created pipeline viewport
            state.
            </summary>
        </member>
        <member name="P:SharpVk.PipelineViewportStateCreateInfo.Flags">
            <summary>
            pname:flags is reserved for future use.
            </summary>
        </member>
        <member name="P:SharpVk.PipelineViewportStateCreateInfo.Viewports">
            <summary>
            pname:pViewports is a pointer to an array of slink:VkViewport
            structures, defining the viewport transforms. If the viewport state
            is dynamic, this member is ignored.
            </summary>
        </member>
        <member name="P:SharpVk.PipelineViewportStateCreateInfo.Scissors">
            <summary>
            pname:pScissors is a pointer to an array of sname:VkRect2D
            structures which define the rectangular bounds of the scissor for
            the corresponding viewport. If the scissor state is dynamic, this
            member is ignored.
            </summary>
        </member>
        <member name="T:SharpVk.PolygonMode">
            <summary>
            <para>
            Control polygon rasterization mode.
            </para>
            <para>
            The pname:polygonMode selects which method of rasterization is used for
            polygons. If pname:polygonMode is ename:VK_POLYGON_MODE_POINT, then the
            vertices of polygons are treated, for rasterization purposes, as if
            they had been drawn as points. ename:VK_POLYGON_MODE_LINE causes
            polygon edges to be drawn as line segments. ename:VK_POLYGON_MODE_FILL
            causes polygons to render using the polygon rasterization rules in this
            section.
            </para>
            <para>
            Note that these modes affect only the final rasterization of polygons:
            in particular, a polygon's vertices are shaded and the polygon is
            clipped and possibly culled before these modes are applied.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PolygonMode.Fill">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PolygonMode.Line">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PolygonMode.Point">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.PresentInfo">
            <summary>
            Structure describing parameters of a queue presentation.
            </summary>
        </member>
        <member name="P:SharpVk.PresentInfo.WaitSemaphores">
            <summary>
            pname:pWaitSemaphores, if not code:VK_NULL_HANDLE, is an array of
            sname:VkSemaphore objects with pname:waitSemaphoreCount entries,
            and specifies the semaphores to wait for before issuing the present
            request.
            </summary>
        </member>
        <member name="P:SharpVk.PresentInfo.Swapchains">
            <summary>
            pname:pSwapchains is an array of sname:VkSwapchainKHR objects with
            pname:swapchainCount entries. A given swapchain must: not appear in
            this list more than once.
            </summary>
        </member>
        <member name="P:SharpVk.PresentInfo.ImageIndices">
            <summary>
            pname:pImageIndices is an array of indices into the array of each
            swapchain's presentable images, with pname:swapchainCount entries.
            Each entry in this array identifies the image to present on the
            corresponding entry in the pname:pSwapchains array.
            </summary>
        </member>
        <member name="P:SharpVk.PresentInfo.Results">
            <summary>
            pname:pResults is an array of ename:VkResult typed elements with
            pname:swapchainCount entries. Applications that do not need
            per-swapchain results can: use `NULL` for pname:pResults. If
            non-`NULL`, each entry in pname:pResults will be set to the
            ename:VkResult for presenting the swapchain corresponding to the
            same index in pname:pSwapchains.
            </summary>
        </member>
        <member name="T:SharpVk.PresentMode">
            <summary>
            <para>
            Presentation mode supported for a surface.
            </para>
            <para>
            [NOTE] .Note ==== For reference, the mode indicated by
            ename:VK_PRESENT_MODE_FIFO_KHR is equivalent to the behavior of
            {wgl|glX|egl}SwapBuffers with a swap interval of 1, while the mode
            indicated by ename:VK_PRESENT_MODE_FIFO_RELAXED_KHR is equivalent to
            the behavior of {wgl|glX}SwapBuffers with a swap interval of -1 (from
            the {WGL|GLX}_EXT_swap_control_tear extensions). ====
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.PresentMode.Immediate">
            <summary>
            ename:VK_PRESENT_MODE_IMMEDIATE_KHR: The presentation engine does
            not wait for a vertical blanking period to update the current
            image, meaning this mode may: result in visible tearing. No
            internal queuing of presentation requests is needed, as the
            requests are applied immediately.
            </summary>
        </member>
        <member name="F:SharpVk.PresentMode.Mailbox">
            <summary>
            ename:VK_PRESENT_MODE_MAILBOX_KHR: The presentation engine waits
            for the next vertical blanking period to update the current image.
            Tearing cannot: be observed. An internal single-entry queue is used
            to hold pending presentation requests. If the queue is full when a
            new presentation request is received, the new request replaces the
            existing entry, and any images associated with the prior entry
            become available for re-use by the application. One request is
            removed from the queue and processed during each vertical blanking
            period in which the queue is non-empty.
            </summary>
        </member>
        <member name="F:SharpVk.PresentMode.Fifo">
            <summary>
            ename:VK_PRESENT_MODE_FIFO_KHR: The presentation engine waits for
            the next vertical blanking period to update the current image.
            Tearing cannot: be observed. An internal queue is used to hold
            pending presentation requests. New requests are appended to the end
            of the queue, and one request is removed from the beginning of the
            queue and processed during each vertical blanking period in which
            the queue is non-empty. This is the only value of pname:presentMode
            that is required: to be supported.
            </summary>
        </member>
        <member name="F:SharpVk.PresentMode.FifoRelaxed">
            <summary>
            ename:VK_PRESENT_MODE_FIFO_RELAXED_KHR: The presentation engine
            generally waits for the next vertical blanking period to update the
            current image. If a vertical blanking period has already passed
            since the last update of the current image then the presentation
            engine does not wait for another vertical blanking period for the
            update, meaning this mode may: result in visible tearing in this
            case. This mode is useful for reducing visual stutter with an
            application that will mostly present a new image before the next
            vertical blanking period, but may occasionally be late, and present
            a new image just after the next vertical blanking period. An
            internal queue is used to hold pending presentation requests. New
            requests are appended to the end of the queue, and one request is
            removed from the beginning of the queue and processed during or
            after each vertical blanking period in which the queue is
            non-empty.
            </summary>
        </member>
        <member name="T:SharpVk.PrimitiveTopology">
            <summary>
            Supported primitive topologies.
            </summary>
        </member>
        <member name="F:SharpVk.PrimitiveTopology.PointList">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PrimitiveTopology.LineList">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PrimitiveTopology.LineStrip">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PrimitiveTopology.TriangleList">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PrimitiveTopology.TriangleStrip">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PrimitiveTopology.TriangleFan">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PrimitiveTopology.LineListWithAdjacency">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PrimitiveTopology.LineStripWithAdjacency">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PrimitiveTopology.TriangleListWithAdjacency">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PrimitiveTopology.TriangleStripWithAdjacency">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.PrimitiveTopology.PatchList">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.PushConstantRange">
            <summary>
            Structure specifying a push constant range.
            </summary>
        </member>
        <member name="M:SharpVk.PushConstantRange.#ctor(SharpVk.ShaderStageFlags,System.UInt32,System.UInt32)">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.PushConstantRange.StageFlags">
            <summary>
            pname:stageFlags is a set of stage flags describing the shader
            stages that will access a range of push constants. If a particular
            stage is not included in the range, then accessing members of that
            range of push constants from the corresponding shader stage will
            result in undefined data being read.
            </summary>
        </member>
        <member name="F:SharpVk.PushConstantRange.Offset">
            <summary>
            pname:offset and pname:size are the start offset and size,
            respectively, consumed by the range. Both pname:offset and
            pname:size are in units of bytes and must: be a multiple of 4. The
            layout of the push constant variables is specified in the shader.
            </summary>
        </member>
        <member name="F:SharpVk.PushConstantRange.Size">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.PushConstantRange.ToString">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.QueryControlFlags">
            <summary>
            <para>
            Bitmask specifying constraints on a query.
            </para>
            <para>
            If the pname:queryType of the pool is ename:VK_QUERY_TYPE_OCCLUSION and
            pname:flags contains ename:VK_QUERY_CONTROL_PRECISE_BIT, an
            implementation must: return a result that matches the actual number of
            samples passed. This is described in more detail in
            &lt;&lt;queries-occlusion,Occlusion Queries&gt;&gt;.
            </para>
            <para>
            After beginning a query, that query is considered _active_ within the
            command buffer it was called in until that same query is ended. Queries
            active in a primary command buffer when secondary command buffers are
            executed are considered active for those secondary command buffers.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.QueryControlFlags.None">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.QueryControlFlags.Precise">
            <summary>
            Require precise results to be collected by the query
            </summary>
        </member>
        <member name="T:SharpVk.QueryPipelineStatisticFlags">
            <summary>
            <para>
            Bitmask specifying queried pipeline statistics.
            </para>
            <para>
            These bits have the following meanings:
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.QueryPipelineStatisticFlags.None">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.QueryPipelineStatisticFlags.InputAssemblyVertices">
            <summary>
            Optional
            </summary>
        </member>
        <member name="F:SharpVk.QueryPipelineStatisticFlags.InputAssemblyPrimitives">
            <summary>
            Optional
            </summary>
        </member>
        <member name="F:SharpVk.QueryPipelineStatisticFlags.VertexShaderInvocations">
            <summary>
            Optional
            </summary>
        </member>
        <member name="F:SharpVk.QueryPipelineStatisticFlags.GeometryShaderInvocations">
            <summary>
            Optional
            </summary>
        </member>
        <member name="F:SharpVk.QueryPipelineStatisticFlags.GeometryShaderPrimitives">
            <summary>
            Optional
            </summary>
        </member>
        <member name="F:SharpVk.QueryPipelineStatisticFlags.ClippingInvocations">
            <summary>
            Optional
            </summary>
        </member>
        <member name="F:SharpVk.QueryPipelineStatisticFlags.ClippingPrimitives">
            <summary>
            Optional
            </summary>
        </member>
        <member name="F:SharpVk.QueryPipelineStatisticFlags.FragmentShaderInvocations">
            <summary>
            Optional
            </summary>
        </member>
        <member name="F:SharpVk.QueryPipelineStatisticFlags.TessellationControlShaderPatches">
            <summary>
            Optional
            </summary>
        </member>
        <member name="F:SharpVk.QueryPipelineStatisticFlags.TessellationEvaluationShaderInvocations">
            <summary>
            Optional
            </summary>
        </member>
        <member name="F:SharpVk.QueryPipelineStatisticFlags.ComputeShaderInvocations">
            <summary>
            Optional
            </summary>
        </member>
        <member name="T:SharpVk.QueryPool">
            <summary>
            <para>
            Opaque handle to a query pool object.
            </para>
            <para>
            Queries are managed using _query pool_ objects. Each query pool is a
            collection of a specific number of queries of a particular type.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.QueryPool.Destroy">
            <summary>
            Destroy a query pool object.
            </summary>
        </member>
        <member name="M:SharpVk.QueryPool.GetResults(System.UInt32,System.UInt32,SharpVk.ArrayProxy{System.Byte},SharpVk.DeviceSize,SharpVk.QueryResultFlags)">
            <summary>
            Copy results of queries in a query pool to a host memory region.
            </summary>
        </member>
        <member name="P:SharpVk.QueryPool.RawHandle">
            <summary>
            The interop handle for this QueryPool.
            </summary>
        </member>
        <member name="M:SharpVk.QueryPool.Dispose">
            <summary>
            Releases the unmanaged resources associated with this instance and
            destroys the underlying Vulkan handle.
            </summary>
        </member>
        <member name="T:SharpVk.QueryPoolCreateFlags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.QueryPoolCreateFlags.None">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.QueryPoolCreateInfo">
            <summary>
            Structure specifying parameters of a newly created query pool.
            </summary>
        </member>
        <member name="P:SharpVk.QueryPoolCreateInfo.Flags">
            <summary>
            pname:flags is reserved for future use.
            </summary>
        </member>
        <member name="P:SharpVk.QueryPoolCreateInfo.QueryType">
            <summary>
            pname:queryType is the type of queries managed by the pool, and
            must: be one of the values + --
            </summary>
        </member>
        <member name="P:SharpVk.QueryPoolCreateInfo.QueryCount">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.QueryPoolCreateInfo.PipelineStatistics">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.QueryResultFlags">
            <summary>
            <para>
            Bitmask specifying how and when query results are returned.
            </para>
            <para>
            If no bits are set in pname:flags, and all requested queries are in the
            available state, results are written as an array of 32-bit unsigned
            integer values. The behavior when not all queries are available, is
            described &lt;&lt;queries-wait-bit-not-set, below&gt;&gt;.
            </para>
            <para>
            If ename:VK_QUERY_RESULT_64_BIT is not set and the result overflows a
            32-bit value, the value may: either wrap or saturate. Similarly, if
            ename:VK_QUERY_RESULT_64_BIT is set and the result overflows a 64-bit
            value, the value may: either wrap or saturate.
            </para>
            <para>
            If ename:VK_QUERY_RESULT_WAIT_BIT is set, Vulkan will wait for each
            query to be in the available state before retrieving the numerical
            results for that query. In this case, fname:vkGetQueryPoolResults is
            guaranteed to succeed and return ename:VK_SUCCESS if the queries become
            available in a finite time (i.e. if they have been issued and not
            reset). If queries will never finish (e.g. due to being reset but not
            issued), then fname:vkGetQueryPoolResults may: not return in finite
            time.
            </para>
            <para>
            If ename:VK_QUERY_RESULT_WAIT_BIT and ename:VK_QUERY_RESULT_PARTIAL_BIT
            are both not set then no result values are written to pname:pData for
            queries that are in the unavailable state at the time of the call, and
            fname:vkGetQueryPoolResults returns ename:VK_NOT_READY. However,
            availability state is still written to pname:pData for those queries if
            ename:VK_QUERY_RESULT_WITH_AVAILABILITY_BIT is set.
            </para>
            <para>
            [NOTE] .Note ==== Applications must: take care to ensure that use of
            the ename:VK_QUERY_RESULT_WAIT_BIT bit has the desired effect.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.QueryResultFlags.None">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.QueryResultFlags.QueryResult64">
            <summary>
            Results of the queries are written to the destination buffer as
            64-bit values
            </summary>
        </member>
        <member name="F:SharpVk.QueryResultFlags.Wait">
            <summary>
            Results of the queries are waited on before proceeding with the
            result copy
            </summary>
        </member>
        <member name="F:SharpVk.QueryResultFlags.WithAvailability">
            <summary>
            Besides the results of the query, the availability of the results
            is also written
            </summary>
        </member>
        <member name="F:SharpVk.QueryResultFlags.Partial">
            <summary>
            Copy the partial results of the query even if the final results are
            not available
            </summary>
        </member>
        <member name="T:SharpVk.QueryType">
            <summary>
            Specify the type of queries managed by a query pool.
            </summary>
        </member>
        <member name="F:SharpVk.QueryType.Occlusion">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.QueryType.PipelineStatistics">
            <summary>
            Optional
            </summary>
        </member>
        <member name="F:SharpVk.QueryType.Timestamp">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Queue">
            <summary>
            <para>
            Opaque handle to a queue object.
            </para>
            <para>
            Creating a logical device also creates the queues associated with that
            device. The queues to create are described by a set of
            slink:VkDeviceQueueCreateInfo structures that are passed to
            flink:vkCreateDevice in pname:pQueueCreateInfos.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Queue.Submit(SharpVk.ArrayProxy{SharpVk.SubmitInfo},SharpVk.Fence)">
            <summary>
            Submits a sequence of semaphores or command buffers to a queue.
            </summary>
        </member>
        <member name="M:SharpVk.Queue.WaitIdle">
            <summary>
            Wait for a queue to become idle.
            </summary>
        </member>
        <member name="M:SharpVk.Queue.BindSparse(SharpVk.ArrayProxy{SharpVk.BindSparseInfo},SharpVk.Fence)">
            <summary>
            Bind device memory to a sparse resource object.
            </summary>
        </member>
        <member name="M:SharpVk.Queue.Present(SharpVk.PresentInfo)">
            <summary>
            Queue an image for presentation.
            </summary>
        </member>
        <member name="P:SharpVk.Queue.RawHandle">
            <summary>
            The interop handle for this Queue.
            </summary>
        </member>
        <member name="T:SharpVk.QueueFamilyProperties">
            <summary>
            <para>
            Structure providing information about a queue family.
            </para>
            <para>
            The bits specified in pname:queueFlags are:
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.QueueFamilyProperties.#ctor(SharpVk.QueueFlags,System.UInt32,System.UInt32,SharpVk.Extent3D)">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.QueueFamilyProperties.QueueFlags">
            <summary>
            pname:queueFlags contains flags indicating the capabilities of the
            queues in this queue family.
            </summary>
        </member>
        <member name="F:SharpVk.QueueFamilyProperties.QueueCount">
            <summary>
            pname:queueCount is the unsigned integer count of queues in this
            queue family.
            </summary>
        </member>
        <member name="F:SharpVk.QueueFamilyProperties.TimestampValidBits">
            <summary>
            pname:timestampValidBits is the unsigned integer count of
            meaningful bits in the timestamps written via
            fname:vkCmdWriteTimestamp. The valid range for the count is 36..64
            bits, or a value of 0, indicating no support for timestamps. Bits
            outside the valid range are guaranteed to be zeros.
            </summary>
        </member>
        <member name="F:SharpVk.QueueFamilyProperties.MinImageTransferGranularity">
            <summary>
            pname:minImageTransferGranularity is the minimum granularity
            supported for image transfer operations on the queues in this queue
            family.
            </summary>
        </member>
        <member name="M:SharpVk.QueueFamilyProperties.ToString">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.QueueFamilyProperties2">
            <summary>
            Structure providing information about a queue family.
            </summary>
        </member>
        <member name="P:SharpVk.QueueFamilyProperties2.QueueFamilyProperties">
            <summary>
            pname:queueFamilyProperties is a structure of type
            slink:VkQueueFamilyProperties which is populated with the same
            values as in flink:vkGetPhysicalDeviceQueueFamilyProperties.
            </summary>
        </member>
        <member name="T:SharpVk.QueueFlags">
            <summary>
            <para>
            Bitmask specifying capabilities of queues in a queue family.
            </para>
            <para>
            If an implementation exposes any queue family that supports graphics
            operations, at least one queue family of at least one physical device
            exposed by the implementation must: support both graphics and compute
            operations.
            </para>
            <para>
            [NOTE] .Note ==== All commands that are allowed on a queue that
            supports transfer operations are also allowed on a queue that supports
            either graphics or compute operations thus if the capabilities of a
            queue family include ename:VK_QUEUE_GRAPHICS_BIT or
            ename:VK_QUEUE_COMPUTE_BIT then reporting the
            ename:VK_QUEUE_TRANSFER_BIT capability separately for that queue family
            is optional:. ====
            </para>
            <para>
            For further details see &lt;&lt;devsandqueues-queues,Queues&gt;&gt;.
            </para>
            <para>
            The value returned in pname:minImageTransferGranularity has a unit of
            compressed texel blocks for images having a block-compressed format,
            and a unit of texels otherwise.
            </para>
            <para>
            Possible values of pname:minImageTransferGranularity are:
            </para>
            <para>
            * [eq]#(0,0,0)# which indicates that only whole mip levels must: be
            transferred using the image transfer operations on the corresponding
            queues. In this case, the following restrictions apply to all offset
            and extent parameters of image transfer operations:
            </para>
            <para>
            ** The pname:x, pname:y, and pname:z members of a slink:VkOffset3D
            parameter must: always be zero. ** The pname:width, pname:height, and
            pname:depth members of a slink:VkExtent3D parameter must: always match
            the width, height, and depth of the image subresource corresponding to
            the parameter, respectively.
            </para>
            <para>
            * [eq]#(A~x~, A~y~, A~z~)# where [eq]#A~x~#, [eq]#A~y~#, and [eq]#A~z~#
            are all integer powers of two. In this case the following restrictions
            apply to all image transfer operations:
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.QueueFlags.None">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.QueueFlags.Graphics">
            <summary>
            if ename:VK_QUEUE_GRAPHICS_BIT is set, then the queues in this
            queue family support graphics operations.
            </summary>
        </member>
        <member name="F:SharpVk.QueueFlags.Compute">
            <summary>
            if ename:VK_QUEUE_COMPUTE_BIT is set, then the queues in this queue
            family support compute operations.
            </summary>
        </member>
        <member name="F:SharpVk.QueueFlags.Transfer">
            <summary>
            if ename:VK_QUEUE_TRANSFER_BIT is set, then the queues in this
            queue family support transfer operations.
            </summary>
        </member>
        <member name="F:SharpVk.QueueFlags.SparseBinding">
            <summary>
            if ename:VK_QUEUE_SPARSE_BINDING_BIT is set, then the queues in
            this queue family support sparse memory management operations (see
            &lt;&lt;sparsememory,Sparse Resources&gt;&gt;). If any of the
            sparse resource features are enabled, then at least one queue
            family must: support this bit.
            </summary>
        </member>
        <member name="T:SharpVk.RasterizationOrder">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.RasterizationOrder.Strict">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.RasterizationOrder.Relaxed">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Rect2D">
            <summary>
            Structure specifying a two-dimensional subregion.
            </summary>
        </member>
        <member name="M:SharpVk.Rect2D.#ctor(SharpVk.Offset2D,SharpVk.Extent2D)">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Rect2D.Offset">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Rect2D.Extent">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Rect2D.ToString">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.RenderPass">
            <summary>
            <para>
            Opaque handle to a render pass object.
            </para>
            <para>
            A _render pass_ represents a collection of attachments, subpasses, and
            dependencies between the subpasses, and describes how the attachments
            are used over the course of the subpasses. The use of a render pass in
            a command buffer is a _render pass instance_.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.RenderPass.Destroy">
            <summary>
            Destroy a render pass object.
            </summary>
        </member>
        <member name="M:SharpVk.RenderPass.GetRenderAreaGranularity">
            <summary>
            Returns the granularity for optimal render area.
            </summary>
        </member>
        <member name="P:SharpVk.RenderPass.RawHandle">
            <summary>
            The interop handle for this RenderPass.
            </summary>
        </member>
        <member name="M:SharpVk.RenderPass.Dispose">
            <summary>
            Releases the unmanaged resources associated with this instance and
            destroys the underlying Vulkan handle.
            </summary>
        </member>
        <member name="T:SharpVk.RenderPassBeginInfo">
            <summary>
            <para>
            Structure specifying render pass begin info.
            </para>
            <para>
            pname:renderArea is the render area that is affected by the render pass
            instance. The effects of attachment load, store and multisample resolve
            operations are restricted to the pixels whose x and y coordinates fall
            within the render area on all attachments. The render area extends to
            all layers of pname:framebuffer. The application must: ensure (using
            scissor if necessary) that all rendering is contained within the render
            area, otherwise the pixels outside of the render area become undefined
            and shader side effects may: occur for fragments outside the render
            area. The render area must: be contained within the framebuffer
            dimensions.
            </para>
            <para>
            [NOTE] .Note ==== There may: be a performance cost for using a render
            area smaller than the framebuffer, unless it matches the render area
            granularity for the render pass. ====
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.RenderPassBeginInfo.RenderPass">
            <summary>
            pname:renderPass is the render pass to begin an instance of.
            </summary>
        </member>
        <member name="P:SharpVk.RenderPassBeginInfo.Framebuffer">
            <summary>
            pname:framebuffer is the framebuffer containing the attachments
            that are used with the render pass.
            </summary>
        </member>
        <member name="P:SharpVk.RenderPassBeginInfo.RenderArea">
            <summary>
            pname:renderArea is the render area that is affected by the render
            pass instance, and is described in more detail below.
            </summary>
        </member>
        <member name="P:SharpVk.RenderPassBeginInfo.ClearValues">
            <summary>
            pname:pClearValues is an array of slink:VkClearValue structures
            that contains clear values for each attachment, if the attachment
            uses a pname:loadOp value of ename:VK_ATTACHMENT_LOAD_OP_CLEAR or
            if the attachment has a depth/stencil format and uses a
            pname:stencilLoadOp value of ename:VK_ATTACHMENT_LOAD_OP_CLEAR. The
            array is indexed by attachment number. Only elements corresponding
            to cleared attachments are used. Other elements of
            pname:pClearValues are ignored.
            </summary>
        </member>
        <member name="T:SharpVk.RenderPassCreateFlags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.RenderPassCreateFlags.None">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.RenderPassCreateInfo">
            <summary>
            Structure specifying parameters of a newly created render pass.
            </summary>
        </member>
        <member name="P:SharpVk.RenderPassCreateInfo.Flags">
            <summary>
            pname:flags is reserved for future use.
            </summary>
        </member>
        <member name="P:SharpVk.RenderPassCreateInfo.Attachments">
            <summary>
            pname:pAttachments points to an array of pname:attachmentCount
            number of slink:VkAttachmentDescription structures describing
            properties of the attachments, or `NULL` if pname:attachmentCount
            is zero.
            </summary>
        </member>
        <member name="P:SharpVk.RenderPassCreateInfo.Subpasses">
            <summary>
            pname:pSubpasses points to an array of pname:subpassCount number of
            slink:VkSubpassDescription structures describing properties of the
            subpasses.
            </summary>
        </member>
        <member name="P:SharpVk.RenderPassCreateInfo.Dependencies">
            <summary>
            pname:pDependencies points to an array of pname:dependencyCount
            number of slink:VkSubpassDependency structures describing
            dependencies between pairs of subpasses, or `NULL` if
            pname:dependencyCount is zero.
            </summary>
        </member>
        <member name="T:SharpVk.Result">
            <summary>
            <para>
            Vulkan command return codes.
            </para>
            <para>
            While the core Vulkan API is not designed to capture incorrect usage,
            some circumstances still require return codes. Commands in Vulkan
            return their status via return codes that are in one of two categories:
            </para>
            <para>
            * Successful completion codes are returned when a command needs to
            communicate success or status information. All successful completion
            codes are non-negative values. * Run time error codes are returned when
            a command needs to communicate a failure that could only be detected at
            run time. All run time error codes are negative values.
            </para>
            <para>
            .Success Codes * ename:VK_SUCCESS Command successfully completed *
            ename:VK_NOT_READY A fence or query has not yet completed *
            ename:VK_TIMEOUT A wait operation has not completed in the specified
            time * ename:VK_EVENT_SET An event is signaled * ename:VK_EVENT_RESET
            An event is unsignaled * ename:VK_INCOMPLETE A return array was too
            small for the result ifdef::VK_KHR_swapchain[] *
            ename:VK_SUBOPTIMAL_KHR A swapchain no longer matches the surface
            properties exactly, but can: still be used to present to the surface
            successfully. endif::VK_KHR_swapchain[]
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.Result.Success">
            <summary>
            Command completed successfully
            </summary>
        </member>
        <member name="F:SharpVk.Result.NotReady">
            <summary>
            A fence or query has not yet completed
            </summary>
        </member>
        <member name="F:SharpVk.Result.Timeout">
            <summary>
            A wait operation has not completed in the specified time
            </summary>
        </member>
        <member name="F:SharpVk.Result.EventSet">
            <summary>
            An event is signaled
            </summary>
        </member>
        <member name="F:SharpVk.Result.EventReset">
            <summary>
            An event is unsignaled
            </summary>
        </member>
        <member name="F:SharpVk.Result.Incomplete">
            <summary>
            A return array was too small for the result
            </summary>
        </member>
        <member name="F:SharpVk.Result.ErrorOutOfHostMemory">
            <summary>
            A host memory allocation has failed
            </summary>
        </member>
        <member name="F:SharpVk.Result.ErrorOutOfDeviceMemory">
            <summary>
            A device memory allocation has failed
            </summary>
        </member>
        <member name="F:SharpVk.Result.ErrorInitializationFailed">
            <summary>
            Initialization of a object has failed
            </summary>
        </member>
        <member name="F:SharpVk.Result.ErrorDeviceLost">
            <summary>
            The logical device has been lost. See
            &lt;&lt;devsandqueues-lost-device&gt;&gt;
            </summary>
        </member>
        <member name="F:SharpVk.Result.ErrorMemoryMapFailed">
            <summary>
            Mapping of a memory object has failed
            </summary>
        </member>
        <member name="F:SharpVk.Result.ErrorLayerNotPresent">
            <summary>
            Layer specified does not exist
            </summary>
        </member>
        <member name="F:SharpVk.Result.ErrorExtensionNotPresent">
            <summary>
            Extension specified does not exist
            </summary>
        </member>
        <member name="F:SharpVk.Result.ErrorFeatureNotPresent">
            <summary>
            Requested feature is not available on this device
            </summary>
        </member>
        <member name="F:SharpVk.Result.ErrorIncompatibleDriver">
            <summary>
            Unable to find a Vulkan driver
            </summary>
        </member>
        <member name="F:SharpVk.Result.ErrorTooManyObjects">
            <summary>
            Too many objects of the type have already been created
            </summary>
        </member>
        <member name="F:SharpVk.Result.ErrorFormatNotSupported">
            <summary>
            Requested format is not supported on this device
            </summary>
        </member>
        <member name="F:SharpVk.Result.ErrorFragmentedPool">
            <summary>
            A requested pool allocation has failed due to fragmentation of the
            pool's memory
            </summary>
        </member>
        <member name="F:SharpVk.Result.ErrorSurfaceLost">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Result.ErrorNativeWindowInUse">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Result.Suboptimal">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Result.ErrorOutOfDate">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Result.ErrorIncompatibleDisplay">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Result.ErrorValidationFailed">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Result.ErrorInvalidShader">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Result.ErrorOutOfPoolMemory">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.SampleCountFlags">
            <summary>
            Bitmask specifying sample counts supported for an image used for
            storage operations.
            </summary>
        </member>
        <member name="F:SharpVk.SampleCountFlags.None">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.SampleCountFlags.SampleCount1">
            <summary>
            Sample count 1 supported
            </summary>
        </member>
        <member name="F:SharpVk.SampleCountFlags.SampleCount2">
            <summary>
            Sample count 2 supported
            </summary>
        </member>
        <member name="F:SharpVk.SampleCountFlags.SampleCount4">
            <summary>
            Sample count 4 supported
            </summary>
        </member>
        <member name="F:SharpVk.SampleCountFlags.SampleCount8">
            <summary>
            Sample count 8 supported
            </summary>
        </member>
        <member name="F:SharpVk.SampleCountFlags.SampleCount16">
            <summary>
            Sample count 16 supported
            </summary>
        </member>
        <member name="F:SharpVk.SampleCountFlags.SampleCount32">
            <summary>
            Sample count 32 supported
            </summary>
        </member>
        <member name="F:SharpVk.SampleCountFlags.SampleCount64">
            <summary>
            Sample count 64 supported
            </summary>
        </member>
        <member name="T:SharpVk.Sampler">
            <summary>
            <para>
            Opaque handle to a sampler object.
            </para>
            <para>
            sname:VkSampler objects represent the state of an image sampler which
            is used by the implementation to read image data and apply filtering
            and other transformations for the shader.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Sampler.Destroy">
            <summary>
            Destroy a sampler object.
            </summary>
        </member>
        <member name="P:SharpVk.Sampler.RawHandle">
            <summary>
            The interop handle for this Sampler.
            </summary>
        </member>
        <member name="M:SharpVk.Sampler.Dispose">
            <summary>
            Releases the unmanaged resources associated with this instance and
            destroys the underlying Vulkan handle.
            </summary>
        </member>
        <member name="T:SharpVk.SamplerAddressMode">
            <summary>
            <para>
            Specify behavior of sampling with texture coordinates outside an image.
            </para>
            <para>
            The maximum number of sampler objects which can: be simultaneously
            created on a device is implementation-dependent and specified by the
            &lt;&lt;features-limits-maxSamplerAllocationCount,pname:maxSamplerAllocationCount&gt;&gt; member
            of the sname:VkPhysicalDeviceLimits structure. If
            pname:maxSamplerAllocationCount is exceeded, fname:vkCreateSampler will
            return ename:VK_ERROR_TOO_MANY_OBJECTS.
            </para>
            <para>
            Since sname:VkSampler is a non-dispatchable handle type,
            implementations may: return the same handle for sampler state vectors
            that are identical. In such cases, all such objects would only count
            once against the pname:maxSamplerAllocationCount limit.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SamplerAddressMode.Repeat">
            <summary>
            ename:VK_SAMPLER_ADDRESS_MODE_REPEAT indicates that the repeat wrap
            mode will be used.
            </summary>
        </member>
        <member name="F:SharpVk.SamplerAddressMode.MirroredRepeat">
            <summary>
            ename:VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT indicates that the
            mirrored repeat wrap mode will be used.
            </summary>
        </member>
        <member name="F:SharpVk.SamplerAddressMode.ClampToEdge">
            <summary>
            ename:VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE indicates that the
            clamp to edge wrap mode will be used.
            </summary>
        </member>
        <member name="F:SharpVk.SamplerAddressMode.ClampToBorder">
            <summary>
            ename:VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER indicates that the
            clamp to border wrap mode will be used.
            </summary>
        </member>
        <member name="F:SharpVk.SamplerAddressMode.MirrorClampToEdge">
            <summary>
            ename:VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE indicates that
            the mirror clamp to edge wrap mode will be used. This is only valid
            if the +VK_KHR_mirror_clamp_to_edge+ extension is enabled.
            </summary>
        </member>
        <member name="T:SharpVk.SamplerCreateFlags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.SamplerCreateFlags.None">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.SamplerCreateInfo">
            <summary>
            Structure specifying parameters of a newly created sampler.
            </summary>
        </member>
        <member name="P:SharpVk.SamplerCreateInfo.Flags">
            <summary>
            pname:flags is reserved for future use.
            </summary>
        </member>
        <member name="P:SharpVk.SamplerCreateInfo.MagFilter">
            <summary>
            pname:magFilter is the magnification filter to apply to lookups,
            and is of type: + --
            </summary>
        </member>
        <member name="P:SharpVk.SamplerCreateInfo.MinFilter">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.SamplerCreateInfo.MipmapMode">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.SamplerCreateInfo.AddressModeU">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.SamplerCreateInfo.AddressModeV">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.SamplerCreateInfo.AddressModeW">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.SamplerCreateInfo.MipLodBias">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.SamplerCreateInfo.AnisotropyEnable">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.SamplerCreateInfo.MaxAnisotropy">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.SamplerCreateInfo.CompareEnable">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.SamplerCreateInfo.CompareOp">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.SamplerCreateInfo.MinLod">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.SamplerCreateInfo.MaxLod">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.SamplerCreateInfo.BorderColor">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.SamplerCreateInfo.UnnormalizedCoordinates">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.SamplerMipmapMode">
            <summary>
            Specify mipmap mode used for texture lookups.
            </summary>
        </member>
        <member name="F:SharpVk.SamplerMipmapMode.Nearest">
            <summary>
            Choose nearest mip level
            </summary>
        </member>
        <member name="F:SharpVk.SamplerMipmapMode.Linear">
            <summary>
            Linear filter between mip levels
            </summary>
        </member>
        <member name="T:SharpVk.Semaphore">
            <summary>
            <para>
            Opaque handle to a semaphore object.
            </para>
            <para>
            Semaphores are a synchronization primitive that can: be used to insert
            a dependency between batches submitted to queues. Semaphores have two
            states - signaled and unsignaled. The state of a semaphore can: be
            signaled after execution of a batch of commands is completed. A batch
            can: wait for a semaphore to become signaled before it begins
            execution, and the semaphore is also unsignaled before the batch begins
            execution.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Semaphore.Destroy">
            <summary>
            Destroy a semaphore object.
            </summary>
        </member>
        <member name="P:SharpVk.Semaphore.RawHandle">
            <summary>
            The interop handle for this Semaphore.
            </summary>
        </member>
        <member name="M:SharpVk.Semaphore.Dispose">
            <summary>
            Releases the unmanaged resources associated with this instance and
            destroys the underlying Vulkan handle.
            </summary>
        </member>
        <member name="T:SharpVk.SemaphoreCreateFlags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.SemaphoreCreateFlags.None">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.SemaphoreCreateInfo">
            <summary>
            Structure specifying parameters of a newly created semaphore.
            </summary>
        </member>
        <member name="P:SharpVk.SemaphoreCreateInfo.Flags">
            <summary>
            pname:flags is reserved for future use.
            </summary>
        </member>
        <member name="T:SharpVk.ShaderModule">
            <summary>
            <para>
            Opaque handle to a shader module object.
            </para>
            <para>
            _Shader modules_ contain _shader code_ and one or more entry points.
            Shaders are selected from a shader module by specifying an entry point
            as part of &lt;&lt;pipelines,pipeline&gt;&gt; creation. The stages of a
            pipeline can: use shaders that come from different modules. The shader
            code defining a shader module must: be in the SPIR-V format, as
            described by the &lt;&lt;spirvenv,Vulkan Environment for SPIR-V&gt;&gt;
            appendix.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.ShaderModule.Destroy">
            <summary>
            Destroy a shader module module.
            </summary>
        </member>
        <member name="P:SharpVk.ShaderModule.RawHandle">
            <summary>
            The interop handle for this ShaderModule.
            </summary>
        </member>
        <member name="M:SharpVk.ShaderModule.Dispose">
            <summary>
            Releases the unmanaged resources associated with this instance and
            destroys the underlying Vulkan handle.
            </summary>
        </member>
        <member name="T:SharpVk.ShaderModuleCreateFlags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.ShaderModuleCreateFlags.None">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.ShaderModuleCreateInfo">
            <summary>
            Structure specifying parameters of a newly created shader module.
            </summary>
        </member>
        <member name="P:SharpVk.ShaderModuleCreateInfo.Flags">
            <summary>
            pname:flags is reserved for future use.
            </summary>
        </member>
        <member name="P:SharpVk.ShaderModuleCreateInfo.CodeSize">
            <summary>
            pname:codeSize is the size, in bytes, of the code pointed to by
            pname:pCode.
            </summary>
        </member>
        <member name="P:SharpVk.ShaderModuleCreateInfo.Code">
            <summary>
            pname:pCode points to code that is used to create the shader
            module. The type and format of the code is determined from the
            content of the memory addressed by pname:pCode.
            </summary>
        </member>
        <member name="T:SharpVk.ShaderStageFlags">
            <summary>
            Bitmask specifying a pipeline stage.
            </summary>
        </member>
        <member name="F:SharpVk.ShaderStageFlags.None">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.ShaderStageFlags.Vertex">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.ShaderStageFlags.TessellationControl">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.ShaderStageFlags.TessellationEvaluation">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.ShaderStageFlags.Geometry">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.ShaderStageFlags.Fragment">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.ShaderStageFlags.Compute">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.ShaderStageFlags.AllGraphics">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.ShaderStageFlags.All">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.SharingMode">
            <summary>
            <para>
            Buffer and image sharing modes.
            </para>
            <para>
            [NOTE] .Note ==== ename:VK_SHARING_MODE_CONCURRENT may: result in lower
            performance access to the buffer or image than
            ename:VK_SHARING_MODE_EXCLUSIVE. ====
            </para>
            <para>
            Ranges of buffers and image subresources of image objects created using
            ename:VK_SHARING_MODE_EXCLUSIVE must: only be accessed by queues in the
            same queue family at any given time. In order for a different queue
            family to be able to interpret the memory contents of a range or image
            subresource, the application must: perform a
            &lt;&lt;synchronization-queue-transfers,queue family ownership
            transfer&gt;&gt;.
            </para>
            <para>
            Upon creation, resources using ename:VK_SHARING_MODE_EXCLUSIVE are not
            owned by any queue family. A buffer or image memory barrier is not
            required to acquire _ownership_ when no queue family owns the resource
            - it is implicitly acquired upon first use within a queue.
            </para>
            <para>
            .Note [NOTE] ==== Images still require a
            &lt;&lt;resources-image-layouts, layout transition&gt;&gt; from
            ename:VK_IMAGE_LAYOUT_UNDEFINED or ename:VK_IMAGE_LAYOUT_PREINITIALIZED
            before being used on the first queue. ====
            </para>
            <para>
            A queue family can: take ownership of an image subresource or buffer
            range of a resource created with ename:VK_SHARING_MODE_EXCLUSIVE,
            without an ownership transfer, in the same way as for a resource that
            was just created; however, taking ownership in this way has the effect
            that the contents of the image subresource or buffer range are
            undefined.
            </para>
            <para>
            Ranges of buffers and image subresources of image objects created using
            ename:VK_SHARING_MODE_CONCURRENT must: only be accessed by queues from
            the queue families specified through the pname:queueFamilyIndexCount
            and pname:pQueueFamilyIndices members of the corresponding create info
            structures.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SharingMode.Exclusive">
            <summary>
            ename:VK_SHARING_MODE_EXCLUSIVE specifies that access to any range
            or image subresource of the object will be exclusive to a single
            queue family at a time.
            </summary>
        </member>
        <member name="F:SharpVk.SharingMode.Concurrent">
            <summary>
            ename:VK_SHARING_MODE_CONCURRENT specifies that concurrent access
            to any range or image subresource of the object from multiple queue
            families is supported.
            </summary>
        </member>
        <member name="T:SharpVk.SparseBufferMemoryBindInfo">
            <summary>
            Structure specifying a sparse buffer memory bind operation.
            </summary>
        </member>
        <member name="P:SharpVk.SparseBufferMemoryBindInfo.Buffer">
            <summary>
            pname:buffer is the sname:VkBuffer object to be bound.
            </summary>
        </member>
        <member name="P:SharpVk.SparseBufferMemoryBindInfo.Binds">
            <summary>
            pname:pBinds is a pointer to array of sname:VkSparseMemoryBind
            structures.
            </summary>
        </member>
        <member name="T:SharpVk.SparseImageFormatFlags">
            <summary>
            Bitmask specifying additional information about a sparse image
            resource.
            </summary>
        </member>
        <member name="F:SharpVk.SparseImageFormatFlags.None">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.SparseImageFormatFlags.SingleMiptail">
            <summary>
            Image uses a single mip tail region for all array layers
            </summary>
        </member>
        <member name="F:SharpVk.SparseImageFormatFlags.AlignedMipSize">
            <summary>
            Image requires mip level dimensions to be an integer multiple of
            the sparse image block dimensions for non-tail mip levels.
            </summary>
        </member>
        <member name="F:SharpVk.SparseImageFormatFlags.NonstandardBlockSize">
            <summary>
            Image uses a non-standard sparse image block dimensions
            </summary>
        </member>
        <member name="T:SharpVk.SparseImageFormatProperties">
            <summary>
            Structure specifying sparse image format properties.
            </summary>
        </member>
        <member name="M:SharpVk.SparseImageFormatProperties.#ctor(SharpVk.ImageAspectFlags,SharpVk.Extent3D,SharpVk.SparseImageFormatFlags)">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.SparseImageFormatProperties.AspectMask">
            <summary>
            pname:aspectMask is a bitmask of elink:VkImageAspectFlagBits
            specifying which aspects of the image the properties apply to.
            </summary>
        </member>
        <member name="F:SharpVk.SparseImageFormatProperties.ImageGranularity">
            <summary>
            pname:imageGranularity is the width, height, and depth of the
            sparse image block in texels or compressed texel blocks.
            </summary>
        </member>
        <member name="F:SharpVk.SparseImageFormatProperties.Flags">
            <summary>
            pname:flags is a bitmask specifying additional information about
            the sparse resource. Bits which can: be set include: + --
            </summary>
        </member>
        <member name="M:SharpVk.SparseImageFormatProperties.ToString">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.SparseImageFormatProperties2">
            <summary>
            Structure specifying sparse image format properties.
            </summary>
        </member>
        <member name="P:SharpVk.SparseImageFormatProperties2.Properties">
            <summary>
            pname:properties is a structure of type
            slink:VkSparseImageFormatProperties which is populated with the
            same values as in
            flink:vkGetPhysicalDeviceSparseImageFormatProperties.
            </summary>
        </member>
        <member name="T:SharpVk.SparseImageMemoryBind">
            <summary>
            Structure specifying sparse image memory bind.
            </summary>
        </member>
        <member name="P:SharpVk.SparseImageMemoryBind.Subresource">
            <summary>
            pname:subresource is the aspectMask and region of interest in the
            image.
            </summary>
        </member>
        <member name="P:SharpVk.SparseImageMemoryBind.Offset">
            <summary>
            pname:offset are the coordinates of the first texel within the
            image subresource to bind.
            </summary>
        </member>
        <member name="P:SharpVk.SparseImageMemoryBind.Extent">
            <summary>
            pname:extent is the size in texels of the region within the image
            subresource to bind. The extent must: be a multiple of the sparse
            image block dimensions, except when binding sparse image blocks
            along the edge of an image subresource it can: instead be such that
            any coordinate of [eq]#pname:offset + pname:extent# equals the
            corresponding dimensions of the image subresource.
            </summary>
        </member>
        <member name="P:SharpVk.SparseImageMemoryBind.Memory">
            <summary>
            pname:memory is the sname:VkDeviceMemory object that the sparse
            image blocks of the image are bound to. If pname:memory is
            dlink:VK_NULL_HANDLE, the sparse image blocks are unbound.
            </summary>
        </member>
        <member name="P:SharpVk.SparseImageMemoryBind.MemoryOffset">
            <summary>
            pname:memoryOffset is an offset into sname:VkDeviceMemory object.
            If pname:memory is dlink:VK_NULL_HANDLE, this value is ignored.
            </summary>
        </member>
        <member name="P:SharpVk.SparseImageMemoryBind.Flags">
            <summary>
            pname:flags are sparse memory binding flags.
            </summary>
        </member>
        <member name="T:SharpVk.SparseImageMemoryBindInfo">
            <summary>
            Structure specifying sparse image memory bind info.
            </summary>
        </member>
        <member name="P:SharpVk.SparseImageMemoryBindInfo.Image">
            <summary>
            pname:image is the sname:VkImage object to be bound
            </summary>
        </member>
        <member name="P:SharpVk.SparseImageMemoryBindInfo.Binds">
            <summary>
            pname:pBinds is a pointer to array of sname:VkSparseImageMemoryBind
            structures
            </summary>
        </member>
        <member name="T:SharpVk.SparseImageMemoryRequirements">
            <summary>
            Structure specifying sparse image memory requirements.
            </summary>
        </member>
        <member name="M:SharpVk.SparseImageMemoryRequirements.#ctor(SharpVk.SparseImageFormatProperties,System.UInt32,SharpVk.DeviceSize,SharpVk.DeviceSize,SharpVk.DeviceSize)">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.SparseImageMemoryRequirements.FormatProperties">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.SparseImageMemoryRequirements.ImageMipTailFirstLod">
            <summary>
            pname:imageMipTailFirstLod is the first mip level at which image
            subresources are included in the mip tail region.
            </summary>
        </member>
        <member name="F:SharpVk.SparseImageMemoryRequirements.ImageMipTailSize">
            <summary>
            pname:imageMipTailSize is the memory size (in bytes) of the mip
            tail region. If pname:formatProperties.flags contains
            ename:VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT, this is the size
            of the whole mip tail, otherwise this is the size of the mip tail
            of a single array layer. This value is guaranteed to be a multiple
            of the sparse block size in bytes.
            </summary>
        </member>
        <member name="F:SharpVk.SparseImageMemoryRequirements.ImageMipTailOffset">
            <summary>
            pname:imageMipTailOffset is the opaque memory offset used with
            slink:VkSparseImageOpaqueMemoryBindInfo to bind the mip tail
            region(s).
            </summary>
        </member>
        <member name="F:SharpVk.SparseImageMemoryRequirements.ImageMipTailStride">
            <summary>
            pname:imageMipTailStride is the offset stride between each
            array-layer's mip tail, if pname:formatProperties.flags does not
            contain ename:VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT (otherwise
            the value is undefined).
            </summary>
        </member>
        <member name="M:SharpVk.SparseImageMemoryRequirements.ToString">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.SparseImageOpaqueMemoryBindInfo">
            <summary>
            Structure specifying sparse image opaque memory bind info.
            </summary>
        </member>
        <member name="P:SharpVk.SparseImageOpaqueMemoryBindInfo.Image">
            <summary>
            pname:image is the sname:VkImage object to be bound.
            </summary>
        </member>
        <member name="P:SharpVk.SparseImageOpaqueMemoryBindInfo.Binds">
            <summary>
            pname:pBinds is a pointer to array of sname:VkSparseMemoryBind
            structures.
            </summary>
        </member>
        <member name="T:SharpVk.SparseMemoryBind">
            <summary>
            Structure specifying a sparse memory bind operation.
            </summary>
        </member>
        <member name="P:SharpVk.SparseMemoryBind.ResourceOffset">
            <summary>
            pname:resourceOffset is the offset into the resource.
            </summary>
        </member>
        <member name="P:SharpVk.SparseMemoryBind.Size">
            <summary>
            pname:size is the size of the memory region to be bound.
            </summary>
        </member>
        <member name="P:SharpVk.SparseMemoryBind.Memory">
            <summary>
            pname:memory is the sname:VkDeviceMemory object that the range of
            the resource is bound to. If pname:memory is dlink:VK_NULL_HANDLE,
            the range is unbound.
            </summary>
        </member>
        <member name="P:SharpVk.SparseMemoryBind.MemoryOffset">
            <summary>
            pname:memoryOffset is the offset into the sname:VkDeviceMemory
            object to bind the resource range to. If pname:memory is
            dlink:VK_NULL_HANDLE, this value is ignored.
            </summary>
        </member>
        <member name="P:SharpVk.SparseMemoryBind.Flags">
            <summary>
            pname:flags is a bitmask specifying usage of the binding operation.
            Bits which can: be set include: + --
            </summary>
        </member>
        <member name="T:SharpVk.SparseMemoryBindFlags">
            <summary>
            <para>
            Bitmask specifying usage of a sparse memory binding operation.
            </para>
            <para>
            The _binding range_ [eq]#[pname:resourceOffset, pname:resourceOffset
            {plus} pname:size)# has different constraints based on pname:flags. If
            pname:flags contains ename:VK_SPARSE_MEMORY_BIND_METADATA_BIT, the
            binding range must: be within the mip tail region of the metadata
            aspect. This metadata region is defined by:
            </para>
            <para>
            :: [eq]#metadataRegion = [base, base + pname:imageMipTailSize)# ::
            [eq]#base = pname:imageMipTailOffset + pname:imageMipTailStride {times}
            n#
            </para>
            <para>
            and pname:imageMipTailOffset, pname:imageMipTailSize, and
            pname:imageMipTailStride values are from the
            slink:VkSparseImageMemoryRequirements corresponding to the metadata
            aspect of the image, and [eq]#n# is a valid array layer index for the
            image,
            </para>
            <para>
            pname:imageMipTailStride is considered to be zero for aspects where
            sname:VkSparseImageMemoryRequirements::pname:formatProperties.flags contains
            ename:VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT.
            </para>
            <para>
            If pname:flags does not contain
            ename:VK_SPARSE_MEMORY_BIND_METADATA_BIT, the binding range must: be
            within the range [eq]#[0,slink:VkMemoryRequirements::pname:size)#.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SparseMemoryBindFlags.None">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.SparseMemoryBindFlags.Metadata">
            <summary>
            Operation binds resource metadata to memory
            </summary>
        </member>
        <member name="T:SharpVk.SpecializationInfo">
            <summary>
            <para>
            Structure specifying specialization info.
            </para>
            <para>
            pname:pMapEntries points to a structure of type
            slink:VkSpecializationMapEntry.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.SpecializationInfo.MapEntries">
            <summary>
            pname:pMapEntries is a pointer to an array of
            sname:VkSpecializationMapEntry which maps constant IDs to offsets
            in pname:pData.
            </summary>
        </member>
        <member name="P:SharpVk.SpecializationInfo.Data">
            <summary>
            pname:pData contains the actual constant values to specialize with.
            </summary>
        </member>
        <member name="T:SharpVk.SpecializationMapEntry">
            <summary>
            <para>
            Structure specifying a specialization map entry.
            </para>
            <para>
            If a pname:constantID value is not a specialization constant ID used in
            the shader, that map entry does not affect the behavior of the
            pipeline.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.SpecializationMapEntry.#ctor(System.UInt32,System.UInt32,SharpVk.Size)">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.SpecializationMapEntry.ConstantID">
            <summary>
            pname:constantID is the ID of the specialization constant in
            SPIR-V.
            </summary>
        </member>
        <member name="F:SharpVk.SpecializationMapEntry.Offset">
            <summary>
            pname:offset is the byte offset of the specialization constant
            value within the supplied data buffer.
            </summary>
        </member>
        <member name="F:SharpVk.SpecializationMapEntry.Size">
            <summary>
            pname:size is the byte size of the specialization constant value
            within the supplied data buffer.
            </summary>
        </member>
        <member name="M:SharpVk.SpecializationMapEntry.ToString">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Spirv.SourceLanguage">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.SourceLanguage.Unknown">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.SourceLanguage.ESSL">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.SourceLanguage.GLSL">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.SourceLanguage.OpenCL_C">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.SourceLanguage.OpenCL_CPP">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Spirv.ExecutionModel">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionModel.Vertex">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionModel.TessellationControl">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionModel.TessellationEvaluation">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionModel.Geometry">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionModel.Fragment">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionModel.GLCompute">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionModel.Kernel">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Spirv.AddressingModel">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.AddressingModel.Logical">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.AddressingModel.Physical32">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.AddressingModel.Physical64">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Spirv.MemoryModel">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.MemoryModel.Simple">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.MemoryModel.GLSL450">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.MemoryModel.OpenCL">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Spirv.ExecutionMode">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionMode.Invocations">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionMode.SpacingEqual">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionMode.SpacingFractionalEven">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionMode.SpacingFractionalOdd">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionMode.VertexOrderCw">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionMode.VertexOrderCcw">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionMode.PixelCenterInteger">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionMode.OriginUpperLeft">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionMode.OriginLowerLeft">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionMode.EarlyFragmentTests">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionMode.PointMode">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionMode.Xfb">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionMode.DepthReplacing">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionMode.DepthGreater">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionMode.DepthLess">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionMode.DepthUnchanged">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionMode.LocalSize">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionMode.LocalSizeHint">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionMode.InputPoints">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionMode.InputLines">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionMode.InputLinesAdjacency">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionMode.Triangles">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionMode.InputTrianglesAdjacency">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionMode.Quads">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionMode.Isolines">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionMode.OutputVertices">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionMode.OutputPoints">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionMode.OutputLineStrip">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionMode.OutputTriangleStrip">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionMode.VecTypeHint">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionMode.ContractionOff">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionMode.Initializer">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionMode.Finalizer">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionMode.SubgroupSize">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ExecutionMode.SubgroupsPerWorkgroup">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Spirv.StorageClass">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.StorageClass.UniformConstant">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.StorageClass.Input">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.StorageClass.Uniform">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.StorageClass.Output">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.StorageClass.Workgroup">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.StorageClass.CrossWorkgroup">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.StorageClass.Private">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.StorageClass.Function">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.StorageClass.Generic">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.StorageClass.PushConstant">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.StorageClass.AtomicCounter">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.StorageClass.Image">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Spirv.Dim">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Dim.Dim1D">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Dim.Dim2D">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Dim.Dim3D">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Dim.Cube">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Dim.Rect">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Dim.Buffer">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Dim.SubpassData">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Spirv.SamplerAddressingMode">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.SamplerAddressingMode.None">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.SamplerAddressingMode.ClampToEdge">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.SamplerAddressingMode.Clamp">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.SamplerAddressingMode.Repeat">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.SamplerAddressingMode.RepeatMirrored">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Spirv.SamplerFilterMode">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.SamplerFilterMode.Nearest">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.SamplerFilterMode.Linear">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Spirv.ImageFormat">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.Unknown">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.Rgba32f">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.Rgba16f">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.R32f">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.Rgba8">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.Rgba8Snorm">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.Rg32f">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.Rg16f">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.R11fG11fB10f">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.R16f">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.Rgba16">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.Rgb10A2">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.Rg16">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.Rg8">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.R16">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.R8">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.Rgba16Snorm">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.Rg16Snorm">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.Rg8Snorm">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.R16Snorm">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.R8Snorm">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.Rgba32i">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.Rgba16i">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.Rgba8i">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.R32i">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.Rg32i">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.Rg16i">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.Rg8i">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.R16i">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.R8i">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.Rgba32ui">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.Rgba16ui">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.Rgba8ui">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.R32ui">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.Rgb10a2ui">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.Rg32ui">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.Rg16ui">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.Rg8ui">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.R16ui">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageFormat.R8ui">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Spirv.ImageChannelOrder">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageChannelOrder.R">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageChannelOrder.A">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageChannelOrder.RG">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageChannelOrder.RA">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageChannelOrder.RGB">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageChannelOrder.RGBA">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageChannelOrder.BGRA">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageChannelOrder.ARGB">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageChannelOrder.Intensity">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageChannelOrder.Luminance">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageChannelOrder.Rx">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageChannelOrder.RGx">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageChannelOrder.RGBx">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageChannelOrder.Depth">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageChannelOrder.DepthStencil">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageChannelOrder.sRGB">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageChannelOrder.sRGBx">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageChannelOrder.sRGBA">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageChannelOrder.sBGRA">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageChannelOrder.ABGR">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Spirv.ImageChannelDataType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageChannelDataType.SnormInt8">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageChannelDataType.SnormInt16">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageChannelDataType.UnormInt8">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageChannelDataType.UnormInt16">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageChannelDataType.UnormShort565">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageChannelDataType.UnormShort555">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageChannelDataType.UnormInt101010">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageChannelDataType.SignedInt8">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageChannelDataType.SignedInt16">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageChannelDataType.SignedInt32">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageChannelDataType.UnsignedInt8">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageChannelDataType.UnsignedInt16">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageChannelDataType.UnsignedInt32">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageChannelDataType.HalfFloat">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageChannelDataType.Float">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageChannelDataType.UnormInt24">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageChannelDataType.UnormInt101010_2">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Spirv.ImageOperands">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageOperands.None">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageOperands.Bias">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageOperands.Lod">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageOperands.Grad">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageOperands.ConstOffset">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageOperands.Offset">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageOperands.ConstOffsets">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageOperands.Sample">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.ImageOperands.MinLod">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Spirv.FPFastMathMode">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.FPFastMathMode.None">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.FPFastMathMode.NotNaN">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.FPFastMathMode.NotInf">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.FPFastMathMode.NSZ">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.FPFastMathMode.AllowRecip">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.FPFastMathMode.Fast">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Spirv.FPRoundingMode">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.FPRoundingMode.RTE">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.FPRoundingMode.RTZ">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.FPRoundingMode.RTP">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.FPRoundingMode.RTN">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Spirv.LinkageType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.LinkageType.Export">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.LinkageType.Import">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Spirv.AccessQualifier">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.AccessQualifier.ReadOnly">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.AccessQualifier.WriteOnly">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.AccessQualifier.ReadWrite">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Spirv.FunctionParameterAttribute">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.FunctionParameterAttribute.Zext">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.FunctionParameterAttribute.Sext">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.FunctionParameterAttribute.ByVal">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.FunctionParameterAttribute.Sret">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.FunctionParameterAttribute.NoAlias">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.FunctionParameterAttribute.NoCapture">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.FunctionParameterAttribute.NoWrite">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.FunctionParameterAttribute.NoReadWrite">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Spirv.Decoration">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.RelaxedPrecision">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.SpecId">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.Block">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.BufferBlock">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.RowMajor">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.ColMajor">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.ArrayStride">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.MatrixStride">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.GLSLShared">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.GLSLPacked">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.CPacked">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.BuiltIn">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.NoPerspective">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.Flat">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.Patch">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.Centroid">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.Sample">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.Invariant">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.Restrict">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.Aliased">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.Volatile">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.Constant">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.Coherent">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.NonWritable">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.NonReadable">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.Uniform">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.SaturatedConversion">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.Stream">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.Location">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.Component">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.Index">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.Binding">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.DescriptorSet">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.Offset">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.XfbBuffer">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.XfbStride">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.FuncParamAttr">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.FPRoundingMode">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.FPFastMathMode">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.LinkageAttributes">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.NoContraction">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.InputAttachmentIndex">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.Alignment">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Decoration.MaxByteOffset">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Spirv.BuiltIn">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.Position">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.PointSize">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.ClipDistance">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.CullDistance">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.VertexId">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.InstanceId">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.PrimitiveId">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.InvocationId">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.Layer">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.ViewportIndex">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.TessLevelOuter">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.TessLevelInner">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.TessCoord">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.PatchVertices">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.FragCoord">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.PointCoord">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.FrontFacing">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.SampleId">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.SamplePosition">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.SampleMask">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.FragDepth">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.HelperInvocation">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.NumWorkgroups">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.WorkgroupSize">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.WorkgroupId">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.LocalInvocationId">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.GlobalInvocationId">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.LocalInvocationIndex">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.WorkDim">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.GlobalSize">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.EnqueuedWorkgroupSize">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.GlobalOffset">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.GlobalLinearId">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.SubgroupSize">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.SubgroupMaxSize">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.NumSubgroups">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.NumEnqueuedSubgroups">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.SubgroupId">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.SubgroupLocalInvocationId">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.VertexIndex">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.InstanceIndex">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.SubgroupEqMaskKHR">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.SubgroupGeMaskKHR">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.SubgroupGtMaskKHR">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.SubgroupLeMaskKHR">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.SubgroupLtMaskKHR">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.BaseVertex">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.BaseInstance">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.BuiltIn.DrawIndex">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Spirv.SelectionControl">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.SelectionControl.None">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.SelectionControl.Flatten">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.SelectionControl.DontFlatten">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Spirv.LoopControl">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.LoopControl.None">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.LoopControl.Unroll">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.LoopControl.DontUnroll">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.LoopControl.DependencyInfinite">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.LoopControl.DependencyLength">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Spirv.FunctionControl">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.FunctionControl.None">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.FunctionControl.Inline">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.FunctionControl.DontInline">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.FunctionControl.Pure">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.FunctionControl.Const">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Spirv.MemorySemantics">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.MemorySemantics.None">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.MemorySemantics.Acquire">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.MemorySemantics.Release">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.MemorySemantics.AcquireRelease">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.MemorySemantics.SequentiallyConsistent">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.MemorySemantics.UniformMemory">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.MemorySemantics.SubgroupMemory">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.MemorySemantics.WorkgroupMemory">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.MemorySemantics.CrossWorkgroupMemory">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.MemorySemantics.AtomicCounterMemory">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.MemorySemantics.ImageMemory">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Spirv.MemoryAccess">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.MemoryAccess.None">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.MemoryAccess.Volatile">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.MemoryAccess.Aligned">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.MemoryAccess.Nontemporal">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Spirv.Scope">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Scope.CrossDevice">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Scope.Device">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Scope.Workgroup">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Scope.Subgroup">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Scope.Invocation">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Spirv.GroupOperation">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.GroupOperation.Reduce">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.GroupOperation.InclusiveScan">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.GroupOperation.ExclusiveScan">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Spirv.KernelEnqueueFlags">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.KernelEnqueueFlags.NoWait">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.KernelEnqueueFlags.WaitKernel">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.KernelEnqueueFlags.WaitWorkGroup">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Spirv.KernelProfilingInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.KernelProfilingInfo.None">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.KernelProfilingInfo.CmdExecTime">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Spirv.Capability">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.Matrix">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.Shader">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.Geometry">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.Tessellation">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.Addresses">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.Linkage">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.Kernel">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.Vector16">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.Float16Buffer">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.Float16">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.Float64">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.Int64">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.Int64Atomics">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.ImageBasic">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.ImageReadWrite">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.ImageMipmap">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.Pipes">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.Groups">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.DeviceEnqueue">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.LiteralSampler">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.AtomicStorage">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.Int16">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.TessellationPointSize">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.GeometryPointSize">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.ImageGatherExtended">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.StorageImageMultisample">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.UniformBufferArrayDynamicIndexing">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.SampledImageArrayDynamicIndexing">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.StorageBufferArrayDynamicIndexing">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.StorageImageArrayDynamicIndexing">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.ClipDistance">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.CullDistance">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.ImageCubeArray">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.SampleRateShading">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.ImageRect">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.SampledRect">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.GenericPointer">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.Int8">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.InputAttachment">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.SparseResidency">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.MinLod">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.Sampled1D">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.Image1D">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.SampledCubeArray">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.SampledBuffer">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.ImageBuffer">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.ImageMSArray">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.StorageImageExtendedFormats">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.ImageQuery">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.DerivativeControl">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.InterpolationFunction">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.TransformFeedback">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.GeometryStreams">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.StorageImageReadWithoutFormat">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.StorageImageWriteWithoutFormat">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.MultiViewport">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.SubgroupDispatch">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.NamedBarrier">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.PipeStorage">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.SubgroupBallotKHR">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Capability.DrawParameters">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Spirv.Op">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpNop">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpUndef">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpSourceContinued">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpSource">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpSourceExtension">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpName">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpMemberName">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpString">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpLine">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpExtension">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpExtInstImport">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpExtInst">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpMemoryModel">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpEntryPoint">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpExecutionMode">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpCapability">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpTypeVoid">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpTypeBool">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpTypeInt">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpTypeFloat">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpTypeVector">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpTypeMatrix">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpTypeImage">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpTypeSampler">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpTypeSampledImage">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpTypeArray">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpTypeRuntimeArray">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpTypeStruct">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpTypeOpaque">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpTypePointer">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpTypeFunction">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpTypeEvent">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpTypeDeviceEvent">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpTypeReserveId">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpTypeQueue">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpTypePipe">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpTypeForwardPointer">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpConstantTrue">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpConstantFalse">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpConstant">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpConstantComposite">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpConstantSampler">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpConstantNull">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpSpecConstantTrue">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpSpecConstantFalse">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpSpecConstant">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpSpecConstantComposite">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpSpecConstantOp">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpFunction">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpFunctionParameter">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpFunctionEnd">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpFunctionCall">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpVariable">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpImageTexelPointer">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpLoad">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpStore">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpCopyMemory">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpCopyMemorySized">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpAccessChain">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpInBoundsAccessChain">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpPtrAccessChain">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpArrayLength">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpGenericPtrMemSemantics">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpInBoundsPtrAccessChain">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpDecorate">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpMemberDecorate">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpDecorationGroup">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpGroupDecorate">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpGroupMemberDecorate">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpVectorExtractDynamic">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpVectorInsertDynamic">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpVectorShuffle">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpCompositeConstruct">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpCompositeExtract">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpCompositeInsert">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpCopyObject">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpTranspose">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpSampledImage">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpImageSampleImplicitLod">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpImageSampleExplicitLod">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpImageSampleDrefImplicitLod">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpImageSampleDrefExplicitLod">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpImageSampleProjImplicitLod">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpImageSampleProjExplicitLod">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpImageSampleProjDrefImplicitLod">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpImageSampleProjDrefExplicitLod">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpImageFetch">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpImageGather">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpImageDrefGather">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpImageRead">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpImageWrite">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpImage">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpImageQueryFormat">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpImageQueryOrder">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpImageQuerySizeLod">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpImageQuerySize">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpImageQueryLod">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpImageQueryLevels">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpImageQuerySamples">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpConvertFToU">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpConvertFToS">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpConvertSToF">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpConvertUToF">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpUConvert">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpSConvert">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpFConvert">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpQuantizeToF16">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpConvertPtrToU">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpSatConvertSToU">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpSatConvertUToS">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpConvertUToPtr">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpPtrCastToGeneric">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpGenericCastToPtr">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpGenericCastToPtrExplicit">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpBitcast">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpSNegate">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpFNegate">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpIAdd">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpFAdd">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpISub">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpFSub">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpIMul">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpFMul">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpUDiv">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpSDiv">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpFDiv">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpUMod">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpSRem">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpSMod">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpFRem">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpFMod">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpVectorTimesScalar">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpMatrixTimesScalar">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpVectorTimesMatrix">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpMatrixTimesVector">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpMatrixTimesMatrix">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpOuterProduct">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpDot">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpIAddCarry">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpISubBorrow">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpUMulExtended">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpSMulExtended">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpAny">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpAll">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpIsNan">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpIsInf">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpIsFinite">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpIsNormal">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpSignBitSet">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpLessOrGreater">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpOrdered">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpUnordered">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpLogicalEqual">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpLogicalNotEqual">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpLogicalOr">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpLogicalAnd">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpLogicalNot">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpSelect">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpIEqual">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpINotEqual">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpUGreaterThan">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpSGreaterThan">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpUGreaterThanEqual">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpSGreaterThanEqual">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpULessThan">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpSLessThan">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpULessThanEqual">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpSLessThanEqual">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpFOrdEqual">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpFUnordEqual">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpFOrdNotEqual">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpFUnordNotEqual">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpFOrdLessThan">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpFUnordLessThan">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpFOrdGreaterThan">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpFUnordGreaterThan">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpFOrdLessThanEqual">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpFUnordLessThanEqual">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpFOrdGreaterThanEqual">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpFUnordGreaterThanEqual">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpShiftRightLogical">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpShiftRightArithmetic">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpShiftLeftLogical">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpBitwiseOr">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpBitwiseXor">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpBitwiseAnd">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpNot">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpBitFieldInsert">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpBitFieldSExtract">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpBitFieldUExtract">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpBitReverse">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpBitCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpDPdx">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpDPdy">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpFwidth">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpDPdxFine">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpDPdyFine">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpFwidthFine">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpDPdxCoarse">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpDPdyCoarse">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpFwidthCoarse">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpEmitVertex">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpEndPrimitive">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpEmitStreamVertex">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpEndStreamPrimitive">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpControlBarrier">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpMemoryBarrier">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpAtomicLoad">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpAtomicStore">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpAtomicExchange">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpAtomicCompareExchange">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpAtomicCompareExchangeWeak">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpAtomicIIncrement">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpAtomicIDecrement">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpAtomicIAdd">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpAtomicISub">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpAtomicSMin">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpAtomicUMin">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpAtomicSMax">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpAtomicUMax">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpAtomicAnd">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpAtomicOr">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpAtomicXor">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpPhi">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpLoopMerge">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpSelectionMerge">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpLabel">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpBranch">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpBranchConditional">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpSwitch">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpKill">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpReturn">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpReturnValue">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpUnreachable">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpLifetimeStart">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpLifetimeStop">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpGroupAsyncCopy">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpGroupWaitEvents">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpGroupAll">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpGroupAny">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpGroupBroadcast">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpGroupIAdd">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpGroupFAdd">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpGroupFMin">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpGroupUMin">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpGroupSMin">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpGroupFMax">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpGroupUMax">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpGroupSMax">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpReadPipe">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpWritePipe">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpReservedReadPipe">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpReservedWritePipe">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpReserveReadPipePackets">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpReserveWritePipePackets">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpCommitReadPipe">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpCommitWritePipe">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpIsValidReserveId">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpGetNumPipePackets">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpGetMaxPipePackets">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpGroupReserveReadPipePackets">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpGroupReserveWritePipePackets">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpGroupCommitReadPipe">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpGroupCommitWritePipe">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpEnqueueMarker">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpEnqueueKernel">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpGetKernelNDrangeSubGroupCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpGetKernelNDrangeMaxSubGroupSize">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpGetKernelWorkGroupSize">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpGetKernelPreferredWorkGroupSizeMultiple">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpRetainEvent">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpReleaseEvent">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpCreateUserEvent">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpIsValidEvent">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpSetUserEventStatus">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpCaptureEventProfilingInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpGetDefaultQueue">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpBuildNDRange">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpImageSparseSampleImplicitLod">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpImageSparseSampleExplicitLod">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpImageSparseSampleDrefImplicitLod">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpImageSparseSampleDrefExplicitLod">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpImageSparseSampleProjImplicitLod">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpImageSparseSampleProjExplicitLod">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpImageSparseSampleProjDrefImplicitLod">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpImageSparseSampleProjDrefExplicitLod">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpImageSparseFetch">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpImageSparseGather">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpImageSparseDrefGather">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpImageSparseTexelsResident">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpNoLine">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpAtomicFlagTestAndSet">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpAtomicFlagClear">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpImageSparseRead">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpSizeOf">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpTypePipeStorage">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpConstantPipeStorage">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpCreatePipeFromPipeStorage">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpGetKernelLocalSizeForSubgroupCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpGetKernelMaxNumSubgroups">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpTypeNamedBarrier">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpNamedBarrierInitialize">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpMemoryNamedBarrier">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpModuleProcessed">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpSubgroupBallotKHR">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Op.OpSubgroupFirstInvocationKHR">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Spirv.ISpirvSink">
            <summary>
            Represents a target for outputing SPIR-V statements
            </summary>
        </member>
        <member name="M:SharpVk.Spirv.ISpirvSink.AddStatement(System.Nullable{SharpVk.Spirv.ResultId},SharpVk.Spirv.SpirvStatement)">
            <summary>
            Output the specified statement with an optional ResultID
            </summary>
            <param name="resultId">
            If not null; the ResultId representing the result of this
            statement.
            </param>
            <param name="statement">
            The SPIR-V statement to output to this sink instance.
            </param>
        </member>
        <member name="T:SharpVk.Spirv.SpirvSinkExtensions">
            <summary>
            Common overloads for ISpirvSink instances.
            </summary>
        </member>
        <member name="M:SharpVk.Spirv.SpirvSinkExtensions.AddStatement(SharpVk.Spirv.ISpirvSink,SharpVk.Spirv.SpirvStatement)">
            <summary>
            Output the specified statement
            </summary>
            <param name="sink">
            The sink to which to output the statement.
            </param>
            <param name="statement">
            The SPIR-V statement to output to this sink instance.
            </param>
        </member>
        <member name="M:SharpVk.Spirv.SpirvSinkExtensions.AddStatement(SharpVk.Spirv.ISpirvSink,SharpVk.Spirv.Op,System.Object[])">
            <summary>
            Output an SPIR-V statement with the specified opcode and operands
            arguments.
            </summary>
            <param name="sink">
            The sink to which to output the statement.
            </param>
            <param name="op">
            The opcode of the statement to output.
            </param>
            <param name="operands">
            A list of operand arguments to include in the output statement.
            </param>
        </member>
        <member name="M:SharpVk.Spirv.SpirvSinkExtensions.AddStatement(SharpVk.Spirv.ISpirvSink,SharpVk.Spirv.ResultId,SharpVk.Spirv.Op,System.Object[])">
            <summary>
            Output an SPIR-V statement with the specified opcode, ResultID and operands
            arguments.
            </summary>
            <param name="sink">
            The sink to which to output the statement.
            </param>
            <param name="resultId">
            A ResultId representing the result of this statement.
            </param>
            <param name="op">
            The opcode of the statement to output.
            </param>
            <param name="operands">
            A list of operand arguments to include in the output statement.
            </param>
        </member>
        <member name="T:SharpVk.Spirv.OpCode">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpNop">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpUndef">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpSourceContinued">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpSource">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpSourceExtension">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpName">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpMemberName">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpString">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpLine">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpExtension">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpExtInstImport">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpExtInst">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpMemoryModel">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpEntryPoint">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpExecutionMode">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpCapability">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpTypeVoid">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpTypeBool">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpTypeInt">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpTypeFloat">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpTypeVector">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpTypeMatrix">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpTypeImage">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpTypeSampler">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpTypeSampledImage">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpTypeArray">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpTypeRuntimeArray">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpTypeStruct">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpTypeOpaque">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpTypePointer">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpTypeFunction">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpTypeEvent">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpTypeDeviceEvent">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpTypeReserveId">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpTypeQueue">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpTypePipe">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpTypeForwardPointer">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpConstantTrue">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpConstantFalse">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpConstant">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpConstantComposite">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpConstantSampler">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpConstantNull">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpSpecConstantTrue">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpSpecConstantFalse">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpSpecConstant">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpSpecConstantComposite">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpSpecConstantOp">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpFunction">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpFunctionParameter">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpFunctionEnd">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpFunctionCall">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpVariable">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpImageTexelPointer">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpLoad">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpStore">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpCopyMemory">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpCopyMemorySized">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpAccessChain">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpInBoundsAccessChain">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpPtrAccessChain">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpArrayLength">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpGenericPtrMemSemantics">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpInBoundsPtrAccessChain">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpDecorate">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpMemberDecorate">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpDecorationGroup">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpGroupDecorate">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpGroupMemberDecorate">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpVectorExtractDynamic">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpVectorInsertDynamic">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpVectorShuffle">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpCompositeConstruct">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpCompositeExtract">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpCompositeInsert">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpCopyObject">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpTranspose">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpSampledImage">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpImageSampleImplicitLod">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpImageSampleExplicitLod">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpImageSampleDrefImplicitLod">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpImageSampleDrefExplicitLod">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpImageSampleProjImplicitLod">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpImageSampleProjExplicitLod">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpImageSampleProjDrefImplicitLod">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpImageSampleProjDrefExplicitLod">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpImageFetch">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpImageGather">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpImageDrefGather">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpImageRead">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpImageWrite">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpImage">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpImageQueryFormat">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpImageQueryOrder">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpImageQuerySizeLod">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpImageQuerySize">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpImageQueryLod">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpImageQueryLevels">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpImageQuerySamples">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpConvertFToU">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpConvertFToS">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpConvertSToF">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpConvertUToF">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpUConvert">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpSConvert">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpFConvert">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpQuantizeToF16">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpConvertPtrToU">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpSatConvertSToU">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpSatConvertUToS">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpConvertUToPtr">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpPtrCastToGeneric">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpGenericCastToPtr">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpGenericCastToPtrExplicit">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpBitcast">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpSNegate">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpFNegate">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpIAdd">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpFAdd">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpISub">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpFSub">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpIMul">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpFMul">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpUDiv">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpSDiv">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpFDiv">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpUMod">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpSRem">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpSMod">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpFRem">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpFMod">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpVectorTimesScalar">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpMatrixTimesScalar">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpVectorTimesMatrix">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpMatrixTimesVector">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpMatrixTimesMatrix">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpOuterProduct">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpDot">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpIAddCarry">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpISubBorrow">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpUMulExtended">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpSMulExtended">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpAny">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpAll">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpIsNan">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpIsInf">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpIsFinite">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpIsNormal">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpSignBitSet">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpLessOrGreater">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpOrdered">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpUnordered">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpLogicalEqual">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpLogicalNotEqual">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpLogicalOr">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpLogicalAnd">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpLogicalNot">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpSelect">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpIEqual">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpINotEqual">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpUGreaterThan">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpSGreaterThan">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpUGreaterThanEqual">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpSGreaterThanEqual">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpULessThan">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpSLessThan">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpULessThanEqual">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpSLessThanEqual">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpFOrdEqual">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpFUnordEqual">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpFOrdNotEqual">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpFUnordNotEqual">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpFOrdLessThan">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpFUnordLessThan">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpFOrdGreaterThan">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpFUnordGreaterThan">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpFOrdLessThanEqual">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpFUnordLessThanEqual">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpFOrdGreaterThanEqual">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpFUnordGreaterThanEqual">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpShiftRightLogical">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpShiftRightArithmetic">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpShiftLeftLogical">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpBitwiseOr">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpBitwiseXor">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpBitwiseAnd">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpNot">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpBitFieldInsert">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpBitFieldSExtract">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpBitFieldUExtract">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpBitReverse">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpBitCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpDPdx">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpDPdy">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpFwidth">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpDPdxFine">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpDPdyFine">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpFwidthFine">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpDPdxCoarse">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpDPdyCoarse">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpFwidthCoarse">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpEmitVertex">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpEndPrimitive">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpEmitStreamVertex">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpEndStreamPrimitive">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpControlBarrier">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpMemoryBarrier">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpAtomicLoad">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpAtomicStore">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpAtomicExchange">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpAtomicCompareExchange">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpAtomicCompareExchangeWeak">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpAtomicIIncrement">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpAtomicIDecrement">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpAtomicIAdd">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpAtomicISub">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpAtomicSMin">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpAtomicUMin">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpAtomicSMax">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpAtomicUMax">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpAtomicAnd">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpAtomicOr">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpAtomicXor">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpPhi">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpLoopMerge">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpSelectionMerge">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpLabel">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpBranch">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpBranchConditional">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpSwitch">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpKill">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpReturn">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpReturnValue">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpUnreachable">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpLifetimeStart">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpLifetimeStop">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpGroupAsyncCopy">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpGroupWaitEvents">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpGroupAll">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpGroupAny">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpGroupBroadcast">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpGroupIAdd">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpGroupFAdd">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpGroupFMin">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpGroupUMin">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpGroupSMin">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpGroupFMax">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpGroupUMax">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpGroupSMax">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpReadPipe">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpWritePipe">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpReservedReadPipe">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpReservedWritePipe">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpReserveReadPipePackets">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpReserveWritePipePackets">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpCommitReadPipe">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpCommitWritePipe">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpIsValidReserveId">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpGetNumPipePackets">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpGetMaxPipePackets">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpGroupReserveReadPipePackets">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpGroupReserveWritePipePackets">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpGroupCommitReadPipe">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpGroupCommitWritePipe">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpEnqueueMarker">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpEnqueueKernel">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpGetKernelNDrangeSubGroupCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpGetKernelNDrangeMaxSubGroupSize">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpGetKernelWorkGroupSize">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpGetKernelPreferredWorkGroupSizeMultiple">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpRetainEvent">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpReleaseEvent">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpCreateUserEvent">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpIsValidEvent">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpSetUserEventStatus">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpCaptureEventProfilingInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpGetDefaultQueue">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpBuildNDRange">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpImageSparseSampleImplicitLod">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpImageSparseSampleExplicitLod">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpImageSparseSampleDrefImplicitLod">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpImageSparseSampleDrefExplicitLod">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpImageSparseSampleProjImplicitLod">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpImageSparseSampleProjExplicitLod">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpImageSparseSampleProjDrefImplicitLod">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpImageSparseSampleProjDrefExplicitLod">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpImageSparseFetch">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpImageSparseGather">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpImageSparseDrefGather">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpImageSparseTexelsResident">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpNoLine">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpAtomicFlagTestAndSet">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpAtomicFlagClear">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpImageSparseRead">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpSizeOf">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpTypePipeStorage">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpConstantPipeStorage">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpCreatePipeFromPipeStorage">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpGetKernelLocalSizeForSubgroupCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpGetKernelMaxNumSubgroups">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpTypeNamedBarrier">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpNamedBarrierInitialize">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpMemoryNamedBarrier">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpModuleProcessed">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpSubgroupBallotKHR">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.OpSubgroupFirstInvocationKHR">
            <summary>
            
            </summary>
        </member>
        <member name="P:SharpVk.Spirv.OpCode.Op">
            <summary>
            
            </summary>
        </member>
        <member name="P:SharpVk.Spirv.OpCode.Operands">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OpCode.Lookup">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Spirv.Operand">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.Spirv.Operand.Kind">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.Spirv.Operand.Quantifier">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.Spirv.Operand.Name">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Spirv.OperandKind">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.ImageOperands">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.FPFastMathMode">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.SelectionControl">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.LoopControl">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.FunctionControl">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.MemorySemantics">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.MemoryAccess">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.KernelProfilingInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.SourceLanguage">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.ExecutionModel">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.AddressingModel">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.MemoryModel">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.ExecutionMode">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.StorageClass">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.Dim">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.SamplerAddressingMode">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.SamplerFilterMode">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.ImageFormat">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.ImageChannelOrder">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.ImageChannelDataType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.FPRoundingMode">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.LinkageType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.AccessQualifier">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.FunctionParameterAttribute">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.Decoration">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.BuiltIn">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.Scope">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.GroupOperation">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.KernelEnqueueFlags">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.Capability">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.IdResultType">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.IdResult">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.IdMemorySemantics">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.IdScope">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.IdRef">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.LiteralInteger">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.LiteralString">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.LiteralContextDependentNumber">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.LiteralExtInstInteger">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.LiteralSpecConstantOpInteger">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.PairLiteralIntegerIdRef">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.PairIdRefLiteralInteger">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.OperandKind.PairIdRefIdRef">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Spirv.Quantifier">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Quantifier.None">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Quantifier.Optional">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Spirv.Quantifier.Multiple">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Spirv.ResultId">
            <summary>
            Represents the unique ID value representing the result of an SPIR-V
            statement.
            </summary>
        </member>
        <member name="P:SharpVk.Spirv.ResultId.Id">
            <summary>
            The integer value of this ID value.
            </summary>
        </member>
        <member name="M:SharpVk.Spirv.ResultId.ToString">
            <summary>
            Returns a string value representing this ID value.
            </summary>
            <returns>
            A string value.
            </returns>
        </member>
        <member name="M:SharpVk.Spirv.ResultId.op_Implicit(System.Int32)~SharpVk.Spirv.ResultId">
            <summary>
            Implicit cast of an integer value to a ResultId.
            </summary>
            <param name="value">
            The unique integer value for this ID.
            </param>
        </member>
        <member name="T:SharpVk.Spirv.SpirvStatement">
            <summary>
            Represents a single line of a SPIR-V shader file.
            </summary>
        </member>
        <member name="M:SharpVk.Spirv.SpirvStatement.#ctor(SharpVk.Spirv.Op,System.Object[])">
            <summary>
            Create a new SPIR-V statement with the specified opcode &amp;
            operand arguments.
            </summary>
            <param name="op">
            The opcode for this statement.
            </param>
            <param name="operands">
            The arguments for any operands of the specified opcode.
            </param>
        </member>
        <member name="P:SharpVk.Spirv.SpirvStatement.Op">
            <summary>
            The Opcode for this statement.
            </summary>
        </member>
        <member name="P:SharpVk.Spirv.SpirvStatement.Operands">
            <summary>
            The operands arguments for this statement.
            </summary>
        </member>
        <member name="M:SharpVk.Spirv.SpirvStatement.ToString">
            <summary>
            Returns a string representation of this statement.
            </summary>
            <returns>
            A string representation of this statement.
            </returns>
        </member>
        <member name="M:SharpVk.Spirv.SpirvStatement.Equals(System.Object)">
            <summary>
            Determines whether the specified object is equal (by value) to this
            instance.
            </summary>
            <param name="obj">
            The object to which to compare.
            </param>
            <returns>
            True if the instances are equal by value; else false.
            </returns>
        </member>
        <member name="M:SharpVk.Spirv.SpirvStatement.GetHashCode">
            <summary>
            Returns a hashcode for the value of this instance.
            </summary>
            <returns>
            A 32-bit signed integer hash value.
            </returns>
        </member>
        <member name="M:SharpVk.Spirv.SpirvStatement.op_Equality(SharpVk.Spirv.SpirvStatement,SharpVk.Spirv.SpirvStatement)">
            <summary>
            Determines whether the specified objects are equal (by value).
            </summary>
            <param name="left">
            The first value to compare.
            </param>
            <param name="right">
            The second value to compare.
            </param>
            <returns>
            True if the instances are equal by value; else false.
            </returns>
        </member>
        <member name="M:SharpVk.Spirv.SpirvStatement.op_Inequality(SharpVk.Spirv.SpirvStatement,SharpVk.Spirv.SpirvStatement)">
            <summary>
            Determines whether the specified objects are not equal (by value).
            </summary>
            <param name="left">
            The first value to compare.
            </param>
            <param name="right">
            The second value to compare.
            </param>
            <returns>
            True if the instances are not equal by value; else false.
            </returns>
        </member>
        <member name="T:SharpVk.StencilFaceFlags">
            <summary>
            Bitmask specifying sets of stencil state for which to update the
            compare mask.
            </summary>
        </member>
        <member name="F:SharpVk.StencilFaceFlags.None">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StencilFaceFlags.Front">
            <summary>
            Front face
            </summary>
        </member>
        <member name="F:SharpVk.StencilFaceFlags.Back">
            <summary>
            Back face
            </summary>
        </member>
        <member name="F:SharpVk.StencilFaceFlags.FrontAndBack">
            <summary>
            Front and back faces
            </summary>
        </member>
        <member name="T:SharpVk.StencilOp">
            <summary>
            <para>
            Stencil comparison function.
            </para>
            <para>
            For purposes of increment and decrement, the stencil bits are
            considered as an unsigned integer.
            </para>
            <para>
            If the stencil test fails, the sample's coverage bit is cleared in the
            fragment. If there is no stencil framebuffer attachment, stencil
            modification cannot: occur, and it is as if the stencil tests always
            pass.
            </para>
            <para>
            If the stencil test passes, the pname:writeMask member of the
            slink:VkStencilOpState structures controls how the updated stencil
            value is written to the stencil framebuffer attachment.
            </para>
            <para>
            The least significant [eq]#s# bits of pname:writeMask, where [eq]#s# is
            the number of bits in the stencil framebuffer attachment, specify an
            integer mask. Where a [eq]#1# appears in this mask, the corresponding
            bit in the stencil value in the depth/stencil attachment is written;
            where a [eq]#0# appears, the bit is not written. The pname:writeMask
            value uses either the front-facing or back-facing state based on the
            facing-ness of the fragment. Fragments generated by front-facing
            primitives use the front mask and fragments generated by back-facing
            primitives use the back mask.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.StencilOp.Keep">
            <summary>
            ename:VK_STENCIL_OP_KEEP keeps the current value.
            </summary>
        </member>
        <member name="F:SharpVk.StencilOp.Zero">
            <summary>
            ename:VK_STENCIL_OP_ZERO sets the value to 0.
            </summary>
        </member>
        <member name="F:SharpVk.StencilOp.Replace">
            <summary>
            ename:VK_STENCIL_OP_REPLACE sets the value to pname:reference.
            </summary>
        </member>
        <member name="F:SharpVk.StencilOp.IncrementAndClamp">
            <summary>
            ename:VK_STENCIL_OP_INCREMENT_AND_CLAMP increments the current
            value and clamps to the maximum representable unsigned value.
            </summary>
        </member>
        <member name="F:SharpVk.StencilOp.DecrementAndClamp">
            <summary>
            ename:VK_STENCIL_OP_DECREMENT_AND_CLAMP decrements the current
            value and clamps to 0.
            </summary>
        </member>
        <member name="F:SharpVk.StencilOp.Invert">
            <summary>
            ename:VK_STENCIL_OP_INVERT bitwise-inverts the current value.
            </summary>
        </member>
        <member name="F:SharpVk.StencilOp.IncrementAndWrap">
            <summary>
            ename:VK_STENCIL_OP_INCREMENT_AND_WRAP increments the current value
            and wraps to 0 when the maximum value would have been exceeded.
            </summary>
        </member>
        <member name="F:SharpVk.StencilOp.DecrementAndWrap">
            <summary>
            ename:VK_STENCIL_OP_DECREMENT_AND_WRAP decrements the current value
            and wraps to the maximum possible value when the value would go
            below 0.
            </summary>
        </member>
        <member name="T:SharpVk.StencilOpState">
            <summary>
            Structure specifying stencil operation state.
            </summary>
        </member>
        <member name="M:SharpVk.StencilOpState.#ctor(SharpVk.StencilOp,SharpVk.StencilOp,SharpVk.StencilOp,SharpVk.CompareOp,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.StencilOpState.FailOp">
            <summary>
            pname:failOp is the action performed on samples that fail the
            stencil test.
            </summary>
        </member>
        <member name="F:SharpVk.StencilOpState.PassOp">
            <summary>
            pname:passOp is the action performed on samples that pass both the
            depth and stencil tests.
            </summary>
        </member>
        <member name="F:SharpVk.StencilOpState.DepthFailOp">
            <summary>
            pname:depthFailOp is the action performed on samples that pass the
            stencil test and fail the depth test.
            </summary>
        </member>
        <member name="F:SharpVk.StencilOpState.CompareOp">
            <summary>
            pname:compareOp is the comparison operator used in the stencil
            test.
            </summary>
        </member>
        <member name="F:SharpVk.StencilOpState.CompareMask">
            <summary>
            pname:compareMask selects the bits of the unsigned integer stencil
            values participating in the stencil test.
            </summary>
        </member>
        <member name="F:SharpVk.StencilOpState.WriteMask">
            <summary>
            pname:writeMask selects the bits of the unsigned integer stencil
            values updated by the stencil test in the stencil framebuffer
            attachment.
            </summary>
        </member>
        <member name="F:SharpVk.StencilOpState.Reference">
            <summary>
            pname:reference is an integer reference value that is used in the
            unsigned stencil comparison.
            </summary>
        </member>
        <member name="M:SharpVk.StencilOpState.ToString">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.SECURITY_ATTRIBUTES">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.SECURITY_ATTRIBUTES.nLength">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.SECURITY_ATTRIBUTES.lpSecurityDescriptor">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.SECURITY_ATTRIBUTES.bInheritHandle">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.SampleMask">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.SampleMask.op_Implicit(System.UInt32)~SharpVk.SampleMask">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.SampleMask.op_Implicit(SharpVk.SampleMask)~System.UInt32">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.SampleMask.ToString">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Bool32">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Bool32.#ctor(System.Boolean)">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Bool32.op_Implicit(System.Boolean)~SharpVk.Bool32">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Bool32.op_Implicit(SharpVk.Bool32)~System.Boolean">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Bool32.ToString">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.DeviceSize">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.DeviceSize.op_Implicit(System.Int32)~SharpVk.DeviceSize">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.DeviceSize.op_Implicit(System.UInt64)~SharpVk.DeviceSize">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.DeviceSize.op_Implicit(SharpVk.DeviceSize)~System.UInt64">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.DeviceSize.ToString">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Size">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Size.op_Implicit(System.Int32)~SharpVk.Size">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Size.op_Implicit(System.UInt32)~SharpVk.Size">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Size.op_Implicit(System.UInt64)~SharpVk.Size">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Size.op_Explicit(SharpVk.Size)~System.UInt32">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Size.op_Explicit(SharpVk.Size)~System.UInt64">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Size.ToString">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.StructureType">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.ApplicationInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.InstanceCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.DeviceQueueCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.DeviceCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.SubmitInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.MemoryAllocateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.MappedMemoryRange">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.BindSparseInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.FenceCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.SemaphoreCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.EventCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.QueryPoolCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.BufferCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.BufferViewCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.ImageCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.ImageViewCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.ShaderModuleCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.PipelineCacheCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.PipelineShaderStageCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.PipelineVertexInputStateCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.PipelineInputAssemblyStateCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.PipelineTessellationStateCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.PipelineViewportStateCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.PipelineRasterizationStateCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.PipelineMultisampleStateCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.PipelineDepthStencilStateCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.PipelineColorBlendStateCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.PipelineDynamicStateCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.GraphicsPipelineCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.ComputePipelineCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.PipelineLayoutCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.SamplerCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.DescriptorSetLayoutCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.DescriptorPoolCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.DescriptorSetAllocateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.WriteDescriptorSet">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.CopyDescriptorSet">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.FramebufferCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.RenderPassCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.CommandPoolCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.CommandBufferAllocateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.CommandBufferInheritanceInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.CommandBufferBeginInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.RenderPassBeginInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.BufferMemoryBarrier">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.ImageMemoryBarrier">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.MemoryBarrier">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.LoaderInstanceCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.LoaderDeviceCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.SwapchainCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.PresentInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.DisplayModeCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.DisplaySurfaceCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.DisplayPresentInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.XlibSurfaceCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.XcbSurfaceCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.WaylandSurfaceCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.MirSurfaceCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.AndroidSurfaceCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.Win32SurfaceCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.DebugReportCallbackCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.PipelineRasterizationStateRasterizationOrder">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.DebugMarkerObjectNameInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.DebugMarkerObjectTagInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.DebugMarkerMarkerInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.DedicatedAllocationImageCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.DedicatedAllocationBufferCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.DedicatedAllocationMemoryAllocateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.ExternalMemoryImageCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.ExportMemoryAllocateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.ImportMemoryWin32HandleInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.ExportMemoryWin32HandleInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.Win32KeyedMutexAcquireReleaseInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.PhysicalDeviceFeatures2">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.PhysicalDeviceProperties2">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.FormatProperties2">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.ImageFormatProperties2">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.PhysicalDeviceImageFormatInfo2">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.QueueFamilyProperties2">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.PhysicalDeviceMemoryProperties2">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.SparseImageFormatProperties2">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.PhysicalDeviceSparseImageFormatInfo2">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.ValidationFlags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.ViSurfaceCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.ObjectTableCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.IndirectCommandsLayoutCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.CommandProcessCommandsInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.CommandReserveSpaceForCommandsInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.DeviceGeneratedCommandsLimits">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.DeviceGeneratedCommandsFeatures">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.SurfaceCapabilities2">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.DisplayPowerInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.DeviceEventInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.DisplayEventInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.StructureType.SwapchainCounterCreateInfo">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.SubmitInfo">
            <summary>
            <para>
            Structure specifying a queue submit operation.
            </para>
            <para>
            The order that command buffers appear in pname:pCommandBuffers is used
            to determine &lt;&lt;synchronization-submission-order, submission
            order&gt;&gt;, and thus all the &lt;&lt;synchronization-implicit,
            implicit ordering guarantees&gt;&gt; that respect it. Other than these
            implicit ordering guarantees and any &lt;&lt;synchronization, explicit
            synchronization primitives&gt;&gt;, these command buffers may: overlap
            or otherwise execute out of order.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.SubmitInfo.WaitSemaphores">
            <summary>
            pname:pWaitSemaphores is a pointer to an array of semaphores upon
            which to wait before the command buffers for this batch begin
            execution. If semaphores to wait on are provided, they define a
            &lt;&lt;synchronization-semaphores-waiting, semaphore wait
            operation&gt;&gt;.
            </summary>
        </member>
        <member name="P:SharpVk.SubmitInfo.WaitDestinationStageMask">
            <summary>
            pname:pWaitDstStageMask is a pointer to an array of pipeline stages
            at which each corresponding semaphore wait will occur.
            </summary>
        </member>
        <member name="P:SharpVk.SubmitInfo.CommandBuffers">
            <summary>
            pname:pCommandBuffers is a pointer to an array of command buffers
            to execute in the batch.
            </summary>
        </member>
        <member name="P:SharpVk.SubmitInfo.SignalSemaphores">
            <summary>
            pname:pSignalSemaphores is a pointer to an array of semaphores
            which will be signaled when the command buffers for this batch have
            completed execution. If semaphores to be signaled are provided,
            they define a &lt;&lt;synchronization-semaphores-signaling,
            semaphore signal operation&gt;&gt;.
            </summary>
        </member>
        <member name="T:SharpVk.SubpassContents">
            <summary>
            <para>
            Specify how commands in the first subpass of a render pass are
            provided.
            </para>
            <para>
            After beginning a render pass instance, the command buffer is ready to
            record the commands for the first subpass of that render pass.
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SubpassContents.Inline">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.SubpassContents.SecondaryCommandBuffers">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.SubpassDependency">
            <summary>
            <para>
            Structure specifying a subpass dependency.
            </para>
            <para>
            If pname:srcSubpass is equal to pname:dstSubpass then the
            slink:VkSubpassDependency describes a
            &lt;&lt;synchronization-pipeline-barriers-subpass-self-dependencies, subpass
            self-dependency&gt;&gt;, and only constrains the pipeline barriers
            allowed within a subpass instance. Otherwise, when a render pass
            instance which includes a subpass dependency is submitted to a queue,
            it defines a memory dependency between the subpasses identified by
            pname:srcSubpass and pname:dstSubpass.
            </para>
            <para>
            If pname:srcSubpass is equal to ename:VK_SUBPASS_EXTERNAL, the first
            &lt;&lt;synchronization-dependencies-scopes, synchronization
            scope&gt;&gt; includes commands submitted to the queue before the
            render pass instance began. Otherwise, the first set of commands
            includes all commands submitted as part of the subpass instance
            identified by pname:srcSubpass and any load, store or multisample
            resolve operations on attachments used in pname:srcSubpass. In either
            case, the first synchronization scope is limited to operations on the
            pipeline stages determined by the
            &lt;&lt;synchronization-pipeline-stages-masks, source stage
            mask&gt;&gt; specified by pname:srcStageMask.
            </para>
            <para>
            If pname:dstSubpass is equal to ename:VK_SUBPASS_EXTERNAL, the second
            &lt;&lt;synchronization-dependencies-scopes, synchronization
            scope&gt;&gt; includes commands submitted after the render pass
            instance is ended. Otherwise, the second set of commands includes all
            commands submitted as part of the subpass instance identified by
            pname:dstSubpass and any load, store or multisample resolve operations
            on attachments used in pname:dstSubpass. In either case, the second
            synchronization scope is limited to operations on the pipeline stages
            determined by the &lt;&lt;synchronization-pipeline-stages-masks,
            destination stage mask&gt;&gt; specified by pname:dstStageMask.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.SubpassDependency.#ctor(System.UInt32,System.UInt32,SharpVk.PipelineStageFlags,SharpVk.PipelineStageFlags,SharpVk.AccessFlags,SharpVk.AccessFlags,SharpVk.DependencyFlags)">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.SubpassDependency.SourceSubpass">
            <summary>
            pname:srcSubpass is the subpass index of the first subpass in the
            dependency, or ename:VK_SUBPASS_EXTERNAL.
            </summary>
        </member>
        <member name="F:SharpVk.SubpassDependency.DestinationSubpass">
            <summary>
            pname:dstSubpass is the subpass index of the second subpass in the
            dependency, or ename:VK_SUBPASS_EXTERNAL.
            </summary>
        </member>
        <member name="F:SharpVk.SubpassDependency.SourceStageMask">
            <summary>
            pname:srcStageMask defines a
            &lt;&lt;synchronization-pipeline-stages-masks, source stage
            mask&gt;&gt;.
            </summary>
        </member>
        <member name="F:SharpVk.SubpassDependency.DestinationStageMask">
            <summary>
            pname:dstStageMask defines a
            &lt;&lt;synchronization-pipeline-stages-masks, destination stage
            mask&gt;&gt;.
            </summary>
        </member>
        <member name="F:SharpVk.SubpassDependency.SourceAccessMask">
            <summary>
            pname:srcAccessMask defines a &lt;&lt;synchronization-access-masks,
            source access mask&gt;&gt;.
            </summary>
        </member>
        <member name="F:SharpVk.SubpassDependency.DestinationAccessMask">
            <summary>
            pname:dstAccessMask defines a &lt;&lt;synchronization-access-masks,
            destination access mask&gt;&gt;.
            </summary>
        </member>
        <member name="F:SharpVk.SubpassDependency.DependencyFlags">
            <summary>
            pname:dependencyFlags is a bitmask of elink:VkDependencyFlagBits.
            </summary>
        </member>
        <member name="M:SharpVk.SubpassDependency.ToString">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.SubpassDescription">
            <summary>
            <para>
            Structure specifying a subpass description.
            </para>
            <para>
            The contents of an attachment within the render area become undefined
            at the start of a subpass *S* if all of the following conditions are
            true:
            </para>
            <para>
            * The attachment is used as a color, depth/stencil, or resolve
            attachment in any subpass in the render pass. * There is a subpass
            *S~1~* that uses or preserves the attachment, and a subpass dependency
            from *S~1~* to *S*. * The attachment is not used or preserved in
            subpass *S*.
            </para>
            <para>
            Once the contents of an attachment become undefined in subpass *S*,
            they remain undefined for subpasses in subpass dependency chains
            starting with subpass *S* until they are written again. However, they
            remain valid for subpasses in other subpass dependency chains starting
            with subpass *S~1~* if those subpasses use or preserve the attachment.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.SubpassDescription.Flags">
            <summary>
            pname:flags is reserved for future use.
            </summary>
        </member>
        <member name="P:SharpVk.SubpassDescription.PipelineBindPoint">
            <summary>
            pname:pipelineBindPoint is a elink:VkPipelineBindPoint value
            specifying whether this is a compute or graphics subpass.
            Currently, only graphics subpasses are supported.
            </summary>
        </member>
        <member name="P:SharpVk.SubpassDescription.InputAttachments">
            <summary>
            pname:pInputAttachments is an array of slink:VkAttachmentReference
            structures (defined below) that lists which of the render pass's
            attachments can: be read in the shader during the subpass, and what
            layout each attachment will be in during the subpass. Each element
            of the array corresponds to an input attachment unit number in the
            shader, i.e. if the shader declares an input variable
            `layout(input_attachment_index=X, set=Y, binding=Z)` then it uses
            the attachment provided in pname:pInputAttachments[X]. Input
            attachments must: also be bound to the pipeline with a descriptor
            set, with the input attachment descriptor written in the location
            (set=Y, binding=Z).
            </summary>
        </member>
        <member name="P:SharpVk.SubpassDescription.ColorAttachments">
            <summary>
            pname:pColorAttachments is an array of pname:colorAttachmentCount
            slink:VkAttachmentReference structures that lists which of the
            render pass's attachments will be used as color attachments in the
            subpass, and what layout each attachment will be in during the
            subpass. Each element of the array corresponds to a fragment shader
            output location, i.e. if the shader declared an output variable
            `layout(location=X)` then it uses the attachment provided in
            pname:pColorAttachments[X].
            </summary>
        </member>
        <member name="P:SharpVk.SubpassDescription.ResolveAttachments">
            <summary>
            pname:pResolveAttachments is `NULL` or an array of
            pname:colorAttachmentCount slink:VkAttachmentReference structures
            that lists which of the render pass's attachments are resolved to
            at the end of the subpass, and what layout each attachment will be
            in during the multisample resolve operation. If
            pname:pResolveAttachments is not `NULL`, each of its elements
            corresponds to a color attachment (the element in
            pname:pColorAttachments at the same index), and a multisample
            resolve operation is defined for each attachment. At the end of
            each subpass, multisample resolve operations read the subpass's
            color attachments, and resolve the samples for each pixel to the
            same pixel location in the corresponding resolve attachments,
            unless the resolve attachment index is ename:VK_ATTACHMENT_UNUSED.
            If the first use of an attachment in a render pass is as a resolve
            attachment, then the pname:loadOp is effectively ignored as the
            resolve is guaranteed to overwrite all pixels in the render area.
            </summary>
        </member>
        <member name="P:SharpVk.SubpassDescription.DepthStencilAttachment">
            <summary>
            pname:pDepthStencilAttachment is a pointer to a
            slink:VkAttachmentReference specifying which attachment will be
            used for depth/stencil data and the layout it will be in during the
            subpass. Setting the attachment index to ename:VK_ATTACHMENT_UNUSED
            or leaving this pointer as `NULL` indicates that no depth/stencil
            attachment will be used in the subpass.
            </summary>
        </member>
        <member name="P:SharpVk.SubpassDescription.PreserveAttachments">
            <summary>
            pname:pPreserveAttachments is an array of
            pname:preserveAttachmentCount render pass attachment indices
            describing the attachments that are not used by a subpass, but
            whose contents must: be preserved throughout the subpass.
            </summary>
        </member>
        <member name="T:SharpVk.SubpassDescriptionFlags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.SubpassDescriptionFlags.None">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.SubresourceLayout">
            <summary>
            <para>
            Structure specifying subresource layout.
            </para>
            <para>
            For images created with linear tiling, pname:rowPitch, pname:arrayPitch
            and pname:depthPitch describe the layout of the image subresource in
            linear memory. For uncompressed formats, pname:rowPitch is the number
            of bytes between texels with the same x coordinate in adjacent rows (y
            coordinates differ by one). pname:arrayPitch is the number of bytes
            between texels with the same x and y coordinate in adjacent array
            layers of the image (array layer values differ by one).
            pname:depthPitch is the number of bytes between texels with the same x
            and y coordinate in adjacent slices of a 3D image (z coordinates differ
            by one). Expressed as an addressing formula, the starting byte of a
            texel in the image subresource has address:
            </para>
            <para>
            [source,c] --------------------------------------------------- //
            (x,y,z,layer) are in texel coordinates address(x,y,z,layer) =
            layer*arrayPitch + z*depthPitch + y*rowPitch + x*elementSize + offset
            ---------------------------------------------------
            </para>
            <para>
            For compressed formats, the pname:rowPitch is the number of bytes
            between compressed texel blocks in adjacent rows. pname:arrayPitch is
            the number of bytes between compressed texel blocks in adjacent array
            layers. pname:depthPitch is the number of bytes between compressed
            texel blocks in adjacent slices of a 3D image.
            </para>
            <para>
            [source,c] --------------------------------------------------- //
            (x,y,z,layer) are in compressed texel block coordinates
            address(x,y,z,layer) = layer*arrayPitch + z*depthPitch + y*rowPitch +
            x*compressedTexelBlockByteSize + offset;
            ---------------------------------------------------
            </para>
            <para>
            pname:arrayPitch is undefined for images that were not created as
            arrays. pname:depthPitch is defined only for 3D images.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.SubresourceLayout.#ctor(SharpVk.DeviceSize,SharpVk.DeviceSize,SharpVk.DeviceSize,SharpVk.DeviceSize,SharpVk.DeviceSize)">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.SubresourceLayout.Offset">
            <summary>
            pname:offset is the byte offset from the start of the image where
            the image subresource begins.
            </summary>
        </member>
        <member name="F:SharpVk.SubresourceLayout.Size">
            <summary>
            pname:size is the size in bytes of the image subresource.
            pname:size includes any extra memory that is required based on
            pname:rowPitch.
            </summary>
        </member>
        <member name="F:SharpVk.SubresourceLayout.RowPitch">
            <summary>
            pname:rowPitch describes the number of bytes between each row of
            texels in an image.
            </summary>
        </member>
        <member name="F:SharpVk.SubresourceLayout.ArrayPitch">
            <summary>
            pname:arrayPitch describes the number of bytes between each array
            layer of an image.
            </summary>
        </member>
        <member name="F:SharpVk.SubresourceLayout.DepthPitch">
            <summary>
            pname:depthPitch describes the number of bytes between each slice
            of 3D image.
            </summary>
        </member>
        <member name="M:SharpVk.SubresourceLayout.ToString">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.Surface">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Surface.Destroy">
            <summary>
            Destroy a VkSurfaceKHR object.
            </summary>
        </member>
        <member name="P:SharpVk.Surface.RawHandle">
            <summary>
            The interop handle for this Surface.
            </summary>
        </member>
        <member name="M:SharpVk.Surface.Dispose">
            <summary>
            Releases the unmanaged resources associated with this instance and
            destroys the underlying Vulkan handle.
            </summary>
        </member>
        <member name="M:SharpVk.Surface.CreateFromHandle(SharpVk.Instance,System.UInt64)">
            <summary>
            Create a new Surface instance from an externally created handle.
            </summary>
            <param name="instance">
            The Vulkan Instance against which the handle was created.
            </param>
            <param name="handle">
            An unsigned 64-bit integer representing the created Surface.
            </param>
            <returns>
            A Surface instance.
            </returns>
        </member>
        <member name="T:SharpVk.SurfaceCapabilities">
            <summary>
            <para>
            Structure describing capabilities of a surface.
            </para>
            <para>
            [NOTE] .Note ==== Formulas such as [eq]#min(N, pname:maxImageCount)#
            are not correct, since pname:maxImageCount may: be zero. ====
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.SurfaceCapabilities.#ctor(System.UInt32,System.UInt32,SharpVk.Extent2D,SharpVk.Extent2D,SharpVk.Extent2D,System.UInt32,SharpVk.SurfaceTransformFlags,SharpVk.SurfaceTransformFlags,SharpVk.CompositeAlphaFlags,SharpVk.ImageUsageFlags)">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.SurfaceCapabilities.MinImageCount">
            <summary>
            pname:minImageCount is the minimum number of images the specified
            device supports for a swapchain created for the surface, and will
            be at least one.
            </summary>
        </member>
        <member name="F:SharpVk.SurfaceCapabilities.MaxImageCount">
            <summary>
            pname:maxImageCount is the maximum number of images the specified
            device supports for a swapchain created for the surface, and will
            be either 0, or greater than or equal to pname:minImageCount. A
            value of 0 means that there is no limit on the number of images,
            though there may: be limits related to the total amount of memory
            used by presentable images.
            </summary>
        </member>
        <member name="F:SharpVk.SurfaceCapabilities.CurrentExtent">
            <summary>
            pname:currentExtent is the current width and height of the surface,
            or the special value [eq]#(0xFFFFFFFF, 0xFFFFFFFF)# indicating that
            the surface size will be determined by the extent of a swapchain
            targeting the surface.
            </summary>
        </member>
        <member name="F:SharpVk.SurfaceCapabilities.MinImageExtent">
            <summary>
            pname:minImageExtent contains the smallest valid swapchain extent
            for the surface on the specified device. The pname:width and
            pname:height of the extent will each be less than or equal to the
            corresponding pname:width and pname:height of pname:currentExtent,
            unless pname:currentExtent has the special value described above.
            </summary>
        </member>
        <member name="F:SharpVk.SurfaceCapabilities.MaxImageExtent">
            <summary>
            pname:maxImageExtent contains the largest valid swapchain extent
            for the surface on the specified device. The pname:width and
            pname:height of the extent will each be greater than or equal to
            the corresponding pname:width and pname:height of
            pname:minImageExtent. The pname:width and pname:height of the
            extent will each be greater than or equal to the corresponding
            pname:width and pname:height of pname:currentExtent, unless
            pname:currentExtent has the special value described above.
            </summary>
        </member>
        <member name="F:SharpVk.SurfaceCapabilities.MaxImageArrayLayers">
            <summary>
            pname:maxImageArrayLayers is the maximum number of layers
            presentable images can: have for a swapchain created for this
            device and surface, and will be at least one.
            </summary>
        </member>
        <member name="F:SharpVk.SurfaceCapabilities.SupportedTransforms">
            <summary>
            pname:supportedTransforms is a bitmask of
            elink:VkSurfaceTransformFlagBitsKHR, describing the presentation
            transforms supported for the surface on the specified device, and
            at least one bit will be set.
            </summary>
        </member>
        <member name="F:SharpVk.SurfaceCapabilities.CurrentTransform">
            <summary>
            pname:currentTransform is the surface's current transform relative
            to the presentation engine's natural orientation, as described by
            elink:VkSurfaceTransformFlagBitsKHR.
            </summary>
        </member>
        <member name="F:SharpVk.SurfaceCapabilities.SupportedCompositeAlpha">
            <summary>
            pname:supportedCompositeAlpha is a bitmask of
            elink:VkCompositeAlphaFlagBitsKHR, representing the alpha
            compositing modes supported by the presentation engine for the
            surface on the specified device, and at least one bit will be set.
            Opaque composition can: be achieved in any alpha compositing mode
            by either using an image format that has no alpha component, or by
            ensuring that all pixels in the presentable images have an alpha
            value of 1.0.
            </summary>
        </member>
        <member name="F:SharpVk.SurfaceCapabilities.SupportedUsageFlags">
            <summary>
            pname:supportedUsageFlags is a bitmask of
            elink:VkImageUsageFlagBits representing the ways the application
            can: use the presentable images of a swapchain created for the
            surface on the specified device.
            ename:VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT must: be included in the
            set but implementations may: support additional usages.
            </summary>
        </member>
        <member name="M:SharpVk.SurfaceCapabilities.ToString">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.SurfaceCapabilities2">
            <summary>
            Structure describing capabilities of a surface.
            </summary>
        </member>
        <member name="P:SharpVk.SurfaceCapabilities2.MinImageCount">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.SurfaceCapabilities2.MaxImageCount">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.SurfaceCapabilities2.CurrentExtent">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.SurfaceCapabilities2.MinImageExtent">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.SurfaceCapabilities2.MaxImageExtent">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.SurfaceCapabilities2.MaxImageArrayLayers">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.SurfaceCapabilities2.SupportedTransforms">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.SurfaceCapabilities2.CurrentTransform">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.SurfaceCapabilities2.SupportedCompositeAlpha">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.SurfaceCapabilities2.SupportedUsageFlags">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.SurfaceCapabilities2.SupportedSurfaceCounters">
            <summary>
            pname:supportedSurfaceCounters is a bitfield containing one bit set
            for each surface counter type supported.
            </summary>
        </member>
        <member name="T:SharpVk.SurfaceCounterFlags">
            <summary>
            Surface-relative counter types.
            </summary>
        </member>
        <member name="F:SharpVk.SurfaceCounterFlags.None">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.SurfaceCounterFlags.Vblank">
            <summary>
            ename:VK_SURFACE_COUNTER_VBLANK_EXT A counter incrementing once
            every time a vblank period occurs on the display associated with
            the surface.
            </summary>
        </member>
        <member name="T:SharpVk.SurfaceFormat">
            <summary>
            Structure describing a supported swapchain format-color space pair.
            </summary>
        </member>
        <member name="M:SharpVk.SurfaceFormat.#ctor(SharpVk.Format,SharpVk.ColorSpace)">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.SurfaceFormat.Format">
            <summary>
            pname:format is a ename:VkFormat that is compatible with the
            specified surface.
            </summary>
        </member>
        <member name="F:SharpVk.SurfaceFormat.ColorSpace">
            <summary>
            pname:colorSpace is a presentation ename:VkColorSpaceKHR that is
            compatible with the surface.
            </summary>
        </member>
        <member name="M:SharpVk.SurfaceFormat.ToString">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.SurfaceTransformFlags">
            <summary>
            Presentation transforms supported on a device.
            </summary>
        </member>
        <member name="F:SharpVk.SurfaceTransformFlags.None">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.SurfaceTransformFlags.Identity">
            <summary>
            ename:VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR: The image content is
            presented without being transformed.
            </summary>
        </member>
        <member name="F:SharpVk.SurfaceTransformFlags.Rotate90">
            <summary>
            ename:VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR: The image content is
            rotated 90 degrees clockwise.
            </summary>
        </member>
        <member name="F:SharpVk.SurfaceTransformFlags.Rotate180">
            <summary>
            ename:VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR: The image content is
            rotated 180 degrees clockwise.
            </summary>
        </member>
        <member name="F:SharpVk.SurfaceTransformFlags.Rotate270">
            <summary>
            ename:VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR: The image content is
            rotated 270 degrees clockwise.
            </summary>
        </member>
        <member name="F:SharpVk.SurfaceTransformFlags.HorizontalMirror">
            <summary>
            ename:VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR: The image
            content is mirrored horizontally.
            </summary>
        </member>
        <member name="F:SharpVk.SurfaceTransformFlags.HorizontalMirrorRotate90">
            <summary>
            ename:VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR: The
            image content is mirrored horizontally, then rotated 90 degrees
            clockwise.
            </summary>
        </member>
        <member name="F:SharpVk.SurfaceTransformFlags.HorizontalMirrorRotate180">
            <summary>
            ename:VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR:
            The image content is mirrored horizontally, then rotated 180
            degrees clockwise.
            </summary>
        </member>
        <member name="F:SharpVk.SurfaceTransformFlags.HorizontalMirrorRotate270">
            <summary>
            ename:VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR:
            The image content is mirrored horizontally, then rotated 270
            degrees clockwise.
            </summary>
        </member>
        <member name="F:SharpVk.SurfaceTransformFlags.Inherit">
            <summary>
            ename:VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR: The presentation
            transform is not specified, and is instead determined by
            platform-specific considerations and mechanisms outside Vulkan.
            </summary>
        </member>
        <member name="T:SharpVk.Swapchain">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Swapchain.Destroy">
            <summary>
            Destroy a swapchain object.
            </summary>
        </member>
        <member name="M:SharpVk.Swapchain.GetImages">
            <summary>
            Obtain the array of presentable images associated with a swapchain.
            </summary>
        </member>
        <member name="M:SharpVk.Swapchain.AcquireNextImage(System.UInt64,SharpVk.Semaphore,SharpVk.Fence)">
            <summary>
            Retrieve the index of the next available presentable image.
            </summary>
        </member>
        <member name="M:SharpVk.Swapchain.GetCounter(SharpVk.SurfaceCounterFlags)">
            <summary>
            Query the current value of a surface counter.
            </summary>
        </member>
        <member name="P:SharpVk.Swapchain.RawHandle">
            <summary>
            The interop handle for this Swapchain.
            </summary>
        </member>
        <member name="M:SharpVk.Swapchain.Dispose">
            <summary>
            Releases the unmanaged resources associated with this instance and
            destroys the underlying Vulkan handle.
            </summary>
        </member>
        <member name="T:SharpVk.SwapchainCounterCreateInfo">
            <summary>
            Specify the surface counters desired.
            </summary>
        </member>
        <member name="P:SharpVk.SwapchainCounterCreateInfo.SurfaceCounters">
            <summary>
            pname:surfaceCounters is a bitmask containing a bit set for each
            surface counter to enable for the swapchain.
            </summary>
        </member>
        <member name="T:SharpVk.SwapchainCreateFlags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.SwapchainCreateFlags.None">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.SwapchainCreateInfo">
            <summary>
            <para>
            Structure specifying parameters of a newly created swapchain object.
            </para>
            <para>
            [NOTE] .Note ==== Applications should: set this value to ename:VK_TRUE
            if they do not expect to read back the content of presentable images
            before presenting them or after reacquiring them and if their pixel
            shaders do not have any side effects that require them to run for all
            pixels in the presentable image. ====
            </para>
            <para>
            * pname:oldSwapchain, if not code:VK_NULL_HANDLE, specifies the
            swapchain that will be replaced by the new swapchain being created. The
            new swapchain will be a descendant of pname:oldSwapchain. Further, any
            descendants of the new swapchain will also be descendants of
            pname:oldSwapchain. Upon calling fname:vkCreateSwapchainKHR with a
            pname:oldSwapchain that is not code:VK_NULL_HANDLE, any images not
            acquired by the application may: be freed by the implementation, which
            may: occur even if creation of the new swapchain fails. The application
            must: destroy the old swapchain to free all memory associated with the
            old swapchain. The application must: wait for the completion of any
            outstanding rendering to images it currently has acquired at the time
            the swapchain is destroyed. The application can: continue to present
            any images it acquired and has not yet presented using the old
            swapchain, as long as it has not entered a state that causes it to
            return ename:VK_ERROR_OUT_OF_DATE_KHR. However, the application cannot:
            acquire any more images from the old swapchain regardless of whether or
            not creation of the new swapchain succeeds.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.SwapchainCreateInfo.Flags">
            <summary>
            pname:flags is reserved for future use, and must: be zero.
            </summary>
        </member>
        <member name="P:SharpVk.SwapchainCreateInfo.Surface">
            <summary>
            pname:surface is the surface that the swapchain will present images
            to.
            </summary>
        </member>
        <member name="P:SharpVk.SwapchainCreateInfo.MinImageCount">
            <summary>
            pname:minImageCount is the minimum number of presentable images
            that the application needs. The platform will either create the
            swapchain with at least that many images, or will fail to create
            the swapchain.
            </summary>
        </member>
        <member name="P:SharpVk.SwapchainCreateInfo.ImageFormat">
            <summary>
            pname:imageFormat is a slink:VkFormat that is valid for swapchains
            on the specified surface.
            </summary>
        </member>
        <member name="P:SharpVk.SwapchainCreateInfo.ImageColorSpace">
            <summary>
            pname:imageColorSpace is a slink:VkColorSpaceKHR that is valid for
            swapchains on the specified surface.
            </summary>
        </member>
        <member name="P:SharpVk.SwapchainCreateInfo.ImageExtent">
            <summary>
            pname:imageExtent is the size (in pixels) of the swapchain.
            Behavior is platform-dependent when the image extent does not match
            the surface's pname:currentExtent as returned by
            fname:vkGetPhysicalDeviceSurfaceCapabilitiesKHR.
            </summary>
        </member>
        <member name="P:SharpVk.SwapchainCreateInfo.ImageArrayLayers">
            <summary>
            pname:imageArrayLayers is the number of views in a multiview/stereo
            surface. For non-stereoscopic-3D applications, this value is 1.
            </summary>
        </member>
        <member name="P:SharpVk.SwapchainCreateInfo.ImageUsage">
            <summary>
            pname:imageUsage is a bitmask of elink:VkImageUsageFlagBits,
            indicating how the application will use the swapchain's presentable
            images.
            </summary>
        </member>
        <member name="P:SharpVk.SwapchainCreateInfo.ImageSharingMode">
            <summary>
            pname:imageSharingMode is the sharing mode used for the images of
            the swapchain.
            </summary>
        </member>
        <member name="P:SharpVk.SwapchainCreateInfo.QueueFamilyIndices">
            <summary>
            pname:pQueueFamilyIndices is an array of queue family indices
            having access to the images of the swapchain in case
            pname:imageSharingMode is ename:VK_SHARING_MODE_CONCURRENT.
            </summary>
        </member>
        <member name="P:SharpVk.SwapchainCreateInfo.PreTransform">
            <summary>
            pname:preTransform is a bitmask of
            elink:VkSurfaceTransformFlagBitsKHR, describing the transform,
            relative to the presentation engine's natural orientation, applied
            to the image content prior to presentation. If it does not match
            the pname:currentTransform value returned by
            fname:vkGetPhysicalDeviceSurfaceCapabilitiesKHR, the presentation
            engine will transform the image content as part of the presentation
            operation.
            </summary>
        </member>
        <member name="P:SharpVk.SwapchainCreateInfo.CompositeAlpha">
            <summary>
            pname:compositeAlpha is a bitmask of
            elink:VkCompositeAlphaFlagBitsKHR, indicating the alpha compositing
            mode to use when this surface is composited together with other
            surfaces on certain window systems.
            </summary>
        </member>
        <member name="P:SharpVk.SwapchainCreateInfo.PresentMode">
            <summary>
            pname:presentMode is the presentation mode the swapchain will use.
            A swapchain's present mode determines how incoming present requests
            will be processed and queued internally.
            </summary>
        </member>
        <member name="P:SharpVk.SwapchainCreateInfo.Clipped">
            <summary>
            pname:clipped indicates whether the Vulkan implementation is
            allowed to discard rendering operations that affect regions of the
            surface which are not visible.
            </summary>
        </member>
        <member name="P:SharpVk.SwapchainCreateInfo.OldSwapchain">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.SystemAllocationScope">
            <summary>
            <para>
            Allocation scope.
            </para>
            <para>
            Most Vulkan commands operate on a single object, or there is a sole
            object that is being created or manipulated. When an allocation uses an
            allocation scope of ename:VK_SYSTEM_ALLOCATION_SCOPE_OBJECT or
            ename:VK_SYSTEM_ALLOCATION_SCOPE_CACHE, the allocation is scoped to the
            object being created or manipulated.
            </para>
            <para>
            When an implementation requires host memory, it will make callbacks to
            the application using the most specific allocator and allocation scope
            available:
            </para>
            </summary>
        </member>
        <member name="F:SharpVk.SystemAllocationScope.Command">
            <summary>
            ename:VK_SYSTEM_ALLOCATION_SCOPE_COMMAND - The allocation is scoped
            to the duration of the Vulkan command.
            </summary>
        </member>
        <member name="F:SharpVk.SystemAllocationScope.Object">
            <summary>
            ename:VK_SYSTEM_ALLOCATION_SCOPE_OBJECT - The allocation is scoped
            to the lifetime of the Vulkan object that is being created or used.
            </summary>
        </member>
        <member name="F:SharpVk.SystemAllocationScope.Cache">
            <summary>
            ename:VK_SYSTEM_ALLOCATION_SCOPE_CACHE - The allocation is scoped
            to the lifetime of a sname:VkPipelineCache object.
            </summary>
        </member>
        <member name="F:SharpVk.SystemAllocationScope.Device">
            <summary>
            ename:VK_SYSTEM_ALLOCATION_SCOPE_DEVICE - The allocation is scoped
            to the lifetime of the Vulkan device.
            </summary>
        </member>
        <member name="F:SharpVk.SystemAllocationScope.Instance">
            <summary>
            ename:VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE - The allocation is
            scoped to the lifetime of the Vulkan instance.
            </summary>
        </member>
        <member name="T:SharpVk.ValidationCheck">
            <summary>
            Specify validation checks to disable.
            </summary>
        </member>
        <member name="F:SharpVk.ValidationCheck.All">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.ValidationFlags">
            <summary>
            Specify validation checks to disable for a Vulkan instance.
            </summary>
        </member>
        <member name="P:SharpVk.ValidationFlags.DisabledValidationChecks">
            <summary>
            pname:pDisabledValidationChecks is a pointer to an array of values
            specifying the validation checks to be disabled. Checks which may:
            be specified include: + --
            </summary>
        </member>
        <member name="T:SharpVk.Version">
            <summary>
            Represents a Semantic Version number encoded as a UInt32
            </summary>
        </member>
        <member name="M:SharpVk.Version.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Create a new version number with the specified values.
            </summary>
            <param name="major">
            The Major version number.
            </param>
            <param name="minor">
            The Minor version number.
            </param>
            <param name="patch">
            The Patch version number.
            </param>
        </member>
        <member name="P:SharpVk.Version.Major">
            <summary>
            The Major version number.
            </summary>
        </member>
        <member name="P:SharpVk.Version.Minor">
            <summary>
            The Minor version number.
            </summary>
        </member>
        <member name="P:SharpVk.Version.Patch">
            <summary>
            The Patch version number.
            </summary>
        </member>
        <member name="M:SharpVk.Version.op_Implicit(System.UInt32)~SharpVk.Version">
            <summary>
            Implicit conversion of a UInt32 value to a decoded Version number.
            </summary>
            <param name="value">
            A semantic version number encoded as a UInt32.
            </param>
        </member>
        <member name="M:SharpVk.Version.op_Explicit(SharpVk.Version)~System.UInt32">
            <summary>
            Explicit conversion of a Version number to an encoded UInt32.
            </summary>
            <param name="size">
            The version number value to encode.
            </param>
        </member>
        <member name="M:SharpVk.Version.ToString">
            <summary>
            Returns a string that represents the current object
            </summary>
            <returns>
            A version string of the format "{Major}.{Minor}.{Patch}".
            </returns>
        </member>
        <member name="T:SharpVk.VertexInputAttributeDescription">
            <summary>
            Structure specifying vertex input attribute description.
            </summary>
        </member>
        <member name="M:SharpVk.VertexInputAttributeDescription.#ctor(System.UInt32,System.UInt32,SharpVk.Format,System.UInt32)">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.VertexInputAttributeDescription.Location">
            <summary>
            pname:location is the shader binding location number for this
            attribute.
            </summary>
        </member>
        <member name="F:SharpVk.VertexInputAttributeDescription.Binding">
            <summary>
            pname:binding is the binding number which this attribute takes its
            data from.
            </summary>
        </member>
        <member name="F:SharpVk.VertexInputAttributeDescription.Format">
            <summary>
            pname:format is the size and type of the vertex attribute data.
            </summary>
        </member>
        <member name="F:SharpVk.VertexInputAttributeDescription.Offset">
            <summary>
            pname:offset is a byte offset of this attribute relative to the
            start of an element in the vertex input binding.
            </summary>
        </member>
        <member name="M:SharpVk.VertexInputAttributeDescription.ToString">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.VertexInputBindingDescription">
            <summary>
            Structure specifying vertex input binding description.
            </summary>
        </member>
        <member name="M:SharpVk.VertexInputBindingDescription.#ctor(System.UInt32,System.UInt32,SharpVk.VertexInputRate)">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.VertexInputBindingDescription.Binding">
            <summary>
            pname:binding is the binding number that this structure describes.
            </summary>
        </member>
        <member name="F:SharpVk.VertexInputBindingDescription.Stride">
            <summary>
            pname:stride is the distance in bytes between two consecutive
            elements within the buffer.
            </summary>
        </member>
        <member name="F:SharpVk.VertexInputBindingDescription.InputRate">
            <summary>
            pname:inputRate specifies whether vertex attribute addressing is a
            function of the vertex index or of the instance index. Possible
            values include: + --
            </summary>
        </member>
        <member name="M:SharpVk.VertexInputBindingDescription.ToString">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.VertexInputRate">
            <summary>
            Specify rate at which vertex attributes are pulled from buffers.
            </summary>
        </member>
        <member name="F:SharpVk.VertexInputRate.Vertex">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.VertexInputRate.Instance">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Viewport">
            <summary>
            <para>
            Structure specifying a viewport.
            </para>
            <para>
            The framebuffer depth coordinate [eq]#pname:z~f~# may: be represented
            using either a fixed-point or floating-point representation. However, a
            floating-point representation must: be used if the depth/stencil
            attachment has a floating-point depth component. If an [eq]#m#-bit
            fixed-point representation is used, we assume that it represents each
            value latexmath:[\frac{k}{2^m - 1}], where [eq]#k {elem} { 0, 1, ...,
            2^m^-1 }#, as [eq]#k# (e.g. 1.0 is represented in binary as a string of
            all ones).
            </para>
            <para>
            The viewport parameters shown in the above equations are found from
            these values as
            </para>
            <para>
            :: [eq]#o~x~ = pname:x + pname:width / 2# :: [eq]#o~y~ = pname:y +
            pname:height / 2# :: [eq]#o~z~ = pname:minDepth# :: [eq]#p~x~ =
            pname:width# :: [eq]#p~y~ = pname:height# :: [eq]#p~z~ = pname:maxDepth
            - pname:minDepth#.
            </para>
            <para>
            ifdef::VK_KHR_maintenance1[] The application can: specify a negative
            term for pname:height, which has the effect of negating the y
            coordinate in clip space before performing the transform. When using a
            negative pname:height, the application should: also adjust the pname:y
            value to point to the lower left corner of the viewport instead of the
            upper left corner. Using the negative pname:height allows the
            application to avoid having to negate the y component of the
            code:Position output from the last vertex processing stage in shaders
            that also target other graphics APIs. endif::VK_KHR_maintenance1[]
            </para>
            <para>
            The width and height of the
            &lt;&lt;features-limits-maxViewportDimensions, implementation-dependent
            maximum viewport dimensions&gt;&gt; must: be greater than or equal to
            the width and height of the largest image which can: be created and
            attached to a framebuffer.
            </para>
            <para>
            The floating-point viewport bounds are represented with an
            &lt;&lt;features-limits-viewportSubPixelBits,implementation-dependent precision&gt;&gt;.
            </para>
            </summary>
        </member>
        <member name="M:SharpVk.Viewport.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpVk.Viewport.X">
            <summary>
            pname:x and pname:y are the viewport's upper left corner
            [eq]#(x,y)#.
            </summary>
        </member>
        <member name="F:SharpVk.Viewport.Y">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Viewport.Width">
            <summary>
            pname:width and pname:height are the viewport's width and height,
            respectively.
            </summary>
        </member>
        <member name="F:SharpVk.Viewport.Height">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Viewport.MinDepth">
            <summary>
            pname:minDepth and pname:maxDepth are the depth range for the
            viewport. It is valid for pname:minDepth to be greater than or
            equal to pname:maxDepth.
            </summary>
        </member>
        <member name="F:SharpVk.Viewport.MaxDepth">
            <summary>
            -
            </summary>
        </member>
        <member name="M:SharpVk.Viewport.ToString">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpVk.ViSurfaceCreateFlags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.ViSurfaceCreateFlags.None">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.ViSurfaceCreateInfo">
            <summary>
            Structure specifying parameters of a newly created VI surface object.
            </summary>
        </member>
        <member name="P:SharpVk.ViSurfaceCreateInfo.Flags">
            <summary>
            pname:flags is reserved for future use.
            </summary>
        </member>
        <member name="P:SharpVk.ViSurfaceCreateInfo.Window">
            <summary>
            pname:window is the code:nn::code:vi::code:NativeWindowHandle for
            the code:nn::code:vi::code:Layer with which to associate the
            surface.
            </summary>
        </member>
        <member name="T:SharpVk.WaylandSurfaceCreateFlags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.WaylandSurfaceCreateFlags.None">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.WaylandSurfaceCreateInfo">
            <summary>
            Structure specifying parameters of a newly created Wayland surface
            object.
            </summary>
        </member>
        <member name="P:SharpVk.WaylandSurfaceCreateInfo.Flags">
            <summary>
            pname:flags is reserved for future use.
            </summary>
        </member>
        <member name="P:SharpVk.WaylandSurfaceCreateInfo.Display">
            <summary>
            pname:display and pname:surface are pointers to the Wayland
            code:wl_display and code:wl_surface to associate the surface with.
            </summary>
        </member>
        <member name="P:SharpVk.WaylandSurfaceCreateInfo.Surface">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Win32KeyedMutexAcquireReleaseInfo">
            <summary>
            <para>
            Use Windows keyex mutex mechanism to synchronize work.
            </para>
            <para>
            When submitting work that operates on memory imported from a Direct3D
            11 resource to a queue, the keyed mutex mechanism may: be used in
            addition to Vulkan semaphores to synchronize the work. Keyed mutexes
            are a property of a properly created shareable Direct3D 11 resource.
            They can: only be used if the imported resource was created with the
            etext:D3D11_RESOURCE_MISC_SHARED_KEYEDMUTEX flag.
            </para>
            <para>
            To acquire keyed mutexes before submitted work and/or release them
            after, add a slink:VkWin32KeyedMutexAcquireReleaseInfoNV structure to
            the pname:pNext chain of the slink:VkSubmitInfo structure.
            </para>
            <para>
            * pname:acquireCount is the number of entries in the
            pname:pAcquireSyncs, pname:pAcquireKeys, and
            pname:pAcquireTimeoutMilliseconds arrays. * pname:pAcquireSyncs is a
            pointer to an array of slink:VkDeviceMemory objects which were imported
            from Direct3D 11 resources. * pname:pAcquireKeys is a pointer to an
            array of mutex key values to wait for prior to beginning the submitted
            work. Entries refer to the keyed mutex associated with the
            corresponding entries in pname:pAcquireSyncs. *
            pname:pAcquireTimeoutMilliseconds is an array of timeout values, in
            millisecond units, for each acquire specified in pname:pAcquireKeys. *
            pname:releaseCount is the number of entries in the pname:pReleaseSyncs
            and pname:pReleaseKeys arrays. * pname:pReleaseSyncs is a pointer to an
            array of slink:VkDeviceMemory objects which were imported from Direct3D
            11 resources. * pname:pReleaseKeys is a pointer to an array of mutex
            key values to set when the submitted work has completed. Entries refer
            to the keyed mutex associated with the corresponding entries in
            pname:pReleaseSyncs.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.Win32KeyedMutexAcquireReleaseInfo.AcquireSyncs">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.Win32KeyedMutexAcquireReleaseInfo.AcquireKeys">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.Win32KeyedMutexAcquireReleaseInfo.AcquireTimeoutMilliseconds">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.Win32KeyedMutexAcquireReleaseInfo.ReleaseSyncs">
            <summary>
            -
            </summary>
        </member>
        <member name="P:SharpVk.Win32KeyedMutexAcquireReleaseInfo.ReleaseKeys">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Win32SurfaceCreateFlags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.Win32SurfaceCreateFlags.None">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.Win32SurfaceCreateInfo">
            <summary>
            Structure specifying parameters of a newly created Win32 surface
            object.
            </summary>
        </member>
        <member name="P:SharpVk.Win32SurfaceCreateInfo.Flags">
            <summary>
            pname:flags is reserved for future use.
            </summary>
        </member>
        <member name="P:SharpVk.Win32SurfaceCreateInfo.Hinstance">
            <summary>
            pname:hinstance and pname:hwnd are the Win32 code:HINSTANCE and
            code:HWND for the window to associate the surface with.
            </summary>
        </member>
        <member name="P:SharpVk.Win32SurfaceCreateInfo.Hwnd">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.WriteDescriptorSet">
            <summary>
            <para>
            Structure specifying the parameters of a descriptor set write
            operation.
            </para>
            <para>
            Only one of pname:pImageInfo, pname:pBufferInfo, or
            pname:pTexelBufferView members is used according to the descriptor type
            specified in the pname:descriptorType member of the containing
            sname:VkWriteDescriptorSet structure, as specified below.
            </para>
            <para>
            [[descriptorsets-updates-consecutive, consecutive binding updates]] If
            the pname:dstBinding has fewer than pname:descriptorCount array
            elements remaining starting from pname:dstArrayElement, then the
            remainder will be used to update the subsequent binding -
            pname:dstBinding+1 starting at array element zero. If a binding has a
            pname:descriptorCount of zero, it is skipped. This behavior applies
            recursively, with the update affecting consecutive bindings as needed
            to update all pname:descriptorCount descriptors. All consecutive
            bindings updated via a single sname:VkWriteDescriptorSet structure,
            except those with a pname:descriptorCount of zero, must: have identical
            pname:descriptorType and pname:stageFlags, and must: all either use
            immutable samplers or must: all not use immutable samplers.
            </para>
            </summary>
        </member>
        <member name="P:SharpVk.WriteDescriptorSet.DestinationSet">
            <summary>
            pname:dstSet is the destination descriptor set to update.
            </summary>
        </member>
        <member name="P:SharpVk.WriteDescriptorSet.DestinationBinding">
            <summary>
            pname:dstBinding is the descriptor binding within that set.
            </summary>
        </member>
        <member name="P:SharpVk.WriteDescriptorSet.DestinationArrayElement">
            <summary>
            pname:dstArrayElement is the starting element in that array.
            </summary>
        </member>
        <member name="P:SharpVk.WriteDescriptorSet.DescriptorType">
            <summary>
            pname:descriptorType is a elink:VkDescriptorType specifying the
            type of each descriptor in pname:pImageInfo, pname:pBufferInfo, or
            pname:pTexelBufferView, as described below. It must: be the same
            type as that specified in sname:VkDescriptorSetLayoutBinding for
            pname:dstSet at pname:dstBinding. The type of the descriptor also
            controls which array the descriptors are taken from.
            </summary>
        </member>
        <member name="P:SharpVk.WriteDescriptorSet.ImageInfo">
            <summary>
            pname:pImageInfo points to an array of slink:VkDescriptorImageInfo
            structures or is ignored, as described below.
            </summary>
        </member>
        <member name="P:SharpVk.WriteDescriptorSet.BufferInfo">
            <summary>
            pname:pBufferInfo points to an array of
            slink:VkDescriptorBufferInfo structures or is ignored, as described
            below.
            </summary>
        </member>
        <member name="P:SharpVk.WriteDescriptorSet.TexelBufferView">
            <summary>
            pname:pTexelBufferView points to an array of slink:VkBufferView
            handles as described in the &lt;&lt;resources-buffer-views,Buffer
            Views&gt;&gt; section or is ignored, as described below.
            </summary>
        </member>
        <member name="T:SharpVk.XcbSurfaceCreateFlags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.XcbSurfaceCreateFlags.None">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.XcbSurfaceCreateInfo">
            <summary>
            Structure specifying parameters of a newly created Xcb surface object.
            </summary>
        </member>
        <member name="P:SharpVk.XcbSurfaceCreateInfo.Flags">
            <summary>
            pname:flags is reserved for future use.
            </summary>
        </member>
        <member name="P:SharpVk.XcbSurfaceCreateInfo.Connection">
            <summary>
            pname:connection is a pointer to an code:xcb_connection_t to the X
            server.
            </summary>
        </member>
        <member name="P:SharpVk.XcbSurfaceCreateInfo.Window">
            <summary>
            pname:window is the code:xcb_window_t for the X11 window to
            associate the surface with.
            </summary>
        </member>
        <member name="T:SharpVk.XlibSurfaceCreateFlags">
            <summary>
            -
            </summary>
        </member>
        <member name="F:SharpVk.XlibSurfaceCreateFlags.None">
            <summary>
            -
            </summary>
        </member>
        <member name="T:SharpVk.XlibSurfaceCreateInfo">
            <summary>
            Structure specifying parameters of a newly created Xlib surface object.
            </summary>
        </member>
        <member name="P:SharpVk.XlibSurfaceCreateInfo.Flags">
            <summary>
            pname:flags is reserved for future use.
            </summary>
        </member>
        <member name="P:SharpVk.XlibSurfaceCreateInfo.Dpy">
            <summary>
            pname:dpy is a pointer to an Xlib code:Display connection to the X
            server.
            </summary>
        </member>
        <member name="P:SharpVk.XlibSurfaceCreateInfo.Window">
            <summary>
            pname:window is an Xlib code:Window to associate the surface with.
            </summary>
        </member>
    </members>
</doc>
